
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Items
 * 
 */
export type Items = $Result.DefaultSelection<Prisma.$ItemsPayload>
/**
 * Model Suppliers
 * 
 */
export type Suppliers = $Result.DefaultSelection<Prisma.$SuppliersPayload>
/**
 * Model Brands
 * 
 */
export type Brands = $Result.DefaultSelection<Prisma.$BrandsPayload>
/**
 * Model Warehouses
 * 
 */
export type Warehouses = $Result.DefaultSelection<Prisma.$WarehousesPayload>
/**
 * Model Inventory
 * 
 */
export type Inventory = $Result.DefaultSelection<Prisma.$InventoryPayload>
/**
 * Model Units
 * 
 */
export type Units = $Result.DefaultSelection<Prisma.$UnitsPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Terms
 * 
 */
export type Terms = $Result.DefaultSelection<Prisma.$TermsPayload>
/**
 * Model SupplierTransactions
 * 
 */
export type SupplierTransactions = $Result.DefaultSelection<Prisma.$SupplierTransactionsPayload>
/**
 * Model SupplierInvoices
 * 
 */
export type SupplierInvoices = $Result.DefaultSelection<Prisma.$SupplierInvoicesPayload>
/**
 * Model CustomerTransactions
 * 
 */
export type CustomerTransactions = $Result.DefaultSelection<Prisma.$CustomerTransactionsPayload>
/**
 * Model CustomerInvoices
 * 
 */
export type CustomerInvoices = $Result.DefaultSelection<Prisma.$CustomerInvoicesPayload>
/**
 * Model WarehouseTransactions
 * 
 */
export type WarehouseTransactions = $Result.DefaultSelection<Prisma.$WarehouseTransactionsPayload>
/**
 * Model WarehouseInvoices
 * 
 */
export type WarehouseInvoices = $Result.DefaultSelection<Prisma.$WarehouseInvoicesPayload>
/**
 * Model CounterReceipts
 * 
 */
export type CounterReceipts = $Result.DefaultSelection<Prisma.$CounterReceiptsPayload>
/**
 * Model CheckVouchers
 * 
 */
export type CheckVouchers = $Result.DefaultSelection<Prisma.$CheckVouchersPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.items`: Exposes CRUD operations for the **Items** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.items.findMany()
    * ```
    */
  get items(): Prisma.ItemsDelegate<ExtArgs>;

  /**
   * `prisma.suppliers`: Exposes CRUD operations for the **Suppliers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.suppliers.findMany()
    * ```
    */
  get suppliers(): Prisma.SuppliersDelegate<ExtArgs>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **Brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.BrandsDelegate<ExtArgs>;

  /**
   * `prisma.warehouses`: Exposes CRUD operations for the **Warehouses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warehouses
    * const warehouses = await prisma.warehouses.findMany()
    * ```
    */
  get warehouses(): Prisma.WarehousesDelegate<ExtArgs>;

  /**
   * `prisma.inventory`: Exposes CRUD operations for the **Inventory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inventories
    * const inventories = await prisma.inventory.findMany()
    * ```
    */
  get inventory(): Prisma.InventoryDelegate<ExtArgs>;

  /**
   * `prisma.units`: Exposes CRUD operations for the **Units** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.units.findMany()
    * ```
    */
  get units(): Prisma.UnitsDelegate<ExtArgs>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs>;

  /**
   * `prisma.terms`: Exposes CRUD operations for the **Terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terms
    * const terms = await prisma.terms.findMany()
    * ```
    */
  get terms(): Prisma.TermsDelegate<ExtArgs>;

  /**
   * `prisma.supplierTransactions`: Exposes CRUD operations for the **SupplierTransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierTransactions
    * const supplierTransactions = await prisma.supplierTransactions.findMany()
    * ```
    */
  get supplierTransactions(): Prisma.SupplierTransactionsDelegate<ExtArgs>;

  /**
   * `prisma.supplierInvoices`: Exposes CRUD operations for the **SupplierInvoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierInvoices
    * const supplierInvoices = await prisma.supplierInvoices.findMany()
    * ```
    */
  get supplierInvoices(): Prisma.SupplierInvoicesDelegate<ExtArgs>;

  /**
   * `prisma.customerTransactions`: Exposes CRUD operations for the **CustomerTransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerTransactions
    * const customerTransactions = await prisma.customerTransactions.findMany()
    * ```
    */
  get customerTransactions(): Prisma.CustomerTransactionsDelegate<ExtArgs>;

  /**
   * `prisma.customerInvoices`: Exposes CRUD operations for the **CustomerInvoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerInvoices
    * const customerInvoices = await prisma.customerInvoices.findMany()
    * ```
    */
  get customerInvoices(): Prisma.CustomerInvoicesDelegate<ExtArgs>;

  /**
   * `prisma.warehouseTransactions`: Exposes CRUD operations for the **WarehouseTransactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseTransactions
    * const warehouseTransactions = await prisma.warehouseTransactions.findMany()
    * ```
    */
  get warehouseTransactions(): Prisma.WarehouseTransactionsDelegate<ExtArgs>;

  /**
   * `prisma.warehouseInvoices`: Exposes CRUD operations for the **WarehouseInvoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WarehouseInvoices
    * const warehouseInvoices = await prisma.warehouseInvoices.findMany()
    * ```
    */
  get warehouseInvoices(): Prisma.WarehouseInvoicesDelegate<ExtArgs>;

  /**
   * `prisma.counterReceipts`: Exposes CRUD operations for the **CounterReceipts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CounterReceipts
    * const counterReceipts = await prisma.counterReceipts.findMany()
    * ```
    */
  get counterReceipts(): Prisma.CounterReceiptsDelegate<ExtArgs>;

  /**
   * `prisma.checkVouchers`: Exposes CRUD operations for the **CheckVouchers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheckVouchers
    * const checkVouchers = await prisma.checkVouchers.findMany()
    * ```
    */
  get checkVouchers(): Prisma.CheckVouchersDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.8.1
   * Query Engine version: 78caf6feeaed953168c64e15a249c3e9a033ebe2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Items: 'Items',
    Suppliers: 'Suppliers',
    Brands: 'Brands',
    Warehouses: 'Warehouses',
    Inventory: 'Inventory',
    Units: 'Units',
    Customers: 'Customers',
    Terms: 'Terms',
    SupplierTransactions: 'SupplierTransactions',
    SupplierInvoices: 'SupplierInvoices',
    CustomerTransactions: 'CustomerTransactions',
    CustomerInvoices: 'CustomerInvoices',
    WarehouseTransactions: 'WarehouseTransactions',
    WarehouseInvoices: 'WarehouseInvoices',
    CounterReceipts: 'CounterReceipts',
    CheckVouchers: 'CheckVouchers'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'session' | 'user' | 'verificationToken' | 'items' | 'suppliers' | 'brands' | 'warehouses' | 'inventory' | 'units' | 'customers' | 'terms' | 'supplierTransactions' | 'supplierInvoices' | 'customerTransactions' | 'customerInvoices' | 'warehouseTransactions' | 'warehouseInvoices' | 'counterReceipts' | 'checkVouchers'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Items: {
        payload: Prisma.$ItemsPayload<ExtArgs>
        fields: Prisma.ItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          findFirst: {
            args: Prisma.ItemsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          findMany: {
            args: Prisma.ItemsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>[]
          }
          create: {
            args: Prisma.ItemsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          createMany: {
            args: Prisma.ItemsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ItemsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          update: {
            args: Prisma.ItemsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          deleteMany: {
            args: Prisma.ItemsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ItemsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ItemsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ItemsPayload>
          }
          aggregate: {
            args: Prisma.ItemsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateItems>
          }
          groupBy: {
            args: Prisma.ItemsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemsCountArgs<ExtArgs>,
            result: $Utils.Optional<ItemsCountAggregateOutputType> | number
          }
        }
      }
      Suppliers: {
        payload: Prisma.$SuppliersPayload<ExtArgs>
        fields: Prisma.SuppliersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuppliersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuppliersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findFirst: {
            args: Prisma.SuppliersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuppliersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          findMany: {
            args: Prisma.SuppliersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>[]
          }
          create: {
            args: Prisma.SuppliersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          createMany: {
            args: Prisma.SuppliersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SuppliersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          update: {
            args: Prisma.SuppliersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          deleteMany: {
            args: Prisma.SuppliersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SuppliersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SuppliersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SuppliersPayload>
          }
          aggregate: {
            args: Prisma.SuppliersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSuppliers>
          }
          groupBy: {
            args: Prisma.SuppliersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SuppliersGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuppliersCountArgs<ExtArgs>,
            result: $Utils.Optional<SuppliersCountAggregateOutputType> | number
          }
        }
      }
      Brands: {
        payload: Prisma.$BrandsPayload<ExtArgs>
        fields: Prisma.BrandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          findFirst: {
            args: Prisma.BrandsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          findMany: {
            args: Prisma.BrandsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>[]
          }
          create: {
            args: Prisma.BrandsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          createMany: {
            args: Prisma.BrandsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BrandsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          update: {
            args: Prisma.BrandsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          deleteMany: {
            args: Prisma.BrandsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BrandsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BrandsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BrandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.BrandsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandsCountArgs<ExtArgs>,
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      Warehouses: {
        payload: Prisma.$WarehousesPayload<ExtArgs>
        fields: Prisma.WarehousesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehousesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehousesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          findFirst: {
            args: Prisma.WarehousesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehousesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          findMany: {
            args: Prisma.WarehousesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>[]
          }
          create: {
            args: Prisma.WarehousesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          createMany: {
            args: Prisma.WarehousesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WarehousesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          update: {
            args: Prisma.WarehousesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          deleteMany: {
            args: Prisma.WarehousesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WarehousesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WarehousesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehousesPayload>
          }
          aggregate: {
            args: Prisma.WarehousesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarehouses>
          }
          groupBy: {
            args: Prisma.WarehousesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarehousesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehousesCountArgs<ExtArgs>,
            result: $Utils.Optional<WarehousesCountAggregateOutputType> | number
          }
        }
      }
      Inventory: {
        payload: Prisma.$InventoryPayload<ExtArgs>
        fields: Prisma.InventoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findFirst: {
            args: Prisma.InventoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          findMany: {
            args: Prisma.InventoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>[]
          }
          create: {
            args: Prisma.InventoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          createMany: {
            args: Prisma.InventoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InventoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          update: {
            args: Prisma.InventoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          deleteMany: {
            args: Prisma.InventoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InventoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InventoryPayload>
          }
          aggregate: {
            args: Prisma.InventoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInventory>
          }
          groupBy: {
            args: Prisma.InventoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InventoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryCountArgs<ExtArgs>,
            result: $Utils.Optional<InventoryCountAggregateOutputType> | number
          }
        }
      }
      Units: {
        payload: Prisma.$UnitsPayload<ExtArgs>
        fields: Prisma.UnitsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          findFirst: {
            args: Prisma.UnitsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          findMany: {
            args: Prisma.UnitsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>[]
          }
          create: {
            args: Prisma.UnitsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          createMany: {
            args: Prisma.UnitsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UnitsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          update: {
            args: Prisma.UnitsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          deleteMany: {
            args: Prisma.UnitsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UnitsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UnitsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UnitsPayload>
          }
          aggregate: {
            args: Prisma.UnitsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUnits>
          }
          groupBy: {
            args: Prisma.UnitsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UnitsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitsCountArgs<ExtArgs>,
            result: $Utils.Optional<UnitsCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Terms: {
        payload: Prisma.$TermsPayload<ExtArgs>
        fields: Prisma.TermsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TermsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TermsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          findFirst: {
            args: Prisma.TermsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TermsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          findMany: {
            args: Prisma.TermsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>[]
          }
          create: {
            args: Prisma.TermsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          createMany: {
            args: Prisma.TermsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TermsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          update: {
            args: Prisma.TermsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          deleteMany: {
            args: Prisma.TermsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TermsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TermsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TermsPayload>
          }
          aggregate: {
            args: Prisma.TermsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTerms>
          }
          groupBy: {
            args: Prisma.TermsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TermsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TermsCountArgs<ExtArgs>,
            result: $Utils.Optional<TermsCountAggregateOutputType> | number
          }
        }
      }
      SupplierTransactions: {
        payload: Prisma.$SupplierTransactionsPayload<ExtArgs>
        fields: Prisma.SupplierTransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierTransactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierTransactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          findFirst: {
            args: Prisma.SupplierTransactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierTransactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          findMany: {
            args: Prisma.SupplierTransactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>[]
          }
          create: {
            args: Prisma.SupplierTransactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          createMany: {
            args: Prisma.SupplierTransactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierTransactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          update: {
            args: Prisma.SupplierTransactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          deleteMany: {
            args: Prisma.SupplierTransactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierTransactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierTransactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierTransactionsPayload>
          }
          aggregate: {
            args: Prisma.SupplierTransactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplierTransactions>
          }
          groupBy: {
            args: Prisma.SupplierTransactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierTransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierTransactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierTransactionsCountAggregateOutputType> | number
          }
        }
      }
      SupplierInvoices: {
        payload: Prisma.$SupplierInvoicesPayload<ExtArgs>
        fields: Prisma.SupplierInvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierInvoicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierInvoicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          findFirst: {
            args: Prisma.SupplierInvoicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierInvoicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          findMany: {
            args: Prisma.SupplierInvoicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>[]
          }
          create: {
            args: Prisma.SupplierInvoicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          createMany: {
            args: Prisma.SupplierInvoicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierInvoicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          update: {
            args: Prisma.SupplierInvoicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          deleteMany: {
            args: Prisma.SupplierInvoicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierInvoicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierInvoicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SupplierInvoicesPayload>
          }
          aggregate: {
            args: Prisma.SupplierInvoicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplierInvoices>
          }
          groupBy: {
            args: Prisma.SupplierInvoicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierInvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierInvoicesCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierInvoicesCountAggregateOutputType> | number
          }
        }
      }
      CustomerTransactions: {
        payload: Prisma.$CustomerTransactionsPayload<ExtArgs>
        fields: Prisma.CustomerTransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerTransactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerTransactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          findFirst: {
            args: Prisma.CustomerTransactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerTransactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          findMany: {
            args: Prisma.CustomerTransactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>[]
          }
          create: {
            args: Prisma.CustomerTransactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          createMany: {
            args: Prisma.CustomerTransactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomerTransactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          update: {
            args: Prisma.CustomerTransactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerTransactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerTransactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomerTransactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerTransactionsPayload>
          }
          aggregate: {
            args: Prisma.CustomerTransactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerTransactions>
          }
          groupBy: {
            args: Prisma.CustomerTransactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerTransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerTransactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerTransactionsCountAggregateOutputType> | number
          }
        }
      }
      CustomerInvoices: {
        payload: Prisma.$CustomerInvoicesPayload<ExtArgs>
        fields: Prisma.CustomerInvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerInvoicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerInvoicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          findFirst: {
            args: Prisma.CustomerInvoicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerInvoicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          findMany: {
            args: Prisma.CustomerInvoicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>[]
          }
          create: {
            args: Prisma.CustomerInvoicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          createMany: {
            args: Prisma.CustomerInvoicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomerInvoicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          update: {
            args: Prisma.CustomerInvoicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          deleteMany: {
            args: Prisma.CustomerInvoicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerInvoicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomerInvoicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerInvoicesPayload>
          }
          aggregate: {
            args: Prisma.CustomerInvoicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomerInvoices>
          }
          groupBy: {
            args: Prisma.CustomerInvoicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerInvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerInvoicesCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerInvoicesCountAggregateOutputType> | number
          }
        }
      }
      WarehouseTransactions: {
        payload: Prisma.$WarehouseTransactionsPayload<ExtArgs>
        fields: Prisma.WarehouseTransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseTransactionsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseTransactionsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          findFirst: {
            args: Prisma.WarehouseTransactionsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseTransactionsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          findMany: {
            args: Prisma.WarehouseTransactionsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>[]
          }
          create: {
            args: Prisma.WarehouseTransactionsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          createMany: {
            args: Prisma.WarehouseTransactionsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WarehouseTransactionsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          update: {
            args: Prisma.WarehouseTransactionsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseTransactionsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseTransactionsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseTransactionsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseTransactionsPayload>
          }
          aggregate: {
            args: Prisma.WarehouseTransactionsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarehouseTransactions>
          }
          groupBy: {
            args: Prisma.WarehouseTransactionsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseTransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseTransactionsCountArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseTransactionsCountAggregateOutputType> | number
          }
        }
      }
      WarehouseInvoices: {
        payload: Prisma.$WarehouseInvoicesPayload<ExtArgs>
        fields: Prisma.WarehouseInvoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WarehouseInvoicesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WarehouseInvoicesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          findFirst: {
            args: Prisma.WarehouseInvoicesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WarehouseInvoicesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          findMany: {
            args: Prisma.WarehouseInvoicesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>[]
          }
          create: {
            args: Prisma.WarehouseInvoicesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          createMany: {
            args: Prisma.WarehouseInvoicesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WarehouseInvoicesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          update: {
            args: Prisma.WarehouseInvoicesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          deleteMany: {
            args: Prisma.WarehouseInvoicesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WarehouseInvoicesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WarehouseInvoicesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WarehouseInvoicesPayload>
          }
          aggregate: {
            args: Prisma.WarehouseInvoicesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWarehouseInvoices>
          }
          groupBy: {
            args: Prisma.WarehouseInvoicesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseInvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.WarehouseInvoicesCountArgs<ExtArgs>,
            result: $Utils.Optional<WarehouseInvoicesCountAggregateOutputType> | number
          }
        }
      }
      CounterReceipts: {
        payload: Prisma.$CounterReceiptsPayload<ExtArgs>
        fields: Prisma.CounterReceiptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CounterReceiptsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CounterReceiptsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          findFirst: {
            args: Prisma.CounterReceiptsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CounterReceiptsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          findMany: {
            args: Prisma.CounterReceiptsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>[]
          }
          create: {
            args: Prisma.CounterReceiptsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          createMany: {
            args: Prisma.CounterReceiptsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CounterReceiptsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          update: {
            args: Prisma.CounterReceiptsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          deleteMany: {
            args: Prisma.CounterReceiptsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CounterReceiptsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CounterReceiptsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CounterReceiptsPayload>
          }
          aggregate: {
            args: Prisma.CounterReceiptsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCounterReceipts>
          }
          groupBy: {
            args: Prisma.CounterReceiptsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CounterReceiptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CounterReceiptsCountArgs<ExtArgs>,
            result: $Utils.Optional<CounterReceiptsCountAggregateOutputType> | number
          }
        }
      }
      CheckVouchers: {
        payload: Prisma.$CheckVouchersPayload<ExtArgs>
        fields: Prisma.CheckVouchersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckVouchersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckVouchersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          findFirst: {
            args: Prisma.CheckVouchersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckVouchersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          findMany: {
            args: Prisma.CheckVouchersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>[]
          }
          create: {
            args: Prisma.CheckVouchersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          createMany: {
            args: Prisma.CheckVouchersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CheckVouchersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          update: {
            args: Prisma.CheckVouchersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          deleteMany: {
            args: Prisma.CheckVouchersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CheckVouchersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CheckVouchersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CheckVouchersPayload>
          }
          aggregate: {
            args: Prisma.CheckVouchersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCheckVouchers>
          }
          groupBy: {
            args: Prisma.CheckVouchersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CheckVouchersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckVouchersCountArgs<ExtArgs>,
            result: $Utils.Optional<CheckVouchersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }



  /**
   * Count Type ItemsCountOutputType
   */

  export type ItemsCountOutputType = {
    inventories: number
    supplierTransactions: number
    CustmerTransactions: number
  }

  export type ItemsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventories?: boolean | ItemsCountOutputTypeCountInventoriesArgs
    supplierTransactions?: boolean | ItemsCountOutputTypeCountSupplierTransactionsArgs
    CustmerTransactions?: boolean | ItemsCountOutputTypeCountCustmerTransactionsArgs
  }

  // Custom InputTypes

  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemsCountOutputType
     */
    select?: ItemsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountSupplierTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierTransactionsWhereInput
  }


  /**
   * ItemsCountOutputType without action
   */
  export type ItemsCountOutputTypeCountCustmerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTransactionsWhereInput
  }



  /**
   * Count Type SuppliersCountOutputType
   */

  export type SuppliersCountOutputType = {
    items: number
    Invoices: number
    CheckVouchers: number
  }

  export type SuppliersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | SuppliersCountOutputTypeCountItemsArgs
    Invoices?: boolean | SuppliersCountOutputTypeCountInvoicesArgs
    CheckVouchers?: boolean | SuppliersCountOutputTypeCountCheckVouchersArgs
  }

  // Custom InputTypes

  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuppliersCountOutputType
     */
    select?: SuppliersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }


  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoicesWhereInput
  }


  /**
   * SuppliersCountOutputType without action
   */
  export type SuppliersCountOutputTypeCountCheckVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckVouchersWhereInput
  }



  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    items: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | BrandsCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }



  /**
   * Count Type WarehousesCountOutputType
   */

  export type WarehousesCountOutputType = {
    inventories: number
    Invoices: number
  }

  export type WarehousesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventories?: boolean | WarehousesCountOutputTypeCountInventoriesArgs
    Invoices?: boolean | WarehousesCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes

  /**
   * WarehousesCountOutputType without action
   */
  export type WarehousesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehousesCountOutputType
     */
    select?: WarehousesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WarehousesCountOutputType without action
   */
  export type WarehousesCountOutputTypeCountInventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
  }


  /**
   * WarehousesCountOutputType without action
   */
  export type WarehousesCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseInvoicesWhereInput
  }



  /**
   * Count Type InventoryCountOutputType
   */

  export type InventoryCountOutputType = {
    SupplierTransactions: number
    WarehouseTransactions: number
  }

  export type InventoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SupplierTransactions?: boolean | InventoryCountOutputTypeCountSupplierTransactionsArgs
    WarehouseTransactions?: boolean | InventoryCountOutputTypeCountWarehouseTransactionsArgs
  }

  // Custom InputTypes

  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryCountOutputType
     */
    select?: InventoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountSupplierTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierTransactionsWhereInput
  }


  /**
   * InventoryCountOutputType without action
   */
  export type InventoryCountOutputTypeCountWarehouseTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseTransactionsWhereInput
  }



  /**
   * Count Type UnitsCountOutputType
   */

  export type UnitsCountOutputType = {
    item: number
  }

  export type UnitsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | UnitsCountOutputTypeCountItemArgs
  }

  // Custom InputTypes

  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitsCountOutputType
     */
    select?: UnitsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UnitsCountOutputType without action
   */
  export type UnitsCountOutputTypeCountItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
  }



  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    CustomerInvoices: number
    CounterReceits: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerInvoices?: boolean | CustomersCountOutputTypeCountCustomerInvoicesArgs
    CounterReceits?: boolean | CustomersCountOutputTypeCountCounterReceitsArgs
  }

  // Custom InputTypes

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountCustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoicesWhereInput
  }


  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountCounterReceitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterReceiptsWhereInput
  }



  /**
   * Count Type TermsCountOutputType
   */

  export type TermsCountOutputType = {
    Customers: number
    Suppliers: number
  }

  export type TermsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | TermsCountOutputTypeCountCustomersArgs
    Suppliers?: boolean | TermsCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes

  /**
   * TermsCountOutputType without action
   */
  export type TermsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TermsCountOutputType
     */
    select?: TermsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TermsCountOutputType without action
   */
  export type TermsCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }


  /**
   * TermsCountOutputType without action
   */
  export type TermsCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuppliersWhereInput
  }



  /**
   * Count Type SupplierInvoicesCountOutputType
   */

  export type SupplierInvoicesCountOutputType = {
    Transactions: number
  }

  export type SupplierInvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Transactions?: boolean | SupplierInvoicesCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes

  /**
   * SupplierInvoicesCountOutputType without action
   */
  export type SupplierInvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoicesCountOutputType
     */
    select?: SupplierInvoicesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierInvoicesCountOutputType without action
   */
  export type SupplierInvoicesCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierTransactionsWhereInput
  }



  /**
   * Count Type CustomerInvoicesCountOutputType
   */

  export type CustomerInvoicesCountOutputType = {
    CustmerTransactions: number
  }

  export type CustomerInvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustmerTransactions?: boolean | CustomerInvoicesCountOutputTypeCountCustmerTransactionsArgs
  }

  // Custom InputTypes

  /**
   * CustomerInvoicesCountOutputType without action
   */
  export type CustomerInvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoicesCountOutputType
     */
    select?: CustomerInvoicesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerInvoicesCountOutputType without action
   */
  export type CustomerInvoicesCountOutputTypeCountCustmerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTransactionsWhereInput
  }



  /**
   * Count Type WarehouseInvoicesCountOutputType
   */

  export type WarehouseInvoicesCountOutputType = {
    WarehouseTransactions: number
  }

  export type WarehouseInvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    WarehouseTransactions?: boolean | WarehouseInvoicesCountOutputTypeCountWarehouseTransactionsArgs
  }

  // Custom InputTypes

  /**
   * WarehouseInvoicesCountOutputType without action
   */
  export type WarehouseInvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoicesCountOutputType
     */
    select?: WarehouseInvoicesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WarehouseInvoicesCountOutputType without action
   */
  export type WarehouseInvoicesCountOutputTypeCountWarehouseTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseTransactionsWhereInput
  }



  /**
   * Count Type CounterReceiptsCountOutputType
   */

  export type CounterReceiptsCountOutputType = {
    CustomerInvoices: number
  }

  export type CounterReceiptsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerInvoices?: boolean | CounterReceiptsCountOutputTypeCountCustomerInvoicesArgs
  }

  // Custom InputTypes

  /**
   * CounterReceiptsCountOutputType without action
   */
  export type CounterReceiptsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceiptsCountOutputType
     */
    select?: CounterReceiptsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CounterReceiptsCountOutputType without action
   */
  export type CounterReceiptsCountOutputTypeCountCustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoicesWhereInput
  }



  /**
   * Count Type CheckVouchersCountOutputType
   */

  export type CheckVouchersCountOutputType = {
    SupplierInvoices: number
  }

  export type CheckVouchersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SupplierInvoices?: boolean | CheckVouchersCountOutputTypeCountSupplierInvoicesArgs
  }

  // Custom InputTypes

  /**
   * CheckVouchersCountOutputType without action
   */
  export type CheckVouchersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchersCountOutputType
     */
    select?: CheckVouchersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CheckVouchersCountOutputType without action
   */
  export type CheckVouchersCountOutputTypeCountSupplierInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoicesWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    hashedPassword: string | null
    image: string | null
    role: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    hashedPassword: string | null
    image: string | null
    role: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    hashedPassword: number
    image: number
    role: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    image?: true
    role?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    image?: true
    role?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    hashedPassword?: true
    image?: true
    role?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    hashedPassword: string | null
    image: string | null
    role: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    hashedPassword?: boolean
    image?: boolean
    role?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    hashedPassword?: boolean
    image?: boolean
    role?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      hashedPassword: string | null
      image: string | null
      role: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly hashedPassword: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data?: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }


  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }



  /**
   * Model Items
   */

  export type AggregateItems = {
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  export type ItemsAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    brandId: number | null
    unitId: number | null
    discount1: number | null
    discount2: number | null
    discount3: number | null
    discount4: number | null
    store: number | null
    cal1: number | null
    cal2: number | null
    cal3: number | null
    ws1: number | null
    ws2: number | null
    ws3: number | null
  }

  export type ItemsSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    brandId: number | null
    unitId: number | null
    discount1: number | null
    discount2: number | null
    discount3: number | null
    discount4: number | null
    store: number | null
    cal1: number | null
    cal2: number | null
    cal3: number | null
    ws1: number | null
    ws2: number | null
    ws3: number | null
  }

  export type ItemsMinAggregateOutputType = {
    id: number | null
    supplierId: number | null
    brandId: number | null
    unitId: number | null
    desc1: string | null
    desc2: string | null
    desc3: string | null
    discount1: number | null
    discount2: number | null
    discount3: number | null
    discount4: number | null
    store: number | null
    cal1: number | null
    cal2: number | null
    cal3: number | null
    ws1: number | null
    ws2: number | null
    ws3: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemsMaxAggregateOutputType = {
    id: number | null
    supplierId: number | null
    brandId: number | null
    unitId: number | null
    desc1: string | null
    desc2: string | null
    desc3: string | null
    discount1: number | null
    discount2: number | null
    discount3: number | null
    discount4: number | null
    store: number | null
    cal1: number | null
    cal2: number | null
    cal3: number | null
    ws1: number | null
    ws2: number | null
    ws3: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemsCountAggregateOutputType = {
    id: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: number
    desc2: number
    desc3: number
    discount1: number
    discount2: number
    discount3: number
    discount4: number
    store: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemsAvgAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    unitId?: true
    discount1?: true
    discount2?: true
    discount3?: true
    discount4?: true
    store?: true
    cal1?: true
    cal2?: true
    cal3?: true
    ws1?: true
    ws2?: true
    ws3?: true
  }

  export type ItemsSumAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    unitId?: true
    discount1?: true
    discount2?: true
    discount3?: true
    discount4?: true
    store?: true
    cal1?: true
    cal2?: true
    cal3?: true
    ws1?: true
    ws2?: true
    ws3?: true
  }

  export type ItemsMinAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    unitId?: true
    desc1?: true
    desc2?: true
    desc3?: true
    discount1?: true
    discount2?: true
    discount3?: true
    discount4?: true
    store?: true
    cal1?: true
    cal2?: true
    cal3?: true
    ws1?: true
    ws2?: true
    ws3?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemsMaxAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    unitId?: true
    desc1?: true
    desc2?: true
    desc3?: true
    discount1?: true
    discount2?: true
    discount3?: true
    discount4?: true
    store?: true
    cal1?: true
    cal2?: true
    cal3?: true
    ws1?: true
    ws2?: true
    ws3?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemsCountAggregateInputType = {
    id?: true
    supplierId?: true
    brandId?: true
    unitId?: true
    desc1?: true
    desc2?: true
    desc3?: true
    discount1?: true
    discount2?: true
    discount3?: true
    discount4?: true
    store?: true
    cal1?: true
    cal2?: true
    cal3?: true
    ws1?: true
    ws2?: true
    ws3?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to aggregate.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemsMaxAggregateInputType
  }

  export type GetItemsAggregateType<T extends ItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItems[P]>
      : GetScalarType<T[P], AggregateItems[P]>
  }




  export type ItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithAggregationInput | ItemsOrderByWithAggregationInput[]
    by: ItemsScalarFieldEnum[] | ItemsScalarFieldEnum
    having?: ItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemsCountAggregateInputType | true
    _avg?: ItemsAvgAggregateInputType
    _sum?: ItemsSumAggregateInputType
    _min?: ItemsMinAggregateInputType
    _max?: ItemsMaxAggregateInputType
  }

  export type ItemsGroupByOutputType = {
    id: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1: number
    discount2: number
    discount3: number
    discount4: number
    store: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt: Date
    updatedAt: Date
    _count: ItemsCountAggregateOutputType | null
    _avg: ItemsAvgAggregateOutputType | null
    _sum: ItemsSumAggregateOutputType | null
    _min: ItemsMinAggregateOutputType | null
    _max: ItemsMaxAggregateOutputType | null
  }

  type GetItemsGroupByPayload<T extends ItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemsGroupByOutputType[P]>
            : GetScalarType<T[P], ItemsGroupByOutputType[P]>
        }
      >
    >


  export type ItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    unitId?: boolean
    desc1?: boolean
    desc2?: boolean
    desc3?: boolean
    discount1?: boolean
    discount2?: boolean
    discount3?: boolean
    discount4?: boolean
    store?: boolean
    cal1?: boolean
    cal2?: boolean
    cal3?: boolean
    ws1?: boolean
    ws2?: boolean
    ws3?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    brand?: boolean | BrandsDefaultArgs<ExtArgs>
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    inventories?: boolean | Items$inventoriesArgs<ExtArgs>
    supplierTransactions?: boolean | Items$supplierTransactionsArgs<ExtArgs>
    CustmerTransactions?: boolean | Items$CustmerTransactionsArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["items"]>

  export type ItemsSelectScalar = {
    id?: boolean
    supplierId?: boolean
    brandId?: boolean
    unitId?: boolean
    desc1?: boolean
    desc2?: boolean
    desc3?: boolean
    discount1?: boolean
    discount2?: boolean
    discount3?: boolean
    discount4?: boolean
    store?: boolean
    cal1?: boolean
    cal2?: boolean
    cal3?: boolean
    ws1?: boolean
    ws2?: boolean
    ws3?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    brand?: boolean | BrandsDefaultArgs<ExtArgs>
    unit?: boolean | UnitsDefaultArgs<ExtArgs>
    inventories?: boolean | Items$inventoriesArgs<ExtArgs>
    supplierTransactions?: boolean | Items$supplierTransactionsArgs<ExtArgs>
    CustmerTransactions?: boolean | Items$CustmerTransactionsArgs<ExtArgs>
    _count?: boolean | ItemsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Items"
    objects: {
      supplier: Prisma.$SuppliersPayload<ExtArgs>
      brand: Prisma.$BrandsPayload<ExtArgs>
      unit: Prisma.$UnitsPayload<ExtArgs>
      inventories: Prisma.$InventoryPayload<ExtArgs>[]
      supplierTransactions: Prisma.$SupplierTransactionsPayload<ExtArgs>[]
      CustmerTransactions: Prisma.$CustomerTransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierId: number
      brandId: number
      unitId: number
      desc1: string
      desc2: string
      desc3: string
      discount1: number
      discount2: number
      discount3: number
      discount4: number
      store: number
      cal1: number
      cal2: number
      cal3: number
      ws1: number
      ws2: number
      ws3: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["items"]>
    composites: {}
  }


  type ItemsGetPayload<S extends boolean | null | undefined | ItemsDefaultArgs> = $Result.GetResult<Prisma.$ItemsPayload, S>

  type ItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemsCountAggregateInputType | true
    }

  export interface ItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Items'], meta: { name: 'Items' } }
    /**
     * Find zero or one Items that matches the filter.
     * @param {ItemsFindUniqueArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ItemsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsFindUniqueArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Items that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ItemsFindUniqueOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ItemsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindFirstArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ItemsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsFindFirstArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Items that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindFirstOrThrowArgs} args - Arguments to find a Items
     * @example
     * // Get one Items
     * const items = await prisma.items.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ItemsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.items.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.items.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemsWithIdOnly = await prisma.items.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ItemsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Items.
     * @param {ItemsCreateArgs} args - Arguments to create a Items.
     * @example
     * // Create one Items
     * const Items = await prisma.items.create({
     *   data: {
     *     // ... data to create a Items
     *   }
     * })
     * 
    **/
    create<T extends ItemsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsCreateArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Items.
     *     @param {ItemsCreateManyArgs} args - Arguments to create many Items.
     *     @example
     *     // Create many Items
     *     const items = await prisma.items.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ItemsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Items.
     * @param {ItemsDeleteArgs} args - Arguments to delete one Items.
     * @example
     * // Delete one Items
     * const Items = await prisma.items.delete({
     *   where: {
     *     // ... filter to delete one Items
     *   }
     * })
     * 
    **/
    delete<T extends ItemsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsDeleteArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Items.
     * @param {ItemsUpdateArgs} args - Arguments to update one Items.
     * @example
     * // Update one Items
     * const items = await prisma.items.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ItemsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsUpdateArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemsDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.items.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ItemsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ItemsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const items = await prisma.items.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ItemsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Items.
     * @param {ItemsUpsertArgs} args - Arguments to update or create a Items.
     * @example
     * // Update or create a Items
     * const items = await prisma.items.upsert({
     *   create: {
     *     // ... data to create a Items
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Items we want to update
     *   }
     * })
    **/
    upsert<T extends ItemsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ItemsUpsertArgs<ExtArgs>>
    ): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.items.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemsCountArgs>(
      args?: Subset<T, ItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemsAggregateArgs>(args: Subset<T, ItemsAggregateArgs>): Prisma.PrismaPromise<GetItemsAggregateType<T>>

    /**
     * Group by Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemsGroupByArgs['orderBy'] }
        : { orderBy?: ItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Items model
   */
  readonly fields: ItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Items.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends SuppliersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuppliersDefaultArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    brand<T extends BrandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandsDefaultArgs<ExtArgs>>): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    unit<T extends UnitsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UnitsDefaultArgs<ExtArgs>>): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inventories<T extends Items$inventoriesArgs<ExtArgs> = {}>(args?: Subset<T, Items$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    supplierTransactions<T extends Items$supplierTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Items$supplierTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    CustmerTransactions<T extends Items$CustmerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Items$CustmerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Items model
   */ 
  interface ItemsFieldRefs {
    readonly id: FieldRef<"Items", 'Int'>
    readonly supplierId: FieldRef<"Items", 'Int'>
    readonly brandId: FieldRef<"Items", 'Int'>
    readonly unitId: FieldRef<"Items", 'Int'>
    readonly desc1: FieldRef<"Items", 'String'>
    readonly desc2: FieldRef<"Items", 'String'>
    readonly desc3: FieldRef<"Items", 'String'>
    readonly discount1: FieldRef<"Items", 'Float'>
    readonly discount2: FieldRef<"Items", 'Float'>
    readonly discount3: FieldRef<"Items", 'Float'>
    readonly discount4: FieldRef<"Items", 'Float'>
    readonly store: FieldRef<"Items", 'Float'>
    readonly cal1: FieldRef<"Items", 'Float'>
    readonly cal2: FieldRef<"Items", 'Float'>
    readonly cal3: FieldRef<"Items", 'Float'>
    readonly ws1: FieldRef<"Items", 'Float'>
    readonly ws2: FieldRef<"Items", 'Float'>
    readonly ws3: FieldRef<"Items", 'Float'>
    readonly createdAt: FieldRef<"Items", 'DateTime'>
    readonly updatedAt: FieldRef<"Items", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Items findUnique
   */
  export type ItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where: ItemsWhereUniqueInput
  }


  /**
   * Items findUniqueOrThrow
   */
  export type ItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where: ItemsWhereUniqueInput
  }


  /**
   * Items findFirst
   */
  export type ItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Items findFirstOrThrow
   */
  export type ItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Items findMany
   */
  export type ItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Items create
   */
  export type ItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a Items.
     */
    data: XOR<ItemsCreateInput, ItemsUncheckedCreateInput>
  }


  /**
   * Items createMany
   */
  export type ItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemsCreateManyInput | ItemsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Items update
   */
  export type ItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a Items.
     */
    data: XOR<ItemsUpdateInput, ItemsUncheckedUpdateInput>
    /**
     * Choose, which Items to update.
     */
    where: ItemsWhereUniqueInput
  }


  /**
   * Items updateMany
   */
  export type ItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemsWhereInput
  }


  /**
   * Items upsert
   */
  export type ItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the Items to update in case it exists.
     */
    where: ItemsWhereUniqueInput
    /**
     * In case the Items found by the `where` argument doesn't exist, create a new Items with this data.
     */
    create: XOR<ItemsCreateInput, ItemsUncheckedCreateInput>
    /**
     * In case the Items was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemsUpdateInput, ItemsUncheckedUpdateInput>
  }


  /**
   * Items delete
   */
  export type ItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    /**
     * Filter which Items to delete.
     */
    where: ItemsWhereUniqueInput
  }


  /**
   * Items deleteMany
   */
  export type ItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemsWhereInput
  }


  /**
   * Items.inventories
   */
  export type Items$inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Items.supplierTransactions
   */
  export type Items$supplierTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    where?: SupplierTransactionsWhereInput
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    cursor?: SupplierTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * Items.CustmerTransactions
   */
  export type Items$CustmerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    where?: CustomerTransactionsWhereInput
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    cursor?: CustomerTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerTransactionsScalarFieldEnum | CustomerTransactionsScalarFieldEnum[]
  }


  /**
   * Items without action
   */
  export type ItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
  }



  /**
   * Model Suppliers
   */

  export type AggregateSuppliers = {
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  export type SuppliersAvgAggregateOutputType = {
    id: number | null
    termId: number | null
  }

  export type SuppliersSumAggregateOutputType = {
    id: number | null
    termId: number | null
  }

  export type SuppliersMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    termId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuppliersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    termId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuppliersCountAggregateOutputType = {
    id: number
    name: number
    address: number
    termId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuppliersAvgAggregateInputType = {
    id?: true
    termId?: true
  }

  export type SuppliersSumAggregateInputType = {
    id?: true
    termId?: true
  }

  export type SuppliersMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuppliersMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuppliersCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuppliersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to aggregate.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SuppliersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SuppliersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SuppliersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuppliersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuppliersMaxAggregateInputType
  }

  export type GetSuppliersAggregateType<T extends SuppliersAggregateArgs> = {
        [P in keyof T & keyof AggregateSuppliers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuppliers[P]>
      : GetScalarType<T[P], AggregateSuppliers[P]>
  }




  export type SuppliersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuppliersWhereInput
    orderBy?: SuppliersOrderByWithAggregationInput | SuppliersOrderByWithAggregationInput[]
    by: SuppliersScalarFieldEnum[] | SuppliersScalarFieldEnum
    having?: SuppliersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuppliersCountAggregateInputType | true
    _avg?: SuppliersAvgAggregateInputType
    _sum?: SuppliersSumAggregateInputType
    _min?: SuppliersMinAggregateInputType
    _max?: SuppliersMaxAggregateInputType
  }

  export type SuppliersGroupByOutputType = {
    id: number
    name: string
    address: string
    termId: number
    createdAt: Date
    updatedAt: Date
    _count: SuppliersCountAggregateOutputType | null
    _avg: SuppliersAvgAggregateOutputType | null
    _sum: SuppliersSumAggregateOutputType | null
    _min: SuppliersMinAggregateOutputType | null
    _max: SuppliersMaxAggregateOutputType | null
  }

  type GetSuppliersGroupByPayload<T extends SuppliersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuppliersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuppliersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
            : GetScalarType<T[P], SuppliersGroupByOutputType[P]>
        }
      >
    >


  export type SuppliersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    termId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Suppliers$itemsArgs<ExtArgs>
    Invoices?: boolean | Suppliers$InvoicesArgs<ExtArgs>
    CheckVouchers?: boolean | Suppliers$CheckVouchersArgs<ExtArgs>
    Terms?: boolean | Suppliers$TermsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["suppliers"]>

  export type SuppliersSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    termId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuppliersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Suppliers$itemsArgs<ExtArgs>
    Invoices?: boolean | Suppliers$InvoicesArgs<ExtArgs>
    CheckVouchers?: boolean | Suppliers$CheckVouchersArgs<ExtArgs>
    Terms?: boolean | Suppliers$TermsArgs<ExtArgs>
    _count?: boolean | SuppliersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SuppliersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Suppliers"
    objects: {
      items: Prisma.$ItemsPayload<ExtArgs>[]
      Invoices: Prisma.$SupplierInvoicesPayload<ExtArgs>[]
      CheckVouchers: Prisma.$CheckVouchersPayload<ExtArgs>[]
      Terms: Prisma.$TermsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      termId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["suppliers"]>
    composites: {}
  }


  type SuppliersGetPayload<S extends boolean | null | undefined | SuppliersDefaultArgs> = $Result.GetResult<Prisma.$SuppliersPayload, S>

  type SuppliersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SuppliersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SuppliersCountAggregateInputType | true
    }

  export interface SuppliersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Suppliers'], meta: { name: 'Suppliers' } }
    /**
     * Find zero or one Suppliers that matches the filter.
     * @param {SuppliersFindUniqueArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SuppliersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersFindUniqueArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Suppliers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SuppliersFindUniqueOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SuppliersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SuppliersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersFindFirstArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Suppliers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindFirstOrThrowArgs} args - Arguments to find a Suppliers
     * @example
     * // Get one Suppliers
     * const suppliers = await prisma.suppliers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SuppliersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.suppliers.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.suppliers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const suppliersWithIdOnly = await prisma.suppliers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SuppliersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Suppliers.
     * @param {SuppliersCreateArgs} args - Arguments to create a Suppliers.
     * @example
     * // Create one Suppliers
     * const Suppliers = await prisma.suppliers.create({
     *   data: {
     *     // ... data to create a Suppliers
     *   }
     * })
     * 
    **/
    create<T extends SuppliersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersCreateArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SuppliersCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const suppliers = await prisma.suppliers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SuppliersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Suppliers.
     * @param {SuppliersDeleteArgs} args - Arguments to delete one Suppliers.
     * @example
     * // Delete one Suppliers
     * const Suppliers = await prisma.suppliers.delete({
     *   where: {
     *     // ... filter to delete one Suppliers
     *   }
     * })
     * 
    **/
    delete<T extends SuppliersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersDeleteArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Suppliers.
     * @param {SuppliersUpdateArgs} args - Arguments to update one Suppliers.
     * @example
     * // Update one Suppliers
     * const suppliers = await prisma.suppliers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SuppliersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersUpdateArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SuppliersDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.suppliers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SuppliersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SuppliersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const suppliers = await prisma.suppliers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SuppliersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Suppliers.
     * @param {SuppliersUpsertArgs} args - Arguments to update or create a Suppliers.
     * @example
     * // Update or create a Suppliers
     * const suppliers = await prisma.suppliers.upsert({
     *   create: {
     *     // ... data to create a Suppliers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Suppliers we want to update
     *   }
     * })
    **/
    upsert<T extends SuppliersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SuppliersUpsertArgs<ExtArgs>>
    ): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.suppliers.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SuppliersCountArgs>(
      args?: Subset<T, SuppliersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuppliersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuppliersAggregateArgs>(args: Subset<T, SuppliersAggregateArgs>): Prisma.PrismaPromise<GetSuppliersAggregateType<T>>

    /**
     * Group by Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuppliersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuppliersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuppliersGroupByArgs['orderBy'] }
        : { orderBy?: SuppliersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuppliersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuppliersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Suppliers model
   */
  readonly fields: SuppliersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Suppliers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuppliersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends Suppliers$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    Invoices<T extends Suppliers$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$InvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    CheckVouchers<T extends Suppliers$CheckVouchersArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$CheckVouchersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findMany'> | Null>;

    Terms<T extends Suppliers$TermsArgs<ExtArgs> = {}>(args?: Subset<T, Suppliers$TermsArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Suppliers model
   */ 
  interface SuppliersFieldRefs {
    readonly id: FieldRef<"Suppliers", 'Int'>
    readonly name: FieldRef<"Suppliers", 'String'>
    readonly address: FieldRef<"Suppliers", 'String'>
    readonly termId: FieldRef<"Suppliers", 'Int'>
    readonly createdAt: FieldRef<"Suppliers", 'DateTime'>
    readonly updatedAt: FieldRef<"Suppliers", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Suppliers findUnique
   */
  export type SuppliersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }


  /**
   * Suppliers findUniqueOrThrow
   */
  export type SuppliersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where: SuppliersWhereUniqueInput
  }


  /**
   * Suppliers findFirst
   */
  export type SuppliersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }


  /**
   * Suppliers findFirstOrThrow
   */
  export type SuppliersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }


  /**
   * Suppliers findMany
   */
  export type SuppliersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SuppliersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SuppliersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }


  /**
   * Suppliers create
   */
  export type SuppliersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to create a Suppliers.
     */
    data: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
  }


  /**
   * Suppliers createMany
   */
  export type SuppliersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SuppliersCreateManyInput | SuppliersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Suppliers update
   */
  export type SuppliersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The data needed to update a Suppliers.
     */
    data: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
    /**
     * Choose, which Suppliers to update.
     */
    where: SuppliersWhereUniqueInput
  }


  /**
   * Suppliers updateMany
   */
  export type SuppliersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SuppliersUpdateManyMutationInput, SuppliersUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SuppliersWhereInput
  }


  /**
   * Suppliers upsert
   */
  export type SuppliersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * The filter to search for the Suppliers to update in case it exists.
     */
    where: SuppliersWhereUniqueInput
    /**
     * In case the Suppliers found by the `where` argument doesn't exist, create a new Suppliers with this data.
     */
    create: XOR<SuppliersCreateInput, SuppliersUncheckedCreateInput>
    /**
     * In case the Suppliers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuppliersUpdateInput, SuppliersUncheckedUpdateInput>
  }


  /**
   * Suppliers delete
   */
  export type SuppliersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    /**
     * Filter which Suppliers to delete.
     */
    where: SuppliersWhereUniqueInput
  }


  /**
   * Suppliers deleteMany
   */
  export type SuppliersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SuppliersWhereInput
  }


  /**
   * Suppliers.items
   */
  export type Suppliers$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Suppliers.Invoices
   */
  export type Suppliers$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    where?: SupplierInvoicesWhereInput
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    cursor?: SupplierInvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierInvoicesScalarFieldEnum | SupplierInvoicesScalarFieldEnum[]
  }


  /**
   * Suppliers.CheckVouchers
   */
  export type Suppliers$CheckVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    where?: CheckVouchersWhereInput
    orderBy?: CheckVouchersOrderByWithRelationInput | CheckVouchersOrderByWithRelationInput[]
    cursor?: CheckVouchersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckVouchersScalarFieldEnum | CheckVouchersScalarFieldEnum[]
  }


  /**
   * Suppliers.Terms
   */
  export type Suppliers$TermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    where?: TermsWhereInput
  }


  /**
   * Suppliers without action
   */
  export type SuppliersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
  }



  /**
   * Model Brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsAvgAggregateOutputType = {
    id: number | null
  }

  export type BrandsSumAggregateOutputType = {
    id: number | null
  }

  export type BrandsMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandsAvgAggregateInputType = {
    id?: true
  }

  export type BrandsSumAggregateInputType = {
    id?: true
  }

  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to aggregate.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type BrandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandsWhereInput
    orderBy?: BrandsOrderByWithAggregationInput | BrandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: BrandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _avg?: BrandsAvgAggregateInputType
    _sum?: BrandsSumAggregateInputType
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BrandsCountAggregateOutputType | null
    _avg: BrandsAvgAggregateOutputType | null
    _sum: BrandsSumAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends BrandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type BrandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | Brands$itemsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>

  export type BrandsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | Brands$itemsArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $BrandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brands"
    objects: {
      items: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }


  type BrandsGetPayload<S extends boolean | null | undefined | BrandsDefaultArgs> = $Result.GetResult<Prisma.$BrandsPayload, S>

  type BrandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BrandsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface BrandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brands'], meta: { name: 'Brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {BrandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BrandsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsFindUniqueArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Brands that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BrandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BrandsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BrandsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsFindFirstArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BrandsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BrandsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Brands.
     * @param {BrandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
    **/
    create<T extends BrandsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsCreateArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Brands.
     *     @param {BrandsCreateManyArgs} args - Arguments to create many Brands.
     *     @example
     *     // Create many Brands
     *     const brands = await prisma.brands.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BrandsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {BrandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
    **/
    delete<T extends BrandsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsDeleteArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Brands.
     * @param {BrandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BrandsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsUpdateArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Brands.
     * @param {BrandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BrandsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BrandsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BrandsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {BrandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
    **/
    upsert<T extends BrandsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BrandsUpsertArgs<ExtArgs>>
    ): Prisma__BrandsClient<$Result.GetResult<Prisma.$BrandsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandsCountArgs>(
      args?: Subset<T, BrandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandsGroupByArgs['orderBy'] }
        : { orderBy?: BrandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brands model
   */
  readonly fields: BrandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    items<T extends Brands$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Brands$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Brands model
   */ 
  interface BrandsFieldRefs {
    readonly id: FieldRef<"Brands", 'Int'>
    readonly name: FieldRef<"Brands", 'String'>
    readonly createdAt: FieldRef<"Brands", 'DateTime'>
    readonly updatedAt: FieldRef<"Brands", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Brands findUnique
   */
  export type BrandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where: BrandsWhereUniqueInput
  }


  /**
   * Brands findUniqueOrThrow
   */
  export type BrandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where: BrandsWhereUniqueInput
  }


  /**
   * Brands findFirst
   */
  export type BrandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }


  /**
   * Brands findFirstOrThrow
   */
  export type BrandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }


  /**
   * Brands findMany
   */
  export type BrandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandsOrderByWithRelationInput | BrandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }


  /**
   * Brands create
   */
  export type BrandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The data needed to create a Brands.
     */
    data: XOR<BrandsCreateInput, BrandsUncheckedCreateInput>
  }


  /**
   * Brands createMany
   */
  export type BrandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandsCreateManyInput | BrandsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Brands update
   */
  export type BrandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The data needed to update a Brands.
     */
    data: XOR<BrandsUpdateInput, BrandsUncheckedUpdateInput>
    /**
     * Choose, which Brands to update.
     */
    where: BrandsWhereUniqueInput
  }


  /**
   * Brands updateMany
   */
  export type BrandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandsUpdateManyMutationInput, BrandsUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandsWhereInput
  }


  /**
   * Brands upsert
   */
  export type BrandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * The filter to search for the Brands to update in case it exists.
     */
    where: BrandsWhereUniqueInput
    /**
     * In case the Brands found by the `where` argument doesn't exist, create a new Brands with this data.
     */
    create: XOR<BrandsCreateInput, BrandsUncheckedCreateInput>
    /**
     * In case the Brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandsUpdateInput, BrandsUncheckedUpdateInput>
  }


  /**
   * Brands delete
   */
  export type BrandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
    /**
     * Filter which Brands to delete.
     */
    where: BrandsWhereUniqueInput
  }


  /**
   * Brands deleteMany
   */
  export type BrandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandsWhereInput
  }


  /**
   * Brands.items
   */
  export type Brands$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Brands without action
   */
  export type BrandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brands
     */
    select?: BrandsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: BrandsInclude<ExtArgs> | null
  }



  /**
   * Model Warehouses
   */

  export type AggregateWarehouses = {
    _count: WarehousesCountAggregateOutputType | null
    _avg: WarehousesAvgAggregateOutputType | null
    _sum: WarehousesSumAggregateOutputType | null
    _min: WarehousesMinAggregateOutputType | null
    _max: WarehousesMaxAggregateOutputType | null
  }

  export type WarehousesAvgAggregateOutputType = {
    id: number | null
  }

  export type WarehousesSumAggregateOutputType = {
    id: number | null
  }

  export type WarehousesMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehousesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WarehousesCountAggregateOutputType = {
    id: number
    name: number
    location: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WarehousesAvgAggregateInputType = {
    id?: true
  }

  export type WarehousesSumAggregateInputType = {
    id?: true
  }

  export type WarehousesMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehousesMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WarehousesCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WarehousesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to aggregate.
     */
    where?: WarehousesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehousesOrderByWithRelationInput | WarehousesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehousesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Warehouses
    **/
    _count?: true | WarehousesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehousesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehousesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehousesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehousesMaxAggregateInputType
  }

  export type GetWarehousesAggregateType<T extends WarehousesAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouses[P]>
      : GetScalarType<T[P], AggregateWarehouses[P]>
  }




  export type WarehousesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehousesWhereInput
    orderBy?: WarehousesOrderByWithAggregationInput | WarehousesOrderByWithAggregationInput[]
    by: WarehousesScalarFieldEnum[] | WarehousesScalarFieldEnum
    having?: WarehousesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehousesCountAggregateInputType | true
    _avg?: WarehousesAvgAggregateInputType
    _sum?: WarehousesSumAggregateInputType
    _min?: WarehousesMinAggregateInputType
    _max?: WarehousesMaxAggregateInputType
  }

  export type WarehousesGroupByOutputType = {
    id: number
    name: string
    location: string
    createdAt: Date
    updatedAt: Date
    _count: WarehousesCountAggregateOutputType | null
    _avg: WarehousesAvgAggregateOutputType | null
    _sum: WarehousesSumAggregateOutputType | null
    _min: WarehousesMinAggregateOutputType | null
    _max: WarehousesMaxAggregateOutputType | null
  }

  type GetWarehousesGroupByPayload<T extends WarehousesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehousesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehousesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehousesGroupByOutputType[P]>
            : GetScalarType<T[P], WarehousesGroupByOutputType[P]>
        }
      >
    >


  export type WarehousesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    inventories?: boolean | Warehouses$inventoriesArgs<ExtArgs>
    Invoices?: boolean | Warehouses$InvoicesArgs<ExtArgs>
    _count?: boolean | WarehousesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouses"]>

  export type WarehousesSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WarehousesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventories?: boolean | Warehouses$inventoriesArgs<ExtArgs>
    Invoices?: boolean | Warehouses$InvoicesArgs<ExtArgs>
    _count?: boolean | WarehousesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WarehousesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Warehouses"
    objects: {
      inventories: Prisma.$InventoryPayload<ExtArgs>[]
      Invoices: Prisma.$WarehouseInvoicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["warehouses"]>
    composites: {}
  }


  type WarehousesGetPayload<S extends boolean | null | undefined | WarehousesDefaultArgs> = $Result.GetResult<Prisma.$WarehousesPayload, S>

  type WarehousesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehousesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehousesCountAggregateInputType | true
    }

  export interface WarehousesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Warehouses'], meta: { name: 'Warehouses' } }
    /**
     * Find zero or one Warehouses that matches the filter.
     * @param {WarehousesFindUniqueArgs} args - Arguments to find a Warehouses
     * @example
     * // Get one Warehouses
     * const warehouses = await prisma.warehouses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WarehousesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesFindUniqueArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Warehouses that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WarehousesFindUniqueOrThrowArgs} args - Arguments to find a Warehouses
     * @example
     * // Get one Warehouses
     * const warehouses = await prisma.warehouses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WarehousesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesFindFirstArgs} args - Arguments to find a Warehouses
     * @example
     * // Get one Warehouses
     * const warehouses = await prisma.warehouses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WarehousesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesFindFirstArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Warehouses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesFindFirstOrThrowArgs} args - Arguments to find a Warehouses
     * @example
     * // Get one Warehouses
     * const warehouses = await prisma.warehouses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WarehousesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Warehouses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warehouses
     * const warehouses = await prisma.warehouses.findMany()
     * 
     * // Get first 10 Warehouses
     * const warehouses = await prisma.warehouses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehousesWithIdOnly = await prisma.warehouses.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WarehousesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Warehouses.
     * @param {WarehousesCreateArgs} args - Arguments to create a Warehouses.
     * @example
     * // Create one Warehouses
     * const Warehouses = await prisma.warehouses.create({
     *   data: {
     *     // ... data to create a Warehouses
     *   }
     * })
     * 
    **/
    create<T extends WarehousesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesCreateArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Warehouses.
     *     @param {WarehousesCreateManyArgs} args - Arguments to create many Warehouses.
     *     @example
     *     // Create many Warehouses
     *     const warehouses = await prisma.warehouses.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WarehousesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Warehouses.
     * @param {WarehousesDeleteArgs} args - Arguments to delete one Warehouses.
     * @example
     * // Delete one Warehouses
     * const Warehouses = await prisma.warehouses.delete({
     *   where: {
     *     // ... filter to delete one Warehouses
     *   }
     * })
     * 
    **/
    delete<T extends WarehousesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesDeleteArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Warehouses.
     * @param {WarehousesUpdateArgs} args - Arguments to update one Warehouses.
     * @example
     * // Update one Warehouses
     * const warehouses = await prisma.warehouses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WarehousesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesUpdateArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Warehouses.
     * @param {WarehousesDeleteManyArgs} args - Arguments to filter Warehouses to delete.
     * @example
     * // Delete a few Warehouses
     * const { count } = await prisma.warehouses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WarehousesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehousesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warehouses
     * const warehouses = await prisma.warehouses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WarehousesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Warehouses.
     * @param {WarehousesUpsertArgs} args - Arguments to update or create a Warehouses.
     * @example
     * // Update or create a Warehouses
     * const warehouses = await prisma.warehouses.upsert({
     *   create: {
     *     // ... data to create a Warehouses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warehouses we want to update
     *   }
     * })
    **/
    upsert<T extends WarehousesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WarehousesUpsertArgs<ExtArgs>>
    ): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesCountArgs} args - Arguments to filter Warehouses to count.
     * @example
     * // Count the number of Warehouses
     * const count = await prisma.warehouses.count({
     *   where: {
     *     // ... the filter for the Warehouses we want to count
     *   }
     * })
    **/
    count<T extends WarehousesCountArgs>(
      args?: Subset<T, WarehousesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehousesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehousesAggregateArgs>(args: Subset<T, WarehousesAggregateArgs>): Prisma.PrismaPromise<GetWarehousesAggregateType<T>>

    /**
     * Group by Warehouses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehousesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehousesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehousesGroupByArgs['orderBy'] }
        : { orderBy?: WarehousesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehousesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehousesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Warehouses model
   */
  readonly fields: WarehousesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Warehouses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehousesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inventories<T extends Warehouses$inventoriesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouses$inventoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'> | Null>;

    Invoices<T extends Warehouses$InvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Warehouses$InvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Warehouses model
   */ 
  interface WarehousesFieldRefs {
    readonly id: FieldRef<"Warehouses", 'Int'>
    readonly name: FieldRef<"Warehouses", 'String'>
    readonly location: FieldRef<"Warehouses", 'String'>
    readonly createdAt: FieldRef<"Warehouses", 'DateTime'>
    readonly updatedAt: FieldRef<"Warehouses", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Warehouses findUnique
   */
  export type WarehousesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where: WarehousesWhereUniqueInput
  }


  /**
   * Warehouses findUniqueOrThrow
   */
  export type WarehousesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where: WarehousesWhereUniqueInput
  }


  /**
   * Warehouses findFirst
   */
  export type WarehousesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehousesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehousesOrderByWithRelationInput | WarehousesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehousesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehousesScalarFieldEnum | WarehousesScalarFieldEnum[]
  }


  /**
   * Warehouses findFirstOrThrow
   */
  export type WarehousesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehousesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehousesOrderByWithRelationInput | WarehousesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Warehouses.
     */
    cursor?: WarehousesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Warehouses.
     */
    distinct?: WarehousesScalarFieldEnum | WarehousesScalarFieldEnum[]
  }


  /**
   * Warehouses findMany
   */
  export type WarehousesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter, which Warehouses to fetch.
     */
    where?: WarehousesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Warehouses to fetch.
     */
    orderBy?: WarehousesOrderByWithRelationInput | WarehousesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Warehouses.
     */
    cursor?: WarehousesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Warehouses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Warehouses.
     */
    skip?: number
    distinct?: WarehousesScalarFieldEnum | WarehousesScalarFieldEnum[]
  }


  /**
   * Warehouses create
   */
  export type WarehousesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * The data needed to create a Warehouses.
     */
    data: XOR<WarehousesCreateInput, WarehousesUncheckedCreateInput>
  }


  /**
   * Warehouses createMany
   */
  export type WarehousesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Warehouses.
     */
    data: WarehousesCreateManyInput | WarehousesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Warehouses update
   */
  export type WarehousesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * The data needed to update a Warehouses.
     */
    data: XOR<WarehousesUpdateInput, WarehousesUncheckedUpdateInput>
    /**
     * Choose, which Warehouses to update.
     */
    where: WarehousesWhereUniqueInput
  }


  /**
   * Warehouses updateMany
   */
  export type WarehousesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Warehouses.
     */
    data: XOR<WarehousesUpdateManyMutationInput, WarehousesUncheckedUpdateManyInput>
    /**
     * Filter which Warehouses to update
     */
    where?: WarehousesWhereInput
  }


  /**
   * Warehouses upsert
   */
  export type WarehousesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * The filter to search for the Warehouses to update in case it exists.
     */
    where: WarehousesWhereUniqueInput
    /**
     * In case the Warehouses found by the `where` argument doesn't exist, create a new Warehouses with this data.
     */
    create: XOR<WarehousesCreateInput, WarehousesUncheckedCreateInput>
    /**
     * In case the Warehouses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehousesUpdateInput, WarehousesUncheckedUpdateInput>
  }


  /**
   * Warehouses delete
   */
  export type WarehousesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    /**
     * Filter which Warehouses to delete.
     */
    where: WarehousesWhereUniqueInput
  }


  /**
   * Warehouses deleteMany
   */
  export type WarehousesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Warehouses to delete
     */
    where?: WarehousesWhereInput
  }


  /**
   * Warehouses.inventories
   */
  export type Warehouses$inventoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    cursor?: InventoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Warehouses.Invoices
   */
  export type Warehouses$InvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    where?: WarehouseInvoicesWhereInput
    orderBy?: WarehouseInvoicesOrderByWithRelationInput | WarehouseInvoicesOrderByWithRelationInput[]
    cursor?: WarehouseInvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseInvoicesScalarFieldEnum | WarehouseInvoicesScalarFieldEnum[]
  }


  /**
   * Warehouses without action
   */
  export type WarehousesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
  }



  /**
   * Model Inventory
   */

  export type AggregateInventory = {
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  export type InventoryAvgAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    itemId: number | null
    count: number | null
    price: number | null
  }

  export type InventorySumAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    itemId: number | null
    count: number | null
    price: number | null
  }

  export type InventoryMinAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    itemId: number | null
    count: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryMaxAggregateOutputType = {
    id: number | null
    warehouseId: number | null
    itemId: number | null
    count: number | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryCountAggregateOutputType = {
    id: number
    warehouseId: number
    itemId: number
    count: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryAvgAggregateInputType = {
    id?: true
    warehouseId?: true
    itemId?: true
    count?: true
    price?: true
  }

  export type InventorySumAggregateInputType = {
    id?: true
    warehouseId?: true
    itemId?: true
    count?: true
    price?: true
  }

  export type InventoryMinAggregateInputType = {
    id?: true
    warehouseId?: true
    itemId?: true
    count?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryMaxAggregateInputType = {
    id?: true
    warehouseId?: true
    itemId?: true
    count?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryCountAggregateInputType = {
    id?: true
    warehouseId?: true
    itemId?: true
    count?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventory to aggregate.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inventories
    **/
    _count?: true | InventoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryMaxAggregateInputType
  }

  export type GetInventoryAggregateType<T extends InventoryAggregateArgs> = {
        [P in keyof T & keyof AggregateInventory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventory[P]>
      : GetScalarType<T[P], AggregateInventory[P]>
  }




  export type InventoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryWhereInput
    orderBy?: InventoryOrderByWithAggregationInput | InventoryOrderByWithAggregationInput[]
    by: InventoryScalarFieldEnum[] | InventoryScalarFieldEnum
    having?: InventoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryCountAggregateInputType | true
    _avg?: InventoryAvgAggregateInputType
    _sum?: InventorySumAggregateInputType
    _min?: InventoryMinAggregateInputType
    _max?: InventoryMaxAggregateInputType
  }

  export type InventoryGroupByOutputType = {
    id: number
    warehouseId: number
    itemId: number
    count: number
    price: number
    createdAt: Date
    updatedAt: Date
    _count: InventoryCountAggregateOutputType | null
    _avg: InventoryAvgAggregateOutputType | null
    _sum: InventorySumAggregateOutputType | null
    _min: InventoryMinAggregateOutputType | null
    _max: InventoryMaxAggregateOutputType | null
  }

  type GetInventoryGroupByPayload<T extends InventoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryGroupByOutputType[P]>
        }
      >
    >


  export type InventorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    warehouseId?: boolean
    itemId?: boolean
    count?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    warehouse?: boolean | WarehousesDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
    SupplierTransactions?: boolean | Inventory$SupplierTransactionsArgs<ExtArgs>
    WarehouseTransactions?: boolean | Inventory$WarehouseTransactionsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventory"]>

  export type InventorySelectScalar = {
    id?: boolean
    warehouseId?: boolean
    itemId?: boolean
    count?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    warehouse?: boolean | WarehousesDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
    SupplierTransactions?: boolean | Inventory$SupplierTransactionsArgs<ExtArgs>
    WarehouseTransactions?: boolean | Inventory$WarehouseTransactionsArgs<ExtArgs>
    _count?: boolean | InventoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InventoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inventory"
    objects: {
      warehouse: Prisma.$WarehousesPayload<ExtArgs>
      item: Prisma.$ItemsPayload<ExtArgs>
      SupplierTransactions: Prisma.$SupplierTransactionsPayload<ExtArgs>[]
      WarehouseTransactions: Prisma.$WarehouseTransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      warehouseId: number
      itemId: number
      count: number
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventory"]>
    composites: {}
  }


  type InventoryGetPayload<S extends boolean | null | undefined | InventoryDefaultArgs> = $Result.GetResult<Prisma.$InventoryPayload, S>

  type InventoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryCountAggregateInputType | true
    }

  export interface InventoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inventory'], meta: { name: 'Inventory' } }
    /**
     * Find zero or one Inventory that matches the filter.
     * @param {InventoryFindUniqueArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InventoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryFindUniqueArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inventory that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InventoryFindUniqueOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InventoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inventory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InventoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inventory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindFirstOrThrowArgs} args - Arguments to find a Inventory
     * @example
     * // Get one Inventory
     * const inventory = await prisma.inventory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InventoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inventories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inventories
     * const inventories = await prisma.inventory.findMany()
     * 
     * // Get first 10 Inventories
     * const inventories = await prisma.inventory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryWithIdOnly = await prisma.inventory.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InventoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inventory.
     * @param {InventoryCreateArgs} args - Arguments to create a Inventory.
     * @example
     * // Create one Inventory
     * const Inventory = await prisma.inventory.create({
     *   data: {
     *     // ... data to create a Inventory
     *   }
     * })
     * 
    **/
    create<T extends InventoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryCreateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inventories.
     *     @param {InventoryCreateManyArgs} args - Arguments to create many Inventories.
     *     @example
     *     // Create many Inventories
     *     const inventory = await prisma.inventory.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InventoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inventory.
     * @param {InventoryDeleteArgs} args - Arguments to delete one Inventory.
     * @example
     * // Delete one Inventory
     * const Inventory = await prisma.inventory.delete({
     *   where: {
     *     // ... filter to delete one Inventory
     *   }
     * })
     * 
    **/
    delete<T extends InventoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryDeleteArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inventory.
     * @param {InventoryUpdateArgs} args - Arguments to update one Inventory.
     * @example
     * // Update one Inventory
     * const inventory = await prisma.inventory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InventoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inventories.
     * @param {InventoryDeleteManyArgs} args - Arguments to filter Inventories to delete.
     * @example
     * // Delete a few Inventories
     * const { count } = await prisma.inventory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InventoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InventoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inventories
     * const inventory = await prisma.inventory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InventoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inventory.
     * @param {InventoryUpsertArgs} args - Arguments to update or create a Inventory.
     * @example
     * // Update or create a Inventory
     * const inventory = await prisma.inventory.upsert({
     *   create: {
     *     // ... data to create a Inventory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inventory we want to update
     *   }
     * })
    **/
    upsert<T extends InventoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InventoryUpsertArgs<ExtArgs>>
    ): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inventories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryCountArgs} args - Arguments to filter Inventories to count.
     * @example
     * // Count the number of Inventories
     * const count = await prisma.inventory.count({
     *   where: {
     *     // ... the filter for the Inventories we want to count
     *   }
     * })
    **/
    count<T extends InventoryCountArgs>(
      args?: Subset<T, InventoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryAggregateArgs>(args: Subset<T, InventoryAggregateArgs>): Prisma.PrismaPromise<GetInventoryAggregateType<T>>

    /**
     * Group by Inventory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryGroupByArgs['orderBy'] }
        : { orderBy?: InventoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inventory model
   */
  readonly fields: InventoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inventory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    warehouse<T extends WarehousesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehousesDefaultArgs<ExtArgs>>): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemsDefaultArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    SupplierTransactions<T extends Inventory$SupplierTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$SupplierTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    WarehouseTransactions<T extends Inventory$WarehouseTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Inventory$WarehouseTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inventory model
   */ 
  interface InventoryFieldRefs {
    readonly id: FieldRef<"Inventory", 'Int'>
    readonly warehouseId: FieldRef<"Inventory", 'Int'>
    readonly itemId: FieldRef<"Inventory", 'Int'>
    readonly count: FieldRef<"Inventory", 'Int'>
    readonly price: FieldRef<"Inventory", 'Float'>
    readonly createdAt: FieldRef<"Inventory", 'DateTime'>
    readonly updatedAt: FieldRef<"Inventory", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Inventory findUnique
   */
  export type InventoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findUniqueOrThrow
   */
  export type InventoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory findFirst
   */
  export type InventoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findFirstOrThrow
   */
  export type InventoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventory to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inventories.
     */
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory findMany
   */
  export type InventoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter, which Inventories to fetch.
     */
    where?: InventoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inventories to fetch.
     */
    orderBy?: InventoryOrderByWithRelationInput | InventoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inventories.
     */
    cursor?: InventoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inventories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inventories.
     */
    skip?: number
    distinct?: InventoryScalarFieldEnum | InventoryScalarFieldEnum[]
  }


  /**
   * Inventory create
   */
  export type InventoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inventory.
     */
    data: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
  }


  /**
   * Inventory createMany
   */
  export type InventoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inventories.
     */
    data: InventoryCreateManyInput | InventoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inventory update
   */
  export type InventoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inventory.
     */
    data: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
    /**
     * Choose, which Inventory to update.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory updateMany
   */
  export type InventoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inventories.
     */
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyInput>
    /**
     * Filter which Inventories to update
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory upsert
   */
  export type InventoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inventory to update in case it exists.
     */
    where: InventoryWhereUniqueInput
    /**
     * In case the Inventory found by the `where` argument doesn't exist, create a new Inventory with this data.
     */
    create: XOR<InventoryCreateInput, InventoryUncheckedCreateInput>
    /**
     * In case the Inventory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryUpdateInput, InventoryUncheckedUpdateInput>
  }


  /**
   * Inventory delete
   */
  export type InventoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
    /**
     * Filter which Inventory to delete.
     */
    where: InventoryWhereUniqueInput
  }


  /**
   * Inventory deleteMany
   */
  export type InventoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inventories to delete
     */
    where?: InventoryWhereInput
  }


  /**
   * Inventory.SupplierTransactions
   */
  export type Inventory$SupplierTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    where?: SupplierTransactionsWhereInput
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    cursor?: SupplierTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * Inventory.WarehouseTransactions
   */
  export type Inventory$WarehouseTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    where?: WarehouseTransactionsWhereInput
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    cursor?: WarehouseTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseTransactionsScalarFieldEnum | WarehouseTransactionsScalarFieldEnum[]
  }


  /**
   * Inventory without action
   */
  export type InventoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inventory
     */
    select?: InventorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InventoryInclude<ExtArgs> | null
  }



  /**
   * Model Units
   */

  export type AggregateUnits = {
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  export type UnitsAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitsSumAggregateOutputType = {
    id: number | null
  }

  export type UnitsMinAggregateOutputType = {
    id: number | null
    name: string | null
    plural: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    plural: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UnitsCountAggregateOutputType = {
    id: number
    name: number
    plural: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UnitsAvgAggregateInputType = {
    id?: true
  }

  export type UnitsSumAggregateInputType = {
    id?: true
  }

  export type UnitsMinAggregateInputType = {
    id?: true
    name?: true
    plural?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsMaxAggregateInputType = {
    id?: true
    name?: true
    plural?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UnitsCountAggregateInputType = {
    id?: true
    name?: true
    plural?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UnitsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to aggregate.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitsMaxAggregateInputType
  }

  export type GetUnitsAggregateType<T extends UnitsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnits]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnits[P]>
      : GetScalarType<T[P], AggregateUnits[P]>
  }




  export type UnitsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitsWhereInput
    orderBy?: UnitsOrderByWithAggregationInput | UnitsOrderByWithAggregationInput[]
    by: UnitsScalarFieldEnum[] | UnitsScalarFieldEnum
    having?: UnitsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitsCountAggregateInputType | true
    _avg?: UnitsAvgAggregateInputType
    _sum?: UnitsSumAggregateInputType
    _min?: UnitsMinAggregateInputType
    _max?: UnitsMaxAggregateInputType
  }

  export type UnitsGroupByOutputType = {
    id: number
    name: string
    plural: string
    createdAt: Date
    updatedAt: Date
    _count: UnitsCountAggregateOutputType | null
    _avg: UnitsAvgAggregateOutputType | null
    _sum: UnitsSumAggregateOutputType | null
    _min: UnitsMinAggregateOutputType | null
    _max: UnitsMaxAggregateOutputType | null
  }

  type GetUnitsGroupByPayload<T extends UnitsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitsGroupByOutputType[P]>
            : GetScalarType<T[P], UnitsGroupByOutputType[P]>
        }
      >
    >


  export type UnitsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    plural?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    item?: boolean | Units$itemArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["units"]>

  export type UnitsSelectScalar = {
    id?: boolean
    name?: boolean
    plural?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UnitsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | Units$itemArgs<ExtArgs>
    _count?: boolean | UnitsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UnitsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Units"
    objects: {
      item: Prisma.$ItemsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      plural: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["units"]>
    composites: {}
  }


  type UnitsGetPayload<S extends boolean | null | undefined | UnitsDefaultArgs> = $Result.GetResult<Prisma.$UnitsPayload, S>

  type UnitsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UnitsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UnitsCountAggregateInputType | true
    }

  export interface UnitsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Units'], meta: { name: 'Units' } }
    /**
     * Find zero or one Units that matches the filter.
     * @param {UnitsFindUniqueArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsFindUniqueArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Units that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UnitsFindUniqueOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UnitsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindFirstArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsFindFirstArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Units that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindFirstOrThrowArgs} args - Arguments to find a Units
     * @example
     * // Get one Units
     * const units = await prisma.units.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UnitsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.units.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.units.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitsWithIdOnly = await prisma.units.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Units.
     * @param {UnitsCreateArgs} args - Arguments to create a Units.
     * @example
     * // Create one Units
     * const Units = await prisma.units.create({
     *   data: {
     *     // ... data to create a Units
     *   }
     * })
     * 
    **/
    create<T extends UnitsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsCreateArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Units.
     *     @param {UnitsCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const units = await prisma.units.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Units.
     * @param {UnitsDeleteArgs} args - Arguments to delete one Units.
     * @example
     * // Delete one Units
     * const Units = await prisma.units.delete({
     *   where: {
     *     // ... filter to delete one Units
     *   }
     * })
     * 
    **/
    delete<T extends UnitsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsDeleteArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Units.
     * @param {UnitsUpdateArgs} args - Arguments to update one Units.
     * @example
     * // Update one Units
     * const units = await prisma.units.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsUpdateArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Units.
     * @param {UnitsDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.units.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UnitsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const units = await prisma.units.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Units.
     * @param {UnitsUpsertArgs} args - Arguments to update or create a Units.
     * @example
     * // Update or create a Units
     * const units = await prisma.units.upsert({
     *   create: {
     *     // ... data to create a Units
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Units we want to update
     *   }
     * })
    **/
    upsert<T extends UnitsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UnitsUpsertArgs<ExtArgs>>
    ): Prisma__UnitsClient<$Result.GetResult<Prisma.$UnitsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.units.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitsCountArgs>(
      args?: Subset<T, UnitsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitsAggregateArgs>(args: Subset<T, UnitsAggregateArgs>): Prisma.PrismaPromise<GetUnitsAggregateType<T>>

    /**
     * Group by Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitsGroupByArgs['orderBy'] }
        : { orderBy?: UnitsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Units model
   */
  readonly fields: UnitsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Units.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    item<T extends Units$itemArgs<ExtArgs> = {}>(args?: Subset<T, Units$itemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Units model
   */ 
  interface UnitsFieldRefs {
    readonly id: FieldRef<"Units", 'Int'>
    readonly name: FieldRef<"Units", 'String'>
    readonly plural: FieldRef<"Units", 'String'>
    readonly createdAt: FieldRef<"Units", 'DateTime'>
    readonly updatedAt: FieldRef<"Units", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Units findUnique
   */
  export type UnitsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where: UnitsWhereUniqueInput
  }


  /**
   * Units findUniqueOrThrow
   */
  export type UnitsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where: UnitsWhereUniqueInput
  }


  /**
   * Units findFirst
   */
  export type UnitsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }


  /**
   * Units findFirstOrThrow
   */
  export type UnitsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }


  /**
   * Units findMany
   */
  export type UnitsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitsOrderByWithRelationInput | UnitsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitsScalarFieldEnum | UnitsScalarFieldEnum[]
  }


  /**
   * Units create
   */
  export type UnitsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The data needed to create a Units.
     */
    data: XOR<UnitsCreateInput, UnitsUncheckedCreateInput>
  }


  /**
   * Units createMany
   */
  export type UnitsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitsCreateManyInput | UnitsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Units update
   */
  export type UnitsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The data needed to update a Units.
     */
    data: XOR<UnitsUpdateInput, UnitsUncheckedUpdateInput>
    /**
     * Choose, which Units to update.
     */
    where: UnitsWhereUniqueInput
  }


  /**
   * Units updateMany
   */
  export type UnitsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitsUpdateManyMutationInput, UnitsUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitsWhereInput
  }


  /**
   * Units upsert
   */
  export type UnitsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * The filter to search for the Units to update in case it exists.
     */
    where: UnitsWhereUniqueInput
    /**
     * In case the Units found by the `where` argument doesn't exist, create a new Units with this data.
     */
    create: XOR<UnitsCreateInput, UnitsUncheckedCreateInput>
    /**
     * In case the Units was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitsUpdateInput, UnitsUncheckedUpdateInput>
  }


  /**
   * Units delete
   */
  export type UnitsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
    /**
     * Filter which Units to delete.
     */
    where: UnitsWhereUniqueInput
  }


  /**
   * Units deleteMany
   */
  export type UnitsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitsWhereInput
  }


  /**
   * Units.item
   */
  export type Units$itemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Items
     */
    select?: ItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ItemsInclude<ExtArgs> | null
    where?: ItemsWhereInput
    orderBy?: ItemsOrderByWithRelationInput | ItemsOrderByWithRelationInput[]
    cursor?: ItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemsScalarFieldEnum | ItemsScalarFieldEnum[]
  }


  /**
   * Units without action
   */
  export type UnitsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Units
     */
    select?: UnitsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UnitsInclude<ExtArgs> | null
  }



  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    termId: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    termId: number | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    termId: number | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    termId: number | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    name: number
    address: number
    termId: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    termId?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    termId?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    termId?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    name: string
    address: string
    termId: number
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    termId?: boolean
    term?: boolean | TermsDefaultArgs<ExtArgs>
    CustomerInvoices?: boolean | Customers$CustomerInvoicesArgs<ExtArgs>
    CounterReceits?: boolean | Customers$CounterReceitsArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    termId?: boolean
  }

  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    term?: boolean | TermsDefaultArgs<ExtArgs>
    CustomerInvoices?: boolean | Customers$CustomerInvoicesArgs<ExtArgs>
    CounterReceits?: boolean | Customers$CounterReceitsArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      term: Prisma.$TermsPayload<ExtArgs>
      CustomerInvoices: Prisma.$CustomerInvoicesPayload<ExtArgs>[]
      CounterReceits: Prisma.$CounterReceiptsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      termId: number
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }


  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
    **/
    create<T extends CustomersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customers.
     *     @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customers = await prisma.customers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
    **/
    delete<T extends CustomersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
    **/
    upsert<T extends CustomersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>
    ): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    term<T extends TermsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TermsDefaultArgs<ExtArgs>>): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CustomerInvoices<T extends Customers$CustomerInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, Customers$CustomerInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    CounterReceits<T extends Customers$CounterReceitsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$CounterReceitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Customers model
   */ 
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'Int'>
    readonly name: FieldRef<"Customers", 'String'>
    readonly address: FieldRef<"Customers", 'String'>
    readonly termId: FieldRef<"Customers", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }


  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }


  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }


  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }


  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
  }


  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }


  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }


  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
  }


  /**
   * Customers.CustomerInvoices
   */
  export type Customers$CustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    where?: CustomerInvoicesWhereInput
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    cursor?: CustomerInvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoicesScalarFieldEnum | CustomerInvoicesScalarFieldEnum[]
  }


  /**
   * Customers.CounterReceits
   */
  export type Customers$CounterReceitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    where?: CounterReceiptsWhereInput
    orderBy?: CounterReceiptsOrderByWithRelationInput | CounterReceiptsOrderByWithRelationInput[]
    cursor?: CounterReceiptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CounterReceiptsScalarFieldEnum | CounterReceiptsScalarFieldEnum[]
  }


  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
  }



  /**
   * Model Terms
   */

  export type AggregateTerms = {
    _count: TermsCountAggregateOutputType | null
    _avg: TermsAvgAggregateOutputType | null
    _sum: TermsSumAggregateOutputType | null
    _min: TermsMinAggregateOutputType | null
    _max: TermsMaxAggregateOutputType | null
  }

  export type TermsAvgAggregateOutputType = {
    id: number | null
  }

  export type TermsSumAggregateOutputType = {
    id: number | null
  }

  export type TermsMinAggregateOutputType = {
    id: number | null
    days: string | null
  }

  export type TermsMaxAggregateOutputType = {
    id: number | null
    days: string | null
  }

  export type TermsCountAggregateOutputType = {
    id: number
    days: number
    _all: number
  }


  export type TermsAvgAggregateInputType = {
    id?: true
  }

  export type TermsSumAggregateInputType = {
    id?: true
  }

  export type TermsMinAggregateInputType = {
    id?: true
    days?: true
  }

  export type TermsMaxAggregateInputType = {
    id?: true
    days?: true
  }

  export type TermsCountAggregateInputType = {
    id?: true
    days?: true
    _all?: true
  }

  export type TermsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terms to aggregate.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terms
    **/
    _count?: true | TermsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TermsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TermsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TermsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TermsMaxAggregateInputType
  }

  export type GetTermsAggregateType<T extends TermsAggregateArgs> = {
        [P in keyof T & keyof AggregateTerms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerms[P]>
      : GetScalarType<T[P], AggregateTerms[P]>
  }




  export type TermsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TermsWhereInput
    orderBy?: TermsOrderByWithAggregationInput | TermsOrderByWithAggregationInput[]
    by: TermsScalarFieldEnum[] | TermsScalarFieldEnum
    having?: TermsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TermsCountAggregateInputType | true
    _avg?: TermsAvgAggregateInputType
    _sum?: TermsSumAggregateInputType
    _min?: TermsMinAggregateInputType
    _max?: TermsMaxAggregateInputType
  }

  export type TermsGroupByOutputType = {
    id: number
    days: string
    _count: TermsCountAggregateOutputType | null
    _avg: TermsAvgAggregateOutputType | null
    _sum: TermsSumAggregateOutputType | null
    _min: TermsMinAggregateOutputType | null
    _max: TermsMaxAggregateOutputType | null
  }

  type GetTermsGroupByPayload<T extends TermsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TermsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TermsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TermsGroupByOutputType[P]>
            : GetScalarType<T[P], TermsGroupByOutputType[P]>
        }
      >
    >


  export type TermsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    days?: boolean
    Customers?: boolean | Terms$CustomersArgs<ExtArgs>
    Suppliers?: boolean | Terms$SuppliersArgs<ExtArgs>
    _count?: boolean | TermsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terms"]>

  export type TermsSelectScalar = {
    id?: boolean
    days?: boolean
  }

  export type TermsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Customers?: boolean | Terms$CustomersArgs<ExtArgs>
    Suppliers?: boolean | Terms$SuppliersArgs<ExtArgs>
    _count?: boolean | TermsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TermsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Terms"
    objects: {
      Customers: Prisma.$CustomersPayload<ExtArgs>[]
      Suppliers: Prisma.$SuppliersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      days: string
    }, ExtArgs["result"]["terms"]>
    composites: {}
  }


  type TermsGetPayload<S extends boolean | null | undefined | TermsDefaultArgs> = $Result.GetResult<Prisma.$TermsPayload, S>

  type TermsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TermsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TermsCountAggregateInputType | true
    }

  export interface TermsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Terms'], meta: { name: 'Terms' } }
    /**
     * Find zero or one Terms that matches the filter.
     * @param {TermsFindUniqueArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TermsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TermsFindUniqueArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Terms that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TermsFindUniqueOrThrowArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TermsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindFirstArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TermsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsFindFirstArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindFirstOrThrowArgs} args - Arguments to find a Terms
     * @example
     * // Get one Terms
     * const terms = await prisma.terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TermsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terms
     * const terms = await prisma.terms.findMany()
     * 
     * // Get first 10 Terms
     * const terms = await prisma.terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const termsWithIdOnly = await prisma.terms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TermsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Terms.
     * @param {TermsCreateArgs} args - Arguments to create a Terms.
     * @example
     * // Create one Terms
     * const Terms = await prisma.terms.create({
     *   data: {
     *     // ... data to create a Terms
     *   }
     * })
     * 
    **/
    create<T extends TermsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TermsCreateArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Terms.
     *     @param {TermsCreateManyArgs} args - Arguments to create many Terms.
     *     @example
     *     // Create many Terms
     *     const terms = await prisma.terms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TermsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Terms.
     * @param {TermsDeleteArgs} args - Arguments to delete one Terms.
     * @example
     * // Delete one Terms
     * const Terms = await prisma.terms.delete({
     *   where: {
     *     // ... filter to delete one Terms
     *   }
     * })
     * 
    **/
    delete<T extends TermsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TermsDeleteArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Terms.
     * @param {TermsUpdateArgs} args - Arguments to update one Terms.
     * @example
     * // Update one Terms
     * const terms = await prisma.terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TermsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TermsUpdateArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Terms.
     * @param {TermsDeleteManyArgs} args - Arguments to filter Terms to delete.
     * @example
     * // Delete a few Terms
     * const { count } = await prisma.terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TermsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TermsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terms
     * const terms = await prisma.terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TermsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TermsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terms.
     * @param {TermsUpsertArgs} args - Arguments to update or create a Terms.
     * @example
     * // Update or create a Terms
     * const terms = await prisma.terms.upsert({
     *   create: {
     *     // ... data to create a Terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terms we want to update
     *   }
     * })
    **/
    upsert<T extends TermsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TermsUpsertArgs<ExtArgs>>
    ): Prisma__TermsClient<$Result.GetResult<Prisma.$TermsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsCountArgs} args - Arguments to filter Terms to count.
     * @example
     * // Count the number of Terms
     * const count = await prisma.terms.count({
     *   where: {
     *     // ... the filter for the Terms we want to count
     *   }
     * })
    **/
    count<T extends TermsCountArgs>(
      args?: Subset<T, TermsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TermsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TermsAggregateArgs>(args: Subset<T, TermsAggregateArgs>): Prisma.PrismaPromise<GetTermsAggregateType<T>>

    /**
     * Group by Terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TermsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TermsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TermsGroupByArgs['orderBy'] }
        : { orderBy?: TermsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TermsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTermsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Terms model
   */
  readonly fields: TermsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TermsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Customers<T extends Terms$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, Terms$CustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findMany'> | Null>;

    Suppliers<T extends Terms$SuppliersArgs<ExtArgs> = {}>(args?: Subset<T, Terms$SuppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Terms model
   */ 
  interface TermsFieldRefs {
    readonly id: FieldRef<"Terms", 'Int'>
    readonly days: FieldRef<"Terms", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Terms findUnique
   */
  export type TermsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where: TermsWhereUniqueInput
  }


  /**
   * Terms findUniqueOrThrow
   */
  export type TermsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where: TermsWhereUniqueInput
  }


  /**
   * Terms findFirst
   */
  export type TermsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }


  /**
   * Terms findFirstOrThrow
   */
  export type TermsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terms.
     */
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }


  /**
   * Terms findMany
   */
  export type TermsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter, which Terms to fetch.
     */
    where?: TermsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terms to fetch.
     */
    orderBy?: TermsOrderByWithRelationInput | TermsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terms.
     */
    cursor?: TermsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terms.
     */
    skip?: number
    distinct?: TermsScalarFieldEnum | TermsScalarFieldEnum[]
  }


  /**
   * Terms create
   */
  export type TermsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * The data needed to create a Terms.
     */
    data: XOR<TermsCreateInput, TermsUncheckedCreateInput>
  }


  /**
   * Terms createMany
   */
  export type TermsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terms.
     */
    data: TermsCreateManyInput | TermsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Terms update
   */
  export type TermsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * The data needed to update a Terms.
     */
    data: XOR<TermsUpdateInput, TermsUncheckedUpdateInput>
    /**
     * Choose, which Terms to update.
     */
    where: TermsWhereUniqueInput
  }


  /**
   * Terms updateMany
   */
  export type TermsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terms.
     */
    data: XOR<TermsUpdateManyMutationInput, TermsUncheckedUpdateManyInput>
    /**
     * Filter which Terms to update
     */
    where?: TermsWhereInput
  }


  /**
   * Terms upsert
   */
  export type TermsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * The filter to search for the Terms to update in case it exists.
     */
    where: TermsWhereUniqueInput
    /**
     * In case the Terms found by the `where` argument doesn't exist, create a new Terms with this data.
     */
    create: XOR<TermsCreateInput, TermsUncheckedCreateInput>
    /**
     * In case the Terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TermsUpdateInput, TermsUncheckedUpdateInput>
  }


  /**
   * Terms delete
   */
  export type TermsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
    /**
     * Filter which Terms to delete.
     */
    where: TermsWhereUniqueInput
  }


  /**
   * Terms deleteMany
   */
  export type TermsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terms to delete
     */
    where?: TermsWhereInput
  }


  /**
   * Terms.Customers
   */
  export type Terms$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }


  /**
   * Terms.Suppliers
   */
  export type Terms$SuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    where?: SuppliersWhereInput
    orderBy?: SuppliersOrderByWithRelationInput | SuppliersOrderByWithRelationInput[]
    cursor?: SuppliersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SuppliersScalarFieldEnum | SuppliersScalarFieldEnum[]
  }


  /**
   * Terms without action
   */
  export type TermsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terms
     */
    select?: TermsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TermsInclude<ExtArgs> | null
  }



  /**
   * Model SupplierTransactions
   */

  export type AggregateSupplierTransactions = {
    _count: SupplierTransactionsCountAggregateOutputType | null
    _avg: SupplierTransactionsAvgAggregateOutputType | null
    _sum: SupplierTransactionsSumAggregateOutputType | null
    _min: SupplierTransactionsMinAggregateOutputType | null
    _max: SupplierTransactionsMaxAggregateOutputType | null
  }

  export type SupplierTransactionsAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    inventoryId: number | null
  }

  export type SupplierTransactionsSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    inventoryId: number | null
  }

  export type SupplierTransactionsMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    inventoryId: number | null
  }

  export type SupplierTransactionsMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    quantity: number | null
    inventoryId: number | null
  }

  export type SupplierTransactionsCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemId: number
    quantity: number
    inventoryId: number
    _all: number
  }


  export type SupplierTransactionsAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    inventoryId?: true
  }

  export type SupplierTransactionsSumAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    inventoryId?: true
  }

  export type SupplierTransactionsMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    inventoryId?: true
  }

  export type SupplierTransactionsMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    inventoryId?: true
  }

  export type SupplierTransactionsCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    quantity?: true
    inventoryId?: true
    _all?: true
  }

  export type SupplierTransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierTransactions to aggregate.
     */
    where?: SupplierTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierTransactions to fetch.
     */
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierTransactions
    **/
    _count?: true | SupplierTransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierTransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierTransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierTransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierTransactionsMaxAggregateInputType
  }

  export type GetSupplierTransactionsAggregateType<T extends SupplierTransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierTransactions[P]>
      : GetScalarType<T[P], AggregateSupplierTransactions[P]>
  }




  export type SupplierTransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierTransactionsWhereInput
    orderBy?: SupplierTransactionsOrderByWithAggregationInput | SupplierTransactionsOrderByWithAggregationInput[]
    by: SupplierTransactionsScalarFieldEnum[] | SupplierTransactionsScalarFieldEnum
    having?: SupplierTransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierTransactionsCountAggregateInputType | true
    _avg?: SupplierTransactionsAvgAggregateInputType
    _sum?: SupplierTransactionsSumAggregateInputType
    _min?: SupplierTransactionsMinAggregateInputType
    _max?: SupplierTransactionsMaxAggregateInputType
  }

  export type SupplierTransactionsGroupByOutputType = {
    id: number
    invoiceId: number
    itemId: number
    quantity: number
    inventoryId: number
    _count: SupplierTransactionsCountAggregateOutputType | null
    _avg: SupplierTransactionsAvgAggregateOutputType | null
    _sum: SupplierTransactionsSumAggregateOutputType | null
    _min: SupplierTransactionsMinAggregateOutputType | null
    _max: SupplierTransactionsMaxAggregateOutputType | null
  }

  type GetSupplierTransactionsGroupByPayload<T extends SupplierTransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierTransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierTransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierTransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierTransactionsGroupByOutputType[P]>
        }
      >
    >


  export type SupplierTransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    quantity?: boolean
    inventoryId?: boolean
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
    invoice?: boolean | SupplierInvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierTransactions"]>

  export type SupplierTransactionsSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    quantity?: boolean
    inventoryId?: boolean
  }

  export type SupplierTransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
    invoice?: boolean | SupplierInvoicesDefaultArgs<ExtArgs>
  }


  export type $SupplierTransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierTransactions"
    objects: {
      inventory: Prisma.$InventoryPayload<ExtArgs>
      item: Prisma.$ItemsPayload<ExtArgs>
      invoice: Prisma.$SupplierInvoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      itemId: number
      quantity: number
      inventoryId: number
    }, ExtArgs["result"]["supplierTransactions"]>
    composites: {}
  }


  type SupplierTransactionsGetPayload<S extends boolean | null | undefined | SupplierTransactionsDefaultArgs> = $Result.GetResult<Prisma.$SupplierTransactionsPayload, S>

  type SupplierTransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierTransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierTransactionsCountAggregateInputType | true
    }

  export interface SupplierTransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierTransactions'], meta: { name: 'SupplierTransactions' } }
    /**
     * Find zero or one SupplierTransactions that matches the filter.
     * @param {SupplierTransactionsFindUniqueArgs} args - Arguments to find a SupplierTransactions
     * @example
     * // Get one SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierTransactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SupplierTransactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierTransactionsFindUniqueOrThrowArgs} args - Arguments to find a SupplierTransactions
     * @example
     * // Get one SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierTransactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SupplierTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsFindFirstArgs} args - Arguments to find a SupplierTransactions
     * @example
     * // Get one SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierTransactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SupplierTransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsFindFirstOrThrowArgs} args - Arguments to find a SupplierTransactions
     * @example
     * // Get one SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierTransactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SupplierTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findMany()
     * 
     * // Get first 10 SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierTransactionsWithIdOnly = await prisma.supplierTransactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierTransactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SupplierTransactions.
     * @param {SupplierTransactionsCreateArgs} args - Arguments to create a SupplierTransactions.
     * @example
     * // Create one SupplierTransactions
     * const SupplierTransactions = await prisma.supplierTransactions.create({
     *   data: {
     *     // ... data to create a SupplierTransactions
     *   }
     * })
     * 
    **/
    create<T extends SupplierTransactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsCreateArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SupplierTransactions.
     *     @param {SupplierTransactionsCreateManyArgs} args - Arguments to create many SupplierTransactions.
     *     @example
     *     // Create many SupplierTransactions
     *     const supplierTransactions = await prisma.supplierTransactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierTransactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupplierTransactions.
     * @param {SupplierTransactionsDeleteArgs} args - Arguments to delete one SupplierTransactions.
     * @example
     * // Delete one SupplierTransactions
     * const SupplierTransactions = await prisma.supplierTransactions.delete({
     *   where: {
     *     // ... filter to delete one SupplierTransactions
     *   }
     * })
     * 
    **/
    delete<T extends SupplierTransactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsDeleteArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SupplierTransactions.
     * @param {SupplierTransactionsUpdateArgs} args - Arguments to update one SupplierTransactions.
     * @example
     * // Update one SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierTransactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsUpdateArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SupplierTransactions.
     * @param {SupplierTransactionsDeleteManyArgs} args - Arguments to filter SupplierTransactions to delete.
     * @example
     * // Delete a few SupplierTransactions
     * const { count } = await prisma.supplierTransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierTransactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierTransactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierTransactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplierTransactions.
     * @param {SupplierTransactionsUpsertArgs} args - Arguments to update or create a SupplierTransactions.
     * @example
     * // Update or create a SupplierTransactions
     * const supplierTransactions = await prisma.supplierTransactions.upsert({
     *   create: {
     *     // ... data to create a SupplierTransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierTransactions we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierTransactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierTransactionsUpsertArgs<ExtArgs>>
    ): Prisma__SupplierTransactionsClient<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SupplierTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsCountArgs} args - Arguments to filter SupplierTransactions to count.
     * @example
     * // Count the number of SupplierTransactions
     * const count = await prisma.supplierTransactions.count({
     *   where: {
     *     // ... the filter for the SupplierTransactions we want to count
     *   }
     * })
    **/
    count<T extends SupplierTransactionsCountArgs>(
      args?: Subset<T, SupplierTransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierTransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierTransactionsAggregateArgs>(args: Subset<T, SupplierTransactionsAggregateArgs>): Prisma.PrismaPromise<GetSupplierTransactionsAggregateType<T>>

    /**
     * Group by SupplierTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierTransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierTransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierTransactionsGroupByArgs['orderBy'] }
        : { orderBy?: SupplierTransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierTransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierTransactions model
   */
  readonly fields: SupplierTransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierTransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierTransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemsDefaultArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    invoice<T extends SupplierInvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierInvoicesDefaultArgs<ExtArgs>>): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SupplierTransactions model
   */ 
  interface SupplierTransactionsFieldRefs {
    readonly id: FieldRef<"SupplierTransactions", 'Int'>
    readonly invoiceId: FieldRef<"SupplierTransactions", 'Int'>
    readonly itemId: FieldRef<"SupplierTransactions", 'Int'>
    readonly quantity: FieldRef<"SupplierTransactions", 'Int'>
    readonly inventoryId: FieldRef<"SupplierTransactions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SupplierTransactions findUnique
   */
  export type SupplierTransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which SupplierTransactions to fetch.
     */
    where: SupplierTransactionsWhereUniqueInput
  }


  /**
   * SupplierTransactions findUniqueOrThrow
   */
  export type SupplierTransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which SupplierTransactions to fetch.
     */
    where: SupplierTransactionsWhereUniqueInput
  }


  /**
   * SupplierTransactions findFirst
   */
  export type SupplierTransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which SupplierTransactions to fetch.
     */
    where?: SupplierTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierTransactions to fetch.
     */
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierTransactions.
     */
    cursor?: SupplierTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierTransactions.
     */
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * SupplierTransactions findFirstOrThrow
   */
  export type SupplierTransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which SupplierTransactions to fetch.
     */
    where?: SupplierTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierTransactions to fetch.
     */
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierTransactions.
     */
    cursor?: SupplierTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierTransactions.
     */
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * SupplierTransactions findMany
   */
  export type SupplierTransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which SupplierTransactions to fetch.
     */
    where?: SupplierTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierTransactions to fetch.
     */
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierTransactions.
     */
    cursor?: SupplierTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierTransactions.
     */
    skip?: number
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * SupplierTransactions create
   */
  export type SupplierTransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierTransactions.
     */
    data: XOR<SupplierTransactionsCreateInput, SupplierTransactionsUncheckedCreateInput>
  }


  /**
   * SupplierTransactions createMany
   */
  export type SupplierTransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierTransactions.
     */
    data: SupplierTransactionsCreateManyInput | SupplierTransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SupplierTransactions update
   */
  export type SupplierTransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierTransactions.
     */
    data: XOR<SupplierTransactionsUpdateInput, SupplierTransactionsUncheckedUpdateInput>
    /**
     * Choose, which SupplierTransactions to update.
     */
    where: SupplierTransactionsWhereUniqueInput
  }


  /**
   * SupplierTransactions updateMany
   */
  export type SupplierTransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierTransactions.
     */
    data: XOR<SupplierTransactionsUpdateManyMutationInput, SupplierTransactionsUncheckedUpdateManyInput>
    /**
     * Filter which SupplierTransactions to update
     */
    where?: SupplierTransactionsWhereInput
  }


  /**
   * SupplierTransactions upsert
   */
  export type SupplierTransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierTransactions to update in case it exists.
     */
    where: SupplierTransactionsWhereUniqueInput
    /**
     * In case the SupplierTransactions found by the `where` argument doesn't exist, create a new SupplierTransactions with this data.
     */
    create: XOR<SupplierTransactionsCreateInput, SupplierTransactionsUncheckedCreateInput>
    /**
     * In case the SupplierTransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierTransactionsUpdateInput, SupplierTransactionsUncheckedUpdateInput>
  }


  /**
   * SupplierTransactions delete
   */
  export type SupplierTransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    /**
     * Filter which SupplierTransactions to delete.
     */
    where: SupplierTransactionsWhereUniqueInput
  }


  /**
   * SupplierTransactions deleteMany
   */
  export type SupplierTransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierTransactions to delete
     */
    where?: SupplierTransactionsWhereInput
  }


  /**
   * SupplierTransactions without action
   */
  export type SupplierTransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
  }



  /**
   * Model SupplierInvoices
   */

  export type AggregateSupplierInvoices = {
    _count: SupplierInvoicesCountAggregateOutputType | null
    _avg: SupplierInvoicesAvgAggregateOutputType | null
    _sum: SupplierInvoicesSumAggregateOutputType | null
    _min: SupplierInvoicesMinAggregateOutputType | null
    _max: SupplierInvoicesMaxAggregateOutputType | null
  }

  export type SupplierInvoicesAvgAggregateOutputType = {
    id: number | null
    supplierId: number | null
    totalAmount: number | null
    checkVouchersId: number | null
  }

  export type SupplierInvoicesSumAggregateOutputType = {
    id: number | null
    supplierId: number | null
    totalAmount: number | null
    checkVouchersId: number | null
  }

  export type SupplierInvoicesMinAggregateOutputType = {
    id: number | null
    supplierId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    isfulfilled: boolean | null
    totalAmount: number | null
    dateCreated: Date | null
    dateUpdated: Date | null
    checkVouchersId: number | null
  }

  export type SupplierInvoicesMaxAggregateOutputType = {
    id: number | null
    supplierId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    isfulfilled: boolean | null
    totalAmount: number | null
    dateCreated: Date | null
    dateUpdated: Date | null
    checkVouchersId: number | null
  }

  export type SupplierInvoicesCountAggregateOutputType = {
    id: number
    supplierId: number
    invoiceNumber: number
    invoiceDate: number
    isfulfilled: number
    totalAmount: number
    dateCreated: number
    dateUpdated: number
    checkVouchersId: number
    _all: number
  }


  export type SupplierInvoicesAvgAggregateInputType = {
    id?: true
    supplierId?: true
    totalAmount?: true
    checkVouchersId?: true
  }

  export type SupplierInvoicesSumAggregateInputType = {
    id?: true
    supplierId?: true
    totalAmount?: true
    checkVouchersId?: true
  }

  export type SupplierInvoicesMinAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    checkVouchersId?: true
  }

  export type SupplierInvoicesMaxAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    checkVouchersId?: true
  }

  export type SupplierInvoicesCountAggregateInputType = {
    id?: true
    supplierId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    checkVouchersId?: true
    _all?: true
  }

  export type SupplierInvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoices to aggregate.
     */
    where?: SupplierInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierInvoices
    **/
    _count?: true | SupplierInvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierInvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierInvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierInvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierInvoicesMaxAggregateInputType
  }

  export type GetSupplierInvoicesAggregateType<T extends SupplierInvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierInvoices[P]>
      : GetScalarType<T[P], AggregateSupplierInvoices[P]>
  }




  export type SupplierInvoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierInvoicesWhereInput
    orderBy?: SupplierInvoicesOrderByWithAggregationInput | SupplierInvoicesOrderByWithAggregationInput[]
    by: SupplierInvoicesScalarFieldEnum[] | SupplierInvoicesScalarFieldEnum
    having?: SupplierInvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierInvoicesCountAggregateInputType | true
    _avg?: SupplierInvoicesAvgAggregateInputType
    _sum?: SupplierInvoicesSumAggregateInputType
    _min?: SupplierInvoicesMinAggregateInputType
    _max?: SupplierInvoicesMaxAggregateInputType
  }

  export type SupplierInvoicesGroupByOutputType = {
    id: number
    supplierId: number
    invoiceNumber: string
    invoiceDate: Date
    isfulfilled: boolean
    totalAmount: number
    dateCreated: Date
    dateUpdated: Date
    checkVouchersId: number | null
    _count: SupplierInvoicesCountAggregateOutputType | null
    _avg: SupplierInvoicesAvgAggregateOutputType | null
    _sum: SupplierInvoicesSumAggregateOutputType | null
    _min: SupplierInvoicesMinAggregateOutputType | null
    _max: SupplierInvoicesMaxAggregateOutputType | null
  }

  type GetSupplierInvoicesGroupByPayload<T extends SupplierInvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierInvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierInvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierInvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierInvoicesGroupByOutputType[P]>
        }
      >
    >


  export type SupplierInvoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    isfulfilled?: boolean
    totalAmount?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
    checkVouchersId?: boolean
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    Transactions?: boolean | SupplierInvoices$TransactionsArgs<ExtArgs>
    CheckVouchers?: boolean | SupplierInvoices$CheckVouchersArgs<ExtArgs>
    _count?: boolean | SupplierInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierInvoices"]>

  export type SupplierInvoicesSelectScalar = {
    id?: boolean
    supplierId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    isfulfilled?: boolean
    totalAmount?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
    checkVouchersId?: boolean
  }

  export type SupplierInvoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | SuppliersDefaultArgs<ExtArgs>
    Transactions?: boolean | SupplierInvoices$TransactionsArgs<ExtArgs>
    CheckVouchers?: boolean | SupplierInvoices$CheckVouchersArgs<ExtArgs>
    _count?: boolean | SupplierInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SupplierInvoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierInvoices"
    objects: {
      supplier: Prisma.$SuppliersPayload<ExtArgs>
      Transactions: Prisma.$SupplierTransactionsPayload<ExtArgs>[]
      CheckVouchers: Prisma.$CheckVouchersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierId: number
      invoiceNumber: string
      invoiceDate: Date
      isfulfilled: boolean
      totalAmount: number
      dateCreated: Date
      dateUpdated: Date
      checkVouchersId: number | null
    }, ExtArgs["result"]["supplierInvoices"]>
    composites: {}
  }


  type SupplierInvoicesGetPayload<S extends boolean | null | undefined | SupplierInvoicesDefaultArgs> = $Result.GetResult<Prisma.$SupplierInvoicesPayload, S>

  type SupplierInvoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierInvoicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierInvoicesCountAggregateInputType | true
    }

  export interface SupplierInvoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierInvoices'], meta: { name: 'SupplierInvoices' } }
    /**
     * Find zero or one SupplierInvoices that matches the filter.
     * @param {SupplierInvoicesFindUniqueArgs} args - Arguments to find a SupplierInvoices
     * @example
     * // Get one SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierInvoicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SupplierInvoices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierInvoicesFindUniqueOrThrowArgs} args - Arguments to find a SupplierInvoices
     * @example
     * // Get one SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierInvoicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SupplierInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesFindFirstArgs} args - Arguments to find a SupplierInvoices
     * @example
     * // Get one SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierInvoicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SupplierInvoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesFindFirstOrThrowArgs} args - Arguments to find a SupplierInvoices
     * @example
     * // Get one SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierInvoicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SupplierInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findMany()
     * 
     * // Get first 10 SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierInvoicesWithIdOnly = await prisma.supplierInvoices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierInvoicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SupplierInvoices.
     * @param {SupplierInvoicesCreateArgs} args - Arguments to create a SupplierInvoices.
     * @example
     * // Create one SupplierInvoices
     * const SupplierInvoices = await prisma.supplierInvoices.create({
     *   data: {
     *     // ... data to create a SupplierInvoices
     *   }
     * })
     * 
    **/
    create<T extends SupplierInvoicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesCreateArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SupplierInvoices.
     *     @param {SupplierInvoicesCreateManyArgs} args - Arguments to create many SupplierInvoices.
     *     @example
     *     // Create many SupplierInvoices
     *     const supplierInvoices = await prisma.supplierInvoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierInvoicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SupplierInvoices.
     * @param {SupplierInvoicesDeleteArgs} args - Arguments to delete one SupplierInvoices.
     * @example
     * // Delete one SupplierInvoices
     * const SupplierInvoices = await prisma.supplierInvoices.delete({
     *   where: {
     *     // ... filter to delete one SupplierInvoices
     *   }
     * })
     * 
    **/
    delete<T extends SupplierInvoicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesDeleteArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SupplierInvoices.
     * @param {SupplierInvoicesUpdateArgs} args - Arguments to update one SupplierInvoices.
     * @example
     * // Update one SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierInvoicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesUpdateArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SupplierInvoices.
     * @param {SupplierInvoicesDeleteManyArgs} args - Arguments to filter SupplierInvoices to delete.
     * @example
     * // Delete a few SupplierInvoices
     * const { count } = await prisma.supplierInvoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierInvoicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierInvoicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierInvoicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SupplierInvoices.
     * @param {SupplierInvoicesUpsertArgs} args - Arguments to update or create a SupplierInvoices.
     * @example
     * // Update or create a SupplierInvoices
     * const supplierInvoices = await prisma.supplierInvoices.upsert({
     *   create: {
     *     // ... data to create a SupplierInvoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierInvoices we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierInvoicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierInvoicesUpsertArgs<ExtArgs>>
    ): Prisma__SupplierInvoicesClient<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesCountArgs} args - Arguments to filter SupplierInvoices to count.
     * @example
     * // Count the number of SupplierInvoices
     * const count = await prisma.supplierInvoices.count({
     *   where: {
     *     // ... the filter for the SupplierInvoices we want to count
     *   }
     * })
    **/
    count<T extends SupplierInvoicesCountArgs>(
      args?: Subset<T, SupplierInvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierInvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierInvoicesAggregateArgs>(args: Subset<T, SupplierInvoicesAggregateArgs>): Prisma.PrismaPromise<GetSupplierInvoicesAggregateType<T>>

    /**
     * Group by SupplierInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierInvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierInvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierInvoicesGroupByArgs['orderBy'] }
        : { orderBy?: SupplierInvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierInvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierInvoices model
   */
  readonly fields: SupplierInvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierInvoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierInvoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    supplier<T extends SuppliersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SuppliersDefaultArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Transactions<T extends SupplierInvoices$TransactionsArgs<ExtArgs> = {}>(args?: Subset<T, SupplierInvoices$TransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    CheckVouchers<T extends SupplierInvoices$CheckVouchersArgs<ExtArgs> = {}>(args?: Subset<T, SupplierInvoices$CheckVouchersArgs<ExtArgs>>): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SupplierInvoices model
   */ 
  interface SupplierInvoicesFieldRefs {
    readonly id: FieldRef<"SupplierInvoices", 'Int'>
    readonly supplierId: FieldRef<"SupplierInvoices", 'Int'>
    readonly invoiceNumber: FieldRef<"SupplierInvoices", 'String'>
    readonly invoiceDate: FieldRef<"SupplierInvoices", 'DateTime'>
    readonly isfulfilled: FieldRef<"SupplierInvoices", 'Boolean'>
    readonly totalAmount: FieldRef<"SupplierInvoices", 'Float'>
    readonly dateCreated: FieldRef<"SupplierInvoices", 'DateTime'>
    readonly dateUpdated: FieldRef<"SupplierInvoices", 'DateTime'>
    readonly checkVouchersId: FieldRef<"SupplierInvoices", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * SupplierInvoices findUnique
   */
  export type SupplierInvoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where: SupplierInvoicesWhereUniqueInput
  }


  /**
   * SupplierInvoices findUniqueOrThrow
   */
  export type SupplierInvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where: SupplierInvoicesWhereUniqueInput
  }


  /**
   * SupplierInvoices findFirst
   */
  export type SupplierInvoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where?: SupplierInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoicesScalarFieldEnum | SupplierInvoicesScalarFieldEnum[]
  }


  /**
   * SupplierInvoices findFirstOrThrow
   */
  export type SupplierInvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where?: SupplierInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierInvoices.
     */
    cursor?: SupplierInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierInvoices.
     */
    distinct?: SupplierInvoicesScalarFieldEnum | SupplierInvoicesScalarFieldEnum[]
  }


  /**
   * SupplierInvoices findMany
   */
  export type SupplierInvoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which SupplierInvoices to fetch.
     */
    where?: SupplierInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierInvoices to fetch.
     */
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierInvoices.
     */
    cursor?: SupplierInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierInvoices.
     */
    skip?: number
    distinct?: SupplierInvoicesScalarFieldEnum | SupplierInvoicesScalarFieldEnum[]
  }


  /**
   * SupplierInvoices create
   */
  export type SupplierInvoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierInvoices.
     */
    data: XOR<SupplierInvoicesCreateInput, SupplierInvoicesUncheckedCreateInput>
  }


  /**
   * SupplierInvoices createMany
   */
  export type SupplierInvoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierInvoices.
     */
    data: SupplierInvoicesCreateManyInput | SupplierInvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * SupplierInvoices update
   */
  export type SupplierInvoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierInvoices.
     */
    data: XOR<SupplierInvoicesUpdateInput, SupplierInvoicesUncheckedUpdateInput>
    /**
     * Choose, which SupplierInvoices to update.
     */
    where: SupplierInvoicesWhereUniqueInput
  }


  /**
   * SupplierInvoices updateMany
   */
  export type SupplierInvoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierInvoices.
     */
    data: XOR<SupplierInvoicesUpdateManyMutationInput, SupplierInvoicesUncheckedUpdateManyInput>
    /**
     * Filter which SupplierInvoices to update
     */
    where?: SupplierInvoicesWhereInput
  }


  /**
   * SupplierInvoices upsert
   */
  export type SupplierInvoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierInvoices to update in case it exists.
     */
    where: SupplierInvoicesWhereUniqueInput
    /**
     * In case the SupplierInvoices found by the `where` argument doesn't exist, create a new SupplierInvoices with this data.
     */
    create: XOR<SupplierInvoicesCreateInput, SupplierInvoicesUncheckedCreateInput>
    /**
     * In case the SupplierInvoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierInvoicesUpdateInput, SupplierInvoicesUncheckedUpdateInput>
  }


  /**
   * SupplierInvoices delete
   */
  export type SupplierInvoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    /**
     * Filter which SupplierInvoices to delete.
     */
    where: SupplierInvoicesWhereUniqueInput
  }


  /**
   * SupplierInvoices deleteMany
   */
  export type SupplierInvoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierInvoices to delete
     */
    where?: SupplierInvoicesWhereInput
  }


  /**
   * SupplierInvoices.Transactions
   */
  export type SupplierInvoices$TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierTransactions
     */
    select?: SupplierTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierTransactionsInclude<ExtArgs> | null
    where?: SupplierTransactionsWhereInput
    orderBy?: SupplierTransactionsOrderByWithRelationInput | SupplierTransactionsOrderByWithRelationInput[]
    cursor?: SupplierTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierTransactionsScalarFieldEnum | SupplierTransactionsScalarFieldEnum[]
  }


  /**
   * SupplierInvoices.CheckVouchers
   */
  export type SupplierInvoices$CheckVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    where?: CheckVouchersWhereInput
  }


  /**
   * SupplierInvoices without action
   */
  export type SupplierInvoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
  }



  /**
   * Model CustomerTransactions
   */

  export type AggregateCustomerTransactions = {
    _count: CustomerTransactionsCountAggregateOutputType | null
    _avg: CustomerTransactionsAvgAggregateOutputType | null
    _sum: CustomerTransactionsSumAggregateOutputType | null
    _min: CustomerTransactionsMinAggregateOutputType | null
    _max: CustomerTransactionsMaxAggregateOutputType | null
  }

  export type CustomerTransactionsAvgAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    customerPrice: number | null
    storePrice: number | null
    quantity: number | null
    supplied: number | null
  }

  export type CustomerTransactionsSumAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    customerPrice: number | null
    storePrice: number | null
    quantity: number | null
    supplied: number | null
  }

  export type CustomerTransactionsMinAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    customerPrice: number | null
    storePrice: number | null
    quantity: number | null
    supplied: number | null
    isDiscounted: boolean | null
  }

  export type CustomerTransactionsMaxAggregateOutputType = {
    id: number | null
    invoiceId: number | null
    itemId: number | null
    customerPrice: number | null
    storePrice: number | null
    quantity: number | null
    supplied: number | null
    isDiscounted: boolean | null
  }

  export type CustomerTransactionsCountAggregateOutputType = {
    id: number
    invoiceId: number
    itemId: number
    customerPrice: number
    storePrice: number
    quantity: number
    supplied: number
    isDiscounted: number
    _all: number
  }


  export type CustomerTransactionsAvgAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    customerPrice?: true
    storePrice?: true
    quantity?: true
    supplied?: true
  }

  export type CustomerTransactionsSumAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    customerPrice?: true
    storePrice?: true
    quantity?: true
    supplied?: true
  }

  export type CustomerTransactionsMinAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    customerPrice?: true
    storePrice?: true
    quantity?: true
    supplied?: true
    isDiscounted?: true
  }

  export type CustomerTransactionsMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    customerPrice?: true
    storePrice?: true
    quantity?: true
    supplied?: true
    isDiscounted?: true
  }

  export type CustomerTransactionsCountAggregateInputType = {
    id?: true
    invoiceId?: true
    itemId?: true
    customerPrice?: true
    storePrice?: true
    quantity?: true
    supplied?: true
    isDiscounted?: true
    _all?: true
  }

  export type CustomerTransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTransactions to aggregate.
     */
    where?: CustomerTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerTransactions
    **/
    _count?: true | CustomerTransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerTransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerTransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerTransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerTransactionsMaxAggregateInputType
  }

  export type GetCustomerTransactionsAggregateType<T extends CustomerTransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerTransactions[P]>
      : GetScalarType<T[P], AggregateCustomerTransactions[P]>
  }




  export type CustomerTransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerTransactionsWhereInput
    orderBy?: CustomerTransactionsOrderByWithAggregationInput | CustomerTransactionsOrderByWithAggregationInput[]
    by: CustomerTransactionsScalarFieldEnum[] | CustomerTransactionsScalarFieldEnum
    having?: CustomerTransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerTransactionsCountAggregateInputType | true
    _avg?: CustomerTransactionsAvgAggregateInputType
    _sum?: CustomerTransactionsSumAggregateInputType
    _min?: CustomerTransactionsMinAggregateInputType
    _max?: CustomerTransactionsMaxAggregateInputType
  }

  export type CustomerTransactionsGroupByOutputType = {
    id: number
    invoiceId: number
    itemId: number
    customerPrice: number
    storePrice: number
    quantity: number
    supplied: number
    isDiscounted: boolean
    _count: CustomerTransactionsCountAggregateOutputType | null
    _avg: CustomerTransactionsAvgAggregateOutputType | null
    _sum: CustomerTransactionsSumAggregateOutputType | null
    _min: CustomerTransactionsMinAggregateOutputType | null
    _max: CustomerTransactionsMaxAggregateOutputType | null
  }

  type GetCustomerTransactionsGroupByPayload<T extends CustomerTransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerTransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerTransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerTransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerTransactionsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerTransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    customerPrice?: boolean
    storePrice?: boolean
    quantity?: boolean
    supplied?: boolean
    isDiscounted?: boolean
    invoice?: boolean | CustomerInvoicesDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerTransactions"]>

  export type CustomerTransactionsSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    itemId?: boolean
    customerPrice?: boolean
    storePrice?: boolean
    quantity?: boolean
    supplied?: boolean
    isDiscounted?: boolean
  }

  export type CustomerTransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | CustomerInvoicesDefaultArgs<ExtArgs>
    item?: boolean | ItemsDefaultArgs<ExtArgs>
  }


  export type $CustomerTransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerTransactions"
    objects: {
      invoice: Prisma.$CustomerInvoicesPayload<ExtArgs>
      item: Prisma.$ItemsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoiceId: number
      itemId: number
      customerPrice: number
      storePrice: number
      quantity: number
      supplied: number
      isDiscounted: boolean
    }, ExtArgs["result"]["customerTransactions"]>
    composites: {}
  }


  type CustomerTransactionsGetPayload<S extends boolean | null | undefined | CustomerTransactionsDefaultArgs> = $Result.GetResult<Prisma.$CustomerTransactionsPayload, S>

  type CustomerTransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerTransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerTransactionsCountAggregateInputType | true
    }

  export interface CustomerTransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerTransactions'], meta: { name: 'CustomerTransactions' } }
    /**
     * Find zero or one CustomerTransactions that matches the filter.
     * @param {CustomerTransactionsFindUniqueArgs} args - Arguments to find a CustomerTransactions
     * @example
     * // Get one CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerTransactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CustomerTransactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerTransactionsFindUniqueOrThrowArgs} args - Arguments to find a CustomerTransactions
     * @example
     * // Get one CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerTransactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CustomerTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsFindFirstArgs} args - Arguments to find a CustomerTransactions
     * @example
     * // Get one CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerTransactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsFindFirstArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CustomerTransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsFindFirstOrThrowArgs} args - Arguments to find a CustomerTransactions
     * @example
     * // Get one CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerTransactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CustomerTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findMany()
     * 
     * // Get first 10 CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerTransactionsWithIdOnly = await prisma.customerTransactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerTransactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CustomerTransactions.
     * @param {CustomerTransactionsCreateArgs} args - Arguments to create a CustomerTransactions.
     * @example
     * // Create one CustomerTransactions
     * const CustomerTransactions = await prisma.customerTransactions.create({
     *   data: {
     *     // ... data to create a CustomerTransactions
     *   }
     * })
     * 
    **/
    create<T extends CustomerTransactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsCreateArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CustomerTransactions.
     *     @param {CustomerTransactionsCreateManyArgs} args - Arguments to create many CustomerTransactions.
     *     @example
     *     // Create many CustomerTransactions
     *     const customerTransactions = await prisma.customerTransactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerTransactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerTransactions.
     * @param {CustomerTransactionsDeleteArgs} args - Arguments to delete one CustomerTransactions.
     * @example
     * // Delete one CustomerTransactions
     * const CustomerTransactions = await prisma.customerTransactions.delete({
     *   where: {
     *     // ... filter to delete one CustomerTransactions
     *   }
     * })
     * 
    **/
    delete<T extends CustomerTransactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsDeleteArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CustomerTransactions.
     * @param {CustomerTransactionsUpdateArgs} args - Arguments to update one CustomerTransactions.
     * @example
     * // Update one CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerTransactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsUpdateArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CustomerTransactions.
     * @param {CustomerTransactionsDeleteManyArgs} args - Arguments to filter CustomerTransactions to delete.
     * @example
     * // Delete a few CustomerTransactions
     * const { count } = await prisma.customerTransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerTransactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerTransactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerTransactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerTransactions.
     * @param {CustomerTransactionsUpsertArgs} args - Arguments to update or create a CustomerTransactions.
     * @example
     * // Update or create a CustomerTransactions
     * const customerTransactions = await prisma.customerTransactions.upsert({
     *   create: {
     *     // ... data to create a CustomerTransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerTransactions we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerTransactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerTransactionsUpsertArgs<ExtArgs>>
    ): Prisma__CustomerTransactionsClient<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsCountArgs} args - Arguments to filter CustomerTransactions to count.
     * @example
     * // Count the number of CustomerTransactions
     * const count = await prisma.customerTransactions.count({
     *   where: {
     *     // ... the filter for the CustomerTransactions we want to count
     *   }
     * })
    **/
    count<T extends CustomerTransactionsCountArgs>(
      args?: Subset<T, CustomerTransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerTransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerTransactionsAggregateArgs>(args: Subset<T, CustomerTransactionsAggregateArgs>): Prisma.PrismaPromise<GetCustomerTransactionsAggregateType<T>>

    /**
     * Group by CustomerTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerTransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerTransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerTransactionsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerTransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerTransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerTransactions model
   */
  readonly fields: CustomerTransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerTransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerTransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    invoice<T extends CustomerInvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoicesDefaultArgs<ExtArgs>>): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    item<T extends ItemsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemsDefaultArgs<ExtArgs>>): Prisma__ItemsClient<$Result.GetResult<Prisma.$ItemsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CustomerTransactions model
   */ 
  interface CustomerTransactionsFieldRefs {
    readonly id: FieldRef<"CustomerTransactions", 'Int'>
    readonly invoiceId: FieldRef<"CustomerTransactions", 'Int'>
    readonly itemId: FieldRef<"CustomerTransactions", 'Int'>
    readonly customerPrice: FieldRef<"CustomerTransactions", 'Float'>
    readonly storePrice: FieldRef<"CustomerTransactions", 'Float'>
    readonly quantity: FieldRef<"CustomerTransactions", 'Int'>
    readonly supplied: FieldRef<"CustomerTransactions", 'Int'>
    readonly isDiscounted: FieldRef<"CustomerTransactions", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * CustomerTransactions findUnique
   */
  export type CustomerTransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where: CustomerTransactionsWhereUniqueInput
  }


  /**
   * CustomerTransactions findUniqueOrThrow
   */
  export type CustomerTransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where: CustomerTransactionsWhereUniqueInput
  }


  /**
   * CustomerTransactions findFirst
   */
  export type CustomerTransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where?: CustomerTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTransactions.
     */
    cursor?: CustomerTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTransactions.
     */
    distinct?: CustomerTransactionsScalarFieldEnum | CustomerTransactionsScalarFieldEnum[]
  }


  /**
   * CustomerTransactions findFirstOrThrow
   */
  export type CustomerTransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where?: CustomerTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerTransactions.
     */
    cursor?: CustomerTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerTransactions.
     */
    distinct?: CustomerTransactionsScalarFieldEnum | CustomerTransactionsScalarFieldEnum[]
  }


  /**
   * CustomerTransactions findMany
   */
  export type CustomerTransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerTransactions to fetch.
     */
    where?: CustomerTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerTransactions to fetch.
     */
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerTransactions.
     */
    cursor?: CustomerTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerTransactions.
     */
    skip?: number
    distinct?: CustomerTransactionsScalarFieldEnum | CustomerTransactionsScalarFieldEnum[]
  }


  /**
   * CustomerTransactions create
   */
  export type CustomerTransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerTransactions.
     */
    data: XOR<CustomerTransactionsCreateInput, CustomerTransactionsUncheckedCreateInput>
  }


  /**
   * CustomerTransactions createMany
   */
  export type CustomerTransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerTransactions.
     */
    data: CustomerTransactionsCreateManyInput | CustomerTransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CustomerTransactions update
   */
  export type CustomerTransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerTransactions.
     */
    data: XOR<CustomerTransactionsUpdateInput, CustomerTransactionsUncheckedUpdateInput>
    /**
     * Choose, which CustomerTransactions to update.
     */
    where: CustomerTransactionsWhereUniqueInput
  }


  /**
   * CustomerTransactions updateMany
   */
  export type CustomerTransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerTransactions.
     */
    data: XOR<CustomerTransactionsUpdateManyMutationInput, CustomerTransactionsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerTransactions to update
     */
    where?: CustomerTransactionsWhereInput
  }


  /**
   * CustomerTransactions upsert
   */
  export type CustomerTransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerTransactions to update in case it exists.
     */
    where: CustomerTransactionsWhereUniqueInput
    /**
     * In case the CustomerTransactions found by the `where` argument doesn't exist, create a new CustomerTransactions with this data.
     */
    create: XOR<CustomerTransactionsCreateInput, CustomerTransactionsUncheckedCreateInput>
    /**
     * In case the CustomerTransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerTransactionsUpdateInput, CustomerTransactionsUncheckedUpdateInput>
  }


  /**
   * CustomerTransactions delete
   */
  export type CustomerTransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    /**
     * Filter which CustomerTransactions to delete.
     */
    where: CustomerTransactionsWhereUniqueInput
  }


  /**
   * CustomerTransactions deleteMany
   */
  export type CustomerTransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerTransactions to delete
     */
    where?: CustomerTransactionsWhereInput
  }


  /**
   * CustomerTransactions without action
   */
  export type CustomerTransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
  }



  /**
   * Model CustomerInvoices
   */

  export type AggregateCustomerInvoices = {
    _count: CustomerInvoicesCountAggregateOutputType | null
    _avg: CustomerInvoicesAvgAggregateOutputType | null
    _sum: CustomerInvoicesSumAggregateOutputType | null
    _min: CustomerInvoicesMinAggregateOutputType | null
    _max: CustomerInvoicesMaxAggregateOutputType | null
  }

  export type CustomerInvoicesAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    totalAmount: number | null
    counterReceiptsId: number | null
  }

  export type CustomerInvoicesSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    totalAmount: number | null
    counterReceiptsId: number | null
  }

  export type CustomerInvoicesMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    isfulfilled: boolean | null
    isCompleted: boolean | null
    totalAmount: number | null
    dateCreated: Date | null
    dateUpdated: Date | null
    counterReceiptsId: number | null
  }

  export type CustomerInvoicesMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    invoiceNumber: string | null
    invoiceDate: Date | null
    isfulfilled: boolean | null
    isCompleted: boolean | null
    totalAmount: number | null
    dateCreated: Date | null
    dateUpdated: Date | null
    counterReceiptsId: number | null
  }

  export type CustomerInvoicesCountAggregateOutputType = {
    id: number
    customerId: number
    invoiceNumber: number
    invoiceDate: number
    isfulfilled: number
    isCompleted: number
    totalAmount: number
    dateCreated: number
    dateUpdated: number
    counterReceiptsId: number
    _all: number
  }


  export type CustomerInvoicesAvgAggregateInputType = {
    id?: true
    customerId?: true
    totalAmount?: true
    counterReceiptsId?: true
  }

  export type CustomerInvoicesSumAggregateInputType = {
    id?: true
    customerId?: true
    totalAmount?: true
    counterReceiptsId?: true
  }

  export type CustomerInvoicesMinAggregateInputType = {
    id?: true
    customerId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    isCompleted?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    counterReceiptsId?: true
  }

  export type CustomerInvoicesMaxAggregateInputType = {
    id?: true
    customerId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    isCompleted?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    counterReceiptsId?: true
  }

  export type CustomerInvoicesCountAggregateInputType = {
    id?: true
    customerId?: true
    invoiceNumber?: true
    invoiceDate?: true
    isfulfilled?: true
    isCompleted?: true
    totalAmount?: true
    dateCreated?: true
    dateUpdated?: true
    counterReceiptsId?: true
    _all?: true
  }

  export type CustomerInvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoices to aggregate.
     */
    where?: CustomerInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerInvoices
    **/
    _count?: true | CustomerInvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerInvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerInvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerInvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerInvoicesMaxAggregateInputType
  }

  export type GetCustomerInvoicesAggregateType<T extends CustomerInvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerInvoices[P]>
      : GetScalarType<T[P], AggregateCustomerInvoices[P]>
  }




  export type CustomerInvoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerInvoicesWhereInput
    orderBy?: CustomerInvoicesOrderByWithAggregationInput | CustomerInvoicesOrderByWithAggregationInput[]
    by: CustomerInvoicesScalarFieldEnum[] | CustomerInvoicesScalarFieldEnum
    having?: CustomerInvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerInvoicesCountAggregateInputType | true
    _avg?: CustomerInvoicesAvgAggregateInputType
    _sum?: CustomerInvoicesSumAggregateInputType
    _min?: CustomerInvoicesMinAggregateInputType
    _max?: CustomerInvoicesMaxAggregateInputType
  }

  export type CustomerInvoicesGroupByOutputType = {
    id: number
    customerId: number
    invoiceNumber: string
    invoiceDate: Date
    isfulfilled: boolean
    isCompleted: boolean
    totalAmount: number
    dateCreated: Date
    dateUpdated: Date
    counterReceiptsId: number | null
    _count: CustomerInvoicesCountAggregateOutputType | null
    _avg: CustomerInvoicesAvgAggregateOutputType | null
    _sum: CustomerInvoicesSumAggregateOutputType | null
    _min: CustomerInvoicesMinAggregateOutputType | null
    _max: CustomerInvoicesMaxAggregateOutputType | null
  }

  type GetCustomerInvoicesGroupByPayload<T extends CustomerInvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerInvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerInvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerInvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerInvoicesGroupByOutputType[P]>
        }
      >
    >


  export type CustomerInvoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
    counterReceiptsId?: boolean
    customer?: boolean | CustomersDefaultArgs<ExtArgs>
    CustmerTransactions?: boolean | CustomerInvoices$CustmerTransactionsArgs<ExtArgs>
    CounterReceipts?: boolean | CustomerInvoices$CounterReceiptsArgs<ExtArgs>
    _count?: boolean | CustomerInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerInvoices"]>

  export type CustomerInvoicesSelectScalar = {
    id?: boolean
    customerId?: boolean
    invoiceNumber?: boolean
    invoiceDate?: boolean
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
    counterReceiptsId?: boolean
  }

  export type CustomerInvoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomersDefaultArgs<ExtArgs>
    CustmerTransactions?: boolean | CustomerInvoices$CustmerTransactionsArgs<ExtArgs>
    CounterReceipts?: boolean | CustomerInvoices$CounterReceiptsArgs<ExtArgs>
    _count?: boolean | CustomerInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CustomerInvoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerInvoices"
    objects: {
      customer: Prisma.$CustomersPayload<ExtArgs>
      CustmerTransactions: Prisma.$CustomerTransactionsPayload<ExtArgs>[]
      CounterReceipts: Prisma.$CounterReceiptsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      invoiceNumber: string
      invoiceDate: Date
      isfulfilled: boolean
      isCompleted: boolean
      totalAmount: number
      dateCreated: Date
      dateUpdated: Date
      counterReceiptsId: number | null
    }, ExtArgs["result"]["customerInvoices"]>
    composites: {}
  }


  type CustomerInvoicesGetPayload<S extends boolean | null | undefined | CustomerInvoicesDefaultArgs> = $Result.GetResult<Prisma.$CustomerInvoicesPayload, S>

  type CustomerInvoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerInvoicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerInvoicesCountAggregateInputType | true
    }

  export interface CustomerInvoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerInvoices'], meta: { name: 'CustomerInvoices' } }
    /**
     * Find zero or one CustomerInvoices that matches the filter.
     * @param {CustomerInvoicesFindUniqueArgs} args - Arguments to find a CustomerInvoices
     * @example
     * // Get one CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerInvoicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CustomerInvoices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerInvoicesFindUniqueOrThrowArgs} args - Arguments to find a CustomerInvoices
     * @example
     * // Get one CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerInvoicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CustomerInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesFindFirstArgs} args - Arguments to find a CustomerInvoices
     * @example
     * // Get one CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerInvoicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesFindFirstArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CustomerInvoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesFindFirstOrThrowArgs} args - Arguments to find a CustomerInvoices
     * @example
     * // Get one CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerInvoicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CustomerInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findMany()
     * 
     * // Get first 10 CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerInvoicesWithIdOnly = await prisma.customerInvoices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerInvoicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CustomerInvoices.
     * @param {CustomerInvoicesCreateArgs} args - Arguments to create a CustomerInvoices.
     * @example
     * // Create one CustomerInvoices
     * const CustomerInvoices = await prisma.customerInvoices.create({
     *   data: {
     *     // ... data to create a CustomerInvoices
     *   }
     * })
     * 
    **/
    create<T extends CustomerInvoicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesCreateArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CustomerInvoices.
     *     @param {CustomerInvoicesCreateManyArgs} args - Arguments to create many CustomerInvoices.
     *     @example
     *     // Create many CustomerInvoices
     *     const customerInvoices = await prisma.customerInvoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerInvoicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomerInvoices.
     * @param {CustomerInvoicesDeleteArgs} args - Arguments to delete one CustomerInvoices.
     * @example
     * // Delete one CustomerInvoices
     * const CustomerInvoices = await prisma.customerInvoices.delete({
     *   where: {
     *     // ... filter to delete one CustomerInvoices
     *   }
     * })
     * 
    **/
    delete<T extends CustomerInvoicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesDeleteArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CustomerInvoices.
     * @param {CustomerInvoicesUpdateArgs} args - Arguments to update one CustomerInvoices.
     * @example
     * // Update one CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerInvoicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesUpdateArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CustomerInvoices.
     * @param {CustomerInvoicesDeleteManyArgs} args - Arguments to filter CustomerInvoices to delete.
     * @example
     * // Delete a few CustomerInvoices
     * const { count } = await prisma.customerInvoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerInvoicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerInvoicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerInvoicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerInvoices.
     * @param {CustomerInvoicesUpsertArgs} args - Arguments to update or create a CustomerInvoices.
     * @example
     * // Update or create a CustomerInvoices
     * const customerInvoices = await prisma.customerInvoices.upsert({
     *   create: {
     *     // ... data to create a CustomerInvoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerInvoices we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerInvoicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerInvoicesUpsertArgs<ExtArgs>>
    ): Prisma__CustomerInvoicesClient<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesCountArgs} args - Arguments to filter CustomerInvoices to count.
     * @example
     * // Count the number of CustomerInvoices
     * const count = await prisma.customerInvoices.count({
     *   where: {
     *     // ... the filter for the CustomerInvoices we want to count
     *   }
     * })
    **/
    count<T extends CustomerInvoicesCountArgs>(
      args?: Subset<T, CustomerInvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerInvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerInvoicesAggregateArgs>(args: Subset<T, CustomerInvoicesAggregateArgs>): Prisma.PrismaPromise<GetCustomerInvoicesAggregateType<T>>

    /**
     * Group by CustomerInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerInvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerInvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerInvoicesGroupByArgs['orderBy'] }
        : { orderBy?: CustomerInvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerInvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerInvoices model
   */
  readonly fields: CustomerInvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerInvoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerInvoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    CustmerTransactions<T extends CustomerInvoices$CustmerTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoices$CustmerTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    CounterReceipts<T extends CustomerInvoices$CounterReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerInvoices$CounterReceiptsArgs<ExtArgs>>): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CustomerInvoices model
   */ 
  interface CustomerInvoicesFieldRefs {
    readonly id: FieldRef<"CustomerInvoices", 'Int'>
    readonly customerId: FieldRef<"CustomerInvoices", 'Int'>
    readonly invoiceNumber: FieldRef<"CustomerInvoices", 'String'>
    readonly invoiceDate: FieldRef<"CustomerInvoices", 'DateTime'>
    readonly isfulfilled: FieldRef<"CustomerInvoices", 'Boolean'>
    readonly isCompleted: FieldRef<"CustomerInvoices", 'Boolean'>
    readonly totalAmount: FieldRef<"CustomerInvoices", 'Float'>
    readonly dateCreated: FieldRef<"CustomerInvoices", 'DateTime'>
    readonly dateUpdated: FieldRef<"CustomerInvoices", 'DateTime'>
    readonly counterReceiptsId: FieldRef<"CustomerInvoices", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CustomerInvoices findUnique
   */
  export type CustomerInvoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where: CustomerInvoicesWhereUniqueInput
  }


  /**
   * CustomerInvoices findUniqueOrThrow
   */
  export type CustomerInvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where: CustomerInvoicesWhereUniqueInput
  }


  /**
   * CustomerInvoices findFirst
   */
  export type CustomerInvoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where?: CustomerInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoicesScalarFieldEnum | CustomerInvoicesScalarFieldEnum[]
  }


  /**
   * CustomerInvoices findFirstOrThrow
   */
  export type CustomerInvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where?: CustomerInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerInvoices.
     */
    cursor?: CustomerInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerInvoices.
     */
    distinct?: CustomerInvoicesScalarFieldEnum | CustomerInvoicesScalarFieldEnum[]
  }


  /**
   * CustomerInvoices findMany
   */
  export type CustomerInvoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which CustomerInvoices to fetch.
     */
    where?: CustomerInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerInvoices to fetch.
     */
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerInvoices.
     */
    cursor?: CustomerInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerInvoices.
     */
    skip?: number
    distinct?: CustomerInvoicesScalarFieldEnum | CustomerInvoicesScalarFieldEnum[]
  }


  /**
   * CustomerInvoices create
   */
  export type CustomerInvoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerInvoices.
     */
    data: XOR<CustomerInvoicesCreateInput, CustomerInvoicesUncheckedCreateInput>
  }


  /**
   * CustomerInvoices createMany
   */
  export type CustomerInvoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerInvoices.
     */
    data: CustomerInvoicesCreateManyInput | CustomerInvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CustomerInvoices update
   */
  export type CustomerInvoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerInvoices.
     */
    data: XOR<CustomerInvoicesUpdateInput, CustomerInvoicesUncheckedUpdateInput>
    /**
     * Choose, which CustomerInvoices to update.
     */
    where: CustomerInvoicesWhereUniqueInput
  }


  /**
   * CustomerInvoices updateMany
   */
  export type CustomerInvoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerInvoices.
     */
    data: XOR<CustomerInvoicesUpdateManyMutationInput, CustomerInvoicesUncheckedUpdateManyInput>
    /**
     * Filter which CustomerInvoices to update
     */
    where?: CustomerInvoicesWhereInput
  }


  /**
   * CustomerInvoices upsert
   */
  export type CustomerInvoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerInvoices to update in case it exists.
     */
    where: CustomerInvoicesWhereUniqueInput
    /**
     * In case the CustomerInvoices found by the `where` argument doesn't exist, create a new CustomerInvoices with this data.
     */
    create: XOR<CustomerInvoicesCreateInput, CustomerInvoicesUncheckedCreateInput>
    /**
     * In case the CustomerInvoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerInvoicesUpdateInput, CustomerInvoicesUncheckedUpdateInput>
  }


  /**
   * CustomerInvoices delete
   */
  export type CustomerInvoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    /**
     * Filter which CustomerInvoices to delete.
     */
    where: CustomerInvoicesWhereUniqueInput
  }


  /**
   * CustomerInvoices deleteMany
   */
  export type CustomerInvoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerInvoices to delete
     */
    where?: CustomerInvoicesWhereInput
  }


  /**
   * CustomerInvoices.CustmerTransactions
   */
  export type CustomerInvoices$CustmerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerTransactions
     */
    select?: CustomerTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerTransactionsInclude<ExtArgs> | null
    where?: CustomerTransactionsWhereInput
    orderBy?: CustomerTransactionsOrderByWithRelationInput | CustomerTransactionsOrderByWithRelationInput[]
    cursor?: CustomerTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerTransactionsScalarFieldEnum | CustomerTransactionsScalarFieldEnum[]
  }


  /**
   * CustomerInvoices.CounterReceipts
   */
  export type CustomerInvoices$CounterReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    where?: CounterReceiptsWhereInput
  }


  /**
   * CustomerInvoices without action
   */
  export type CustomerInvoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
  }



  /**
   * Model WarehouseTransactions
   */

  export type AggregateWarehouseTransactions = {
    _count: WarehouseTransactionsCountAggregateOutputType | null
    _avg: WarehouseTransactionsAvgAggregateOutputType | null
    _sum: WarehouseTransactionsSumAggregateOutputType | null
    _min: WarehouseTransactionsMinAggregateOutputType | null
    _max: WarehouseTransactionsMaxAggregateOutputType | null
  }

  export type WarehouseTransactionsAvgAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    invoiceId: number | null
    count: number | null
  }

  export type WarehouseTransactionsSumAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    invoiceId: number | null
    count: number | null
  }

  export type WarehouseTransactionsMinAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    invoiceId: number | null
    count: number | null
  }

  export type WarehouseTransactionsMaxAggregateOutputType = {
    id: number | null
    inventoryId: number | null
    invoiceId: number | null
    count: number | null
  }

  export type WarehouseTransactionsCountAggregateOutputType = {
    id: number
    inventoryId: number
    invoiceId: number
    count: number
    _all: number
  }


  export type WarehouseTransactionsAvgAggregateInputType = {
    id?: true
    inventoryId?: true
    invoiceId?: true
    count?: true
  }

  export type WarehouseTransactionsSumAggregateInputType = {
    id?: true
    inventoryId?: true
    invoiceId?: true
    count?: true
  }

  export type WarehouseTransactionsMinAggregateInputType = {
    id?: true
    inventoryId?: true
    invoiceId?: true
    count?: true
  }

  export type WarehouseTransactionsMaxAggregateInputType = {
    id?: true
    inventoryId?: true
    invoiceId?: true
    count?: true
  }

  export type WarehouseTransactionsCountAggregateInputType = {
    id?: true
    inventoryId?: true
    invoiceId?: true
    count?: true
    _all?: true
  }

  export type WarehouseTransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseTransactions to aggregate.
     */
    where?: WarehouseTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseTransactions to fetch.
     */
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseTransactions
    **/
    _count?: true | WarehouseTransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseTransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseTransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseTransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseTransactionsMaxAggregateInputType
  }

  export type GetWarehouseTransactionsAggregateType<T extends WarehouseTransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseTransactions[P]>
      : GetScalarType<T[P], AggregateWarehouseTransactions[P]>
  }




  export type WarehouseTransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseTransactionsWhereInput
    orderBy?: WarehouseTransactionsOrderByWithAggregationInput | WarehouseTransactionsOrderByWithAggregationInput[]
    by: WarehouseTransactionsScalarFieldEnum[] | WarehouseTransactionsScalarFieldEnum
    having?: WarehouseTransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseTransactionsCountAggregateInputType | true
    _avg?: WarehouseTransactionsAvgAggregateInputType
    _sum?: WarehouseTransactionsSumAggregateInputType
    _min?: WarehouseTransactionsMinAggregateInputType
    _max?: WarehouseTransactionsMaxAggregateInputType
  }

  export type WarehouseTransactionsGroupByOutputType = {
    id: number
    inventoryId: number
    invoiceId: number
    count: number
    _count: WarehouseTransactionsCountAggregateOutputType | null
    _avg: WarehouseTransactionsAvgAggregateOutputType | null
    _sum: WarehouseTransactionsSumAggregateOutputType | null
    _min: WarehouseTransactionsMinAggregateOutputType | null
    _max: WarehouseTransactionsMaxAggregateOutputType | null
  }

  type GetWarehouseTransactionsGroupByPayload<T extends WarehouseTransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseTransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseTransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseTransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseTransactionsGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseTransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inventoryId?: boolean
    invoiceId?: boolean
    count?: boolean
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Invoice?: boolean | WarehouseInvoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseTransactions"]>

  export type WarehouseTransactionsSelectScalar = {
    id?: boolean
    inventoryId?: boolean
    invoiceId?: boolean
    count?: boolean
  }

  export type WarehouseTransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Inventory?: boolean | InventoryDefaultArgs<ExtArgs>
    Invoice?: boolean | WarehouseInvoicesDefaultArgs<ExtArgs>
  }


  export type $WarehouseTransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseTransactions"
    objects: {
      Inventory: Prisma.$InventoryPayload<ExtArgs>
      Invoice: Prisma.$WarehouseInvoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inventoryId: number
      invoiceId: number
      count: number
    }, ExtArgs["result"]["warehouseTransactions"]>
    composites: {}
  }


  type WarehouseTransactionsGetPayload<S extends boolean | null | undefined | WarehouseTransactionsDefaultArgs> = $Result.GetResult<Prisma.$WarehouseTransactionsPayload, S>

  type WarehouseTransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseTransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseTransactionsCountAggregateInputType | true
    }

  export interface WarehouseTransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseTransactions'], meta: { name: 'WarehouseTransactions' } }
    /**
     * Find zero or one WarehouseTransactions that matches the filter.
     * @param {WarehouseTransactionsFindUniqueArgs} args - Arguments to find a WarehouseTransactions
     * @example
     * // Get one WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WarehouseTransactionsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsFindUniqueArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WarehouseTransactions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WarehouseTransactionsFindUniqueOrThrowArgs} args - Arguments to find a WarehouseTransactions
     * @example
     * // Get one WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WarehouseTransactionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WarehouseTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsFindFirstArgs} args - Arguments to find a WarehouseTransactions
     * @example
     * // Get one WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WarehouseTransactionsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsFindFirstArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WarehouseTransactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsFindFirstOrThrowArgs} args - Arguments to find a WarehouseTransactions
     * @example
     * // Get one WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WarehouseTransactionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WarehouseTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findMany()
     * 
     * // Get first 10 WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseTransactionsWithIdOnly = await prisma.warehouseTransactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WarehouseTransactionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WarehouseTransactions.
     * @param {WarehouseTransactionsCreateArgs} args - Arguments to create a WarehouseTransactions.
     * @example
     * // Create one WarehouseTransactions
     * const WarehouseTransactions = await prisma.warehouseTransactions.create({
     *   data: {
     *     // ... data to create a WarehouseTransactions
     *   }
     * })
     * 
    **/
    create<T extends WarehouseTransactionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsCreateArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WarehouseTransactions.
     *     @param {WarehouseTransactionsCreateManyArgs} args - Arguments to create many WarehouseTransactions.
     *     @example
     *     // Create many WarehouseTransactions
     *     const warehouseTransactions = await prisma.warehouseTransactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WarehouseTransactionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WarehouseTransactions.
     * @param {WarehouseTransactionsDeleteArgs} args - Arguments to delete one WarehouseTransactions.
     * @example
     * // Delete one WarehouseTransactions
     * const WarehouseTransactions = await prisma.warehouseTransactions.delete({
     *   where: {
     *     // ... filter to delete one WarehouseTransactions
     *   }
     * })
     * 
    **/
    delete<T extends WarehouseTransactionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsDeleteArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WarehouseTransactions.
     * @param {WarehouseTransactionsUpdateArgs} args - Arguments to update one WarehouseTransactions.
     * @example
     * // Update one WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WarehouseTransactionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsUpdateArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WarehouseTransactions.
     * @param {WarehouseTransactionsDeleteManyArgs} args - Arguments to filter WarehouseTransactions to delete.
     * @example
     * // Delete a few WarehouseTransactions
     * const { count } = await prisma.warehouseTransactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WarehouseTransactionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseTransactionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WarehouseTransactionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarehouseTransactions.
     * @param {WarehouseTransactionsUpsertArgs} args - Arguments to update or create a WarehouseTransactions.
     * @example
     * // Update or create a WarehouseTransactions
     * const warehouseTransactions = await prisma.warehouseTransactions.upsert({
     *   create: {
     *     // ... data to create a WarehouseTransactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseTransactions we want to update
     *   }
     * })
    **/
    upsert<T extends WarehouseTransactionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseTransactionsUpsertArgs<ExtArgs>>
    ): Prisma__WarehouseTransactionsClient<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WarehouseTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsCountArgs} args - Arguments to filter WarehouseTransactions to count.
     * @example
     * // Count the number of WarehouseTransactions
     * const count = await prisma.warehouseTransactions.count({
     *   where: {
     *     // ... the filter for the WarehouseTransactions we want to count
     *   }
     * })
    **/
    count<T extends WarehouseTransactionsCountArgs>(
      args?: Subset<T, WarehouseTransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseTransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseTransactionsAggregateArgs>(args: Subset<T, WarehouseTransactionsAggregateArgs>): Prisma.PrismaPromise<GetWarehouseTransactionsAggregateType<T>>

    /**
     * Group by WarehouseTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseTransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseTransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseTransactionsGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseTransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseTransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseTransactions model
   */
  readonly fields: WarehouseTransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseTransactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseTransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Inventory<T extends InventoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryDefaultArgs<ExtArgs>>): Prisma__InventoryClient<$Result.GetResult<Prisma.$InventoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Invoice<T extends WarehouseInvoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseInvoicesDefaultArgs<ExtArgs>>): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WarehouseTransactions model
   */ 
  interface WarehouseTransactionsFieldRefs {
    readonly id: FieldRef<"WarehouseTransactions", 'Int'>
    readonly inventoryId: FieldRef<"WarehouseTransactions", 'Int'>
    readonly invoiceId: FieldRef<"WarehouseTransactions", 'Int'>
    readonly count: FieldRef<"WarehouseTransactions", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * WarehouseTransactions findUnique
   */
  export type WarehouseTransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseTransactions to fetch.
     */
    where: WarehouseTransactionsWhereUniqueInput
  }


  /**
   * WarehouseTransactions findUniqueOrThrow
   */
  export type WarehouseTransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseTransactions to fetch.
     */
    where: WarehouseTransactionsWhereUniqueInput
  }


  /**
   * WarehouseTransactions findFirst
   */
  export type WarehouseTransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseTransactions to fetch.
     */
    where?: WarehouseTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseTransactions to fetch.
     */
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseTransactions.
     */
    cursor?: WarehouseTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseTransactions.
     */
    distinct?: WarehouseTransactionsScalarFieldEnum | WarehouseTransactionsScalarFieldEnum[]
  }


  /**
   * WarehouseTransactions findFirstOrThrow
   */
  export type WarehouseTransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseTransactions to fetch.
     */
    where?: WarehouseTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseTransactions to fetch.
     */
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseTransactions.
     */
    cursor?: WarehouseTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseTransactions.
     */
    distinct?: WarehouseTransactionsScalarFieldEnum | WarehouseTransactionsScalarFieldEnum[]
  }


  /**
   * WarehouseTransactions findMany
   */
  export type WarehouseTransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseTransactions to fetch.
     */
    where?: WarehouseTransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseTransactions to fetch.
     */
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseTransactions.
     */
    cursor?: WarehouseTransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseTransactions.
     */
    skip?: number
    distinct?: WarehouseTransactionsScalarFieldEnum | WarehouseTransactionsScalarFieldEnum[]
  }


  /**
   * WarehouseTransactions create
   */
  export type WarehouseTransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseTransactions.
     */
    data: XOR<WarehouseTransactionsCreateInput, WarehouseTransactionsUncheckedCreateInput>
  }


  /**
   * WarehouseTransactions createMany
   */
  export type WarehouseTransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseTransactions.
     */
    data: WarehouseTransactionsCreateManyInput | WarehouseTransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WarehouseTransactions update
   */
  export type WarehouseTransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseTransactions.
     */
    data: XOR<WarehouseTransactionsUpdateInput, WarehouseTransactionsUncheckedUpdateInput>
    /**
     * Choose, which WarehouseTransactions to update.
     */
    where: WarehouseTransactionsWhereUniqueInput
  }


  /**
   * WarehouseTransactions updateMany
   */
  export type WarehouseTransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseTransactions.
     */
    data: XOR<WarehouseTransactionsUpdateManyMutationInput, WarehouseTransactionsUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseTransactions to update
     */
    where?: WarehouseTransactionsWhereInput
  }


  /**
   * WarehouseTransactions upsert
   */
  export type WarehouseTransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseTransactions to update in case it exists.
     */
    where: WarehouseTransactionsWhereUniqueInput
    /**
     * In case the WarehouseTransactions found by the `where` argument doesn't exist, create a new WarehouseTransactions with this data.
     */
    create: XOR<WarehouseTransactionsCreateInput, WarehouseTransactionsUncheckedCreateInput>
    /**
     * In case the WarehouseTransactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseTransactionsUpdateInput, WarehouseTransactionsUncheckedUpdateInput>
  }


  /**
   * WarehouseTransactions delete
   */
  export type WarehouseTransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    /**
     * Filter which WarehouseTransactions to delete.
     */
    where: WarehouseTransactionsWhereUniqueInput
  }


  /**
   * WarehouseTransactions deleteMany
   */
  export type WarehouseTransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseTransactions to delete
     */
    where?: WarehouseTransactionsWhereInput
  }


  /**
   * WarehouseTransactions without action
   */
  export type WarehouseTransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
  }



  /**
   * Model WarehouseInvoices
   */

  export type AggregateWarehouseInvoices = {
    _count: WarehouseInvoicesCountAggregateOutputType | null
    _avg: WarehouseInvoicesAvgAggregateOutputType | null
    _sum: WarehouseInvoicesSumAggregateOutputType | null
    _min: WarehouseInvoicesMinAggregateOutputType | null
    _max: WarehouseInvoicesMaxAggregateOutputType | null
  }

  export type WarehouseInvoicesAvgAggregateOutputType = {
    id: number | null
    targetWarehouseId: number | null
    warehouseId: number | null
  }

  export type WarehouseInvoicesSumAggregateOutputType = {
    id: number | null
    targetWarehouseId: number | null
    warehouseId: number | null
  }

  export type WarehouseInvoicesMinAggregateOutputType = {
    id: number | null
    targetWarehouseId: number | null
    warehouseId: number | null
    isFullfilled: boolean | null
    dateCreated: Date | null
    dateUpdated: Date | null
  }

  export type WarehouseInvoicesMaxAggregateOutputType = {
    id: number | null
    targetWarehouseId: number | null
    warehouseId: number | null
    isFullfilled: boolean | null
    dateCreated: Date | null
    dateUpdated: Date | null
  }

  export type WarehouseInvoicesCountAggregateOutputType = {
    id: number
    targetWarehouseId: number
    warehouseId: number
    isFullfilled: number
    dateCreated: number
    dateUpdated: number
    _all: number
  }


  export type WarehouseInvoicesAvgAggregateInputType = {
    id?: true
    targetWarehouseId?: true
    warehouseId?: true
  }

  export type WarehouseInvoicesSumAggregateInputType = {
    id?: true
    targetWarehouseId?: true
    warehouseId?: true
  }

  export type WarehouseInvoicesMinAggregateInputType = {
    id?: true
    targetWarehouseId?: true
    warehouseId?: true
    isFullfilled?: true
    dateCreated?: true
    dateUpdated?: true
  }

  export type WarehouseInvoicesMaxAggregateInputType = {
    id?: true
    targetWarehouseId?: true
    warehouseId?: true
    isFullfilled?: true
    dateCreated?: true
    dateUpdated?: true
  }

  export type WarehouseInvoicesCountAggregateInputType = {
    id?: true
    targetWarehouseId?: true
    warehouseId?: true
    isFullfilled?: true
    dateCreated?: true
    dateUpdated?: true
    _all?: true
  }

  export type WarehouseInvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseInvoices to aggregate.
     */
    where?: WarehouseInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseInvoices to fetch.
     */
    orderBy?: WarehouseInvoicesOrderByWithRelationInput | WarehouseInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WarehouseInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WarehouseInvoices
    **/
    _count?: true | WarehouseInvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WarehouseInvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WarehouseInvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarehouseInvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarehouseInvoicesMaxAggregateInputType
  }

  export type GetWarehouseInvoicesAggregateType<T extends WarehouseInvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateWarehouseInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarehouseInvoices[P]>
      : GetScalarType<T[P], AggregateWarehouseInvoices[P]>
  }




  export type WarehouseInvoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WarehouseInvoicesWhereInput
    orderBy?: WarehouseInvoicesOrderByWithAggregationInput | WarehouseInvoicesOrderByWithAggregationInput[]
    by: WarehouseInvoicesScalarFieldEnum[] | WarehouseInvoicesScalarFieldEnum
    having?: WarehouseInvoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarehouseInvoicesCountAggregateInputType | true
    _avg?: WarehouseInvoicesAvgAggregateInputType
    _sum?: WarehouseInvoicesSumAggregateInputType
    _min?: WarehouseInvoicesMinAggregateInputType
    _max?: WarehouseInvoicesMaxAggregateInputType
  }

  export type WarehouseInvoicesGroupByOutputType = {
    id: number
    targetWarehouseId: number
    warehouseId: number | null
    isFullfilled: boolean
    dateCreated: Date
    dateUpdated: Date
    _count: WarehouseInvoicesCountAggregateOutputType | null
    _avg: WarehouseInvoicesAvgAggregateOutputType | null
    _sum: WarehouseInvoicesSumAggregateOutputType | null
    _min: WarehouseInvoicesMinAggregateOutputType | null
    _max: WarehouseInvoicesMaxAggregateOutputType | null
  }

  type GetWarehouseInvoicesGroupByPayload<T extends WarehouseInvoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarehouseInvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarehouseInvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarehouseInvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], WarehouseInvoicesGroupByOutputType[P]>
        }
      >
    >


  export type WarehouseInvoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetWarehouseId?: boolean
    warehouseId?: boolean
    isFullfilled?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
    Warehouses?: boolean | WarehouseInvoices$WarehousesArgs<ExtArgs>
    WarehouseTransactions?: boolean | WarehouseInvoices$WarehouseTransactionsArgs<ExtArgs>
    _count?: boolean | WarehouseInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["warehouseInvoices"]>

  export type WarehouseInvoicesSelectScalar = {
    id?: boolean
    targetWarehouseId?: boolean
    warehouseId?: boolean
    isFullfilled?: boolean
    dateCreated?: boolean
    dateUpdated?: boolean
  }

  export type WarehouseInvoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Warehouses?: boolean | WarehouseInvoices$WarehousesArgs<ExtArgs>
    WarehouseTransactions?: boolean | WarehouseInvoices$WarehouseTransactionsArgs<ExtArgs>
    _count?: boolean | WarehouseInvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $WarehouseInvoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WarehouseInvoices"
    objects: {
      Warehouses: Prisma.$WarehousesPayload<ExtArgs> | null
      WarehouseTransactions: Prisma.$WarehouseTransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      targetWarehouseId: number
      warehouseId: number | null
      isFullfilled: boolean
      dateCreated: Date
      dateUpdated: Date
    }, ExtArgs["result"]["warehouseInvoices"]>
    composites: {}
  }


  type WarehouseInvoicesGetPayload<S extends boolean | null | undefined | WarehouseInvoicesDefaultArgs> = $Result.GetResult<Prisma.$WarehouseInvoicesPayload, S>

  type WarehouseInvoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WarehouseInvoicesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WarehouseInvoicesCountAggregateInputType | true
    }

  export interface WarehouseInvoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WarehouseInvoices'], meta: { name: 'WarehouseInvoices' } }
    /**
     * Find zero or one WarehouseInvoices that matches the filter.
     * @param {WarehouseInvoicesFindUniqueArgs} args - Arguments to find a WarehouseInvoices
     * @example
     * // Get one WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WarehouseInvoicesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesFindUniqueArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one WarehouseInvoices that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WarehouseInvoicesFindUniqueOrThrowArgs} args - Arguments to find a WarehouseInvoices
     * @example
     * // Get one WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WarehouseInvoicesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first WarehouseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesFindFirstArgs} args - Arguments to find a WarehouseInvoices
     * @example
     * // Get one WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WarehouseInvoicesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesFindFirstArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first WarehouseInvoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesFindFirstOrThrowArgs} args - Arguments to find a WarehouseInvoices
     * @example
     * // Get one WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WarehouseInvoicesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more WarehouseInvoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findMany()
     * 
     * // Get first 10 WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warehouseInvoicesWithIdOnly = await prisma.warehouseInvoices.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WarehouseInvoicesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a WarehouseInvoices.
     * @param {WarehouseInvoicesCreateArgs} args - Arguments to create a WarehouseInvoices.
     * @example
     * // Create one WarehouseInvoices
     * const WarehouseInvoices = await prisma.warehouseInvoices.create({
     *   data: {
     *     // ... data to create a WarehouseInvoices
     *   }
     * })
     * 
    **/
    create<T extends WarehouseInvoicesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesCreateArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many WarehouseInvoices.
     *     @param {WarehouseInvoicesCreateManyArgs} args - Arguments to create many WarehouseInvoices.
     *     @example
     *     // Create many WarehouseInvoices
     *     const warehouseInvoices = await prisma.warehouseInvoices.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WarehouseInvoicesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WarehouseInvoices.
     * @param {WarehouseInvoicesDeleteArgs} args - Arguments to delete one WarehouseInvoices.
     * @example
     * // Delete one WarehouseInvoices
     * const WarehouseInvoices = await prisma.warehouseInvoices.delete({
     *   where: {
     *     // ... filter to delete one WarehouseInvoices
     *   }
     * })
     * 
    **/
    delete<T extends WarehouseInvoicesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesDeleteArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one WarehouseInvoices.
     * @param {WarehouseInvoicesUpdateArgs} args - Arguments to update one WarehouseInvoices.
     * @example
     * // Update one WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WarehouseInvoicesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesUpdateArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more WarehouseInvoices.
     * @param {WarehouseInvoicesDeleteManyArgs} args - Arguments to filter WarehouseInvoices to delete.
     * @example
     * // Delete a few WarehouseInvoices
     * const { count } = await prisma.warehouseInvoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WarehouseInvoicesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WarehouseInvoicesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WarehouseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WarehouseInvoicesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WarehouseInvoices.
     * @param {WarehouseInvoicesUpsertArgs} args - Arguments to update or create a WarehouseInvoices.
     * @example
     * // Update or create a WarehouseInvoices
     * const warehouseInvoices = await prisma.warehouseInvoices.upsert({
     *   create: {
     *     // ... data to create a WarehouseInvoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WarehouseInvoices we want to update
     *   }
     * })
    **/
    upsert<T extends WarehouseInvoicesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WarehouseInvoicesUpsertArgs<ExtArgs>>
    ): Prisma__WarehouseInvoicesClient<$Result.GetResult<Prisma.$WarehouseInvoicesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of WarehouseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesCountArgs} args - Arguments to filter WarehouseInvoices to count.
     * @example
     * // Count the number of WarehouseInvoices
     * const count = await prisma.warehouseInvoices.count({
     *   where: {
     *     // ... the filter for the WarehouseInvoices we want to count
     *   }
     * })
    **/
    count<T extends WarehouseInvoicesCountArgs>(
      args?: Subset<T, WarehouseInvoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarehouseInvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WarehouseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarehouseInvoicesAggregateArgs>(args: Subset<T, WarehouseInvoicesAggregateArgs>): Prisma.PrismaPromise<GetWarehouseInvoicesAggregateType<T>>

    /**
     * Group by WarehouseInvoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarehouseInvoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WarehouseInvoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WarehouseInvoicesGroupByArgs['orderBy'] }
        : { orderBy?: WarehouseInvoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WarehouseInvoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarehouseInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WarehouseInvoices model
   */
  readonly fields: WarehouseInvoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WarehouseInvoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WarehouseInvoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Warehouses<T extends WarehouseInvoices$WarehousesArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseInvoices$WarehousesArgs<ExtArgs>>): Prisma__WarehousesClient<$Result.GetResult<Prisma.$WarehousesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    WarehouseTransactions<T extends WarehouseInvoices$WarehouseTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, WarehouseInvoices$WarehouseTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WarehouseTransactionsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the WarehouseInvoices model
   */ 
  interface WarehouseInvoicesFieldRefs {
    readonly id: FieldRef<"WarehouseInvoices", 'Int'>
    readonly targetWarehouseId: FieldRef<"WarehouseInvoices", 'Int'>
    readonly warehouseId: FieldRef<"WarehouseInvoices", 'Int'>
    readonly isFullfilled: FieldRef<"WarehouseInvoices", 'Boolean'>
    readonly dateCreated: FieldRef<"WarehouseInvoices", 'DateTime'>
    readonly dateUpdated: FieldRef<"WarehouseInvoices", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * WarehouseInvoices findUnique
   */
  export type WarehouseInvoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseInvoices to fetch.
     */
    where: WarehouseInvoicesWhereUniqueInput
  }


  /**
   * WarehouseInvoices findUniqueOrThrow
   */
  export type WarehouseInvoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseInvoices to fetch.
     */
    where: WarehouseInvoicesWhereUniqueInput
  }


  /**
   * WarehouseInvoices findFirst
   */
  export type WarehouseInvoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseInvoices to fetch.
     */
    where?: WarehouseInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseInvoices to fetch.
     */
    orderBy?: WarehouseInvoicesOrderByWithRelationInput | WarehouseInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseInvoices.
     */
    cursor?: WarehouseInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseInvoices.
     */
    distinct?: WarehouseInvoicesScalarFieldEnum | WarehouseInvoicesScalarFieldEnum[]
  }


  /**
   * WarehouseInvoices findFirstOrThrow
   */
  export type WarehouseInvoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseInvoices to fetch.
     */
    where?: WarehouseInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseInvoices to fetch.
     */
    orderBy?: WarehouseInvoicesOrderByWithRelationInput | WarehouseInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WarehouseInvoices.
     */
    cursor?: WarehouseInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseInvoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WarehouseInvoices.
     */
    distinct?: WarehouseInvoicesScalarFieldEnum | WarehouseInvoicesScalarFieldEnum[]
  }


  /**
   * WarehouseInvoices findMany
   */
  export type WarehouseInvoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter, which WarehouseInvoices to fetch.
     */
    where?: WarehouseInvoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WarehouseInvoices to fetch.
     */
    orderBy?: WarehouseInvoicesOrderByWithRelationInput | WarehouseInvoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WarehouseInvoices.
     */
    cursor?: WarehouseInvoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WarehouseInvoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WarehouseInvoices.
     */
    skip?: number
    distinct?: WarehouseInvoicesScalarFieldEnum | WarehouseInvoicesScalarFieldEnum[]
  }


  /**
   * WarehouseInvoices create
   */
  export type WarehouseInvoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a WarehouseInvoices.
     */
    data: XOR<WarehouseInvoicesCreateInput, WarehouseInvoicesUncheckedCreateInput>
  }


  /**
   * WarehouseInvoices createMany
   */
  export type WarehouseInvoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WarehouseInvoices.
     */
    data: WarehouseInvoicesCreateManyInput | WarehouseInvoicesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * WarehouseInvoices update
   */
  export type WarehouseInvoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a WarehouseInvoices.
     */
    data: XOR<WarehouseInvoicesUpdateInput, WarehouseInvoicesUncheckedUpdateInput>
    /**
     * Choose, which WarehouseInvoices to update.
     */
    where: WarehouseInvoicesWhereUniqueInput
  }


  /**
   * WarehouseInvoices updateMany
   */
  export type WarehouseInvoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WarehouseInvoices.
     */
    data: XOR<WarehouseInvoicesUpdateManyMutationInput, WarehouseInvoicesUncheckedUpdateManyInput>
    /**
     * Filter which WarehouseInvoices to update
     */
    where?: WarehouseInvoicesWhereInput
  }


  /**
   * WarehouseInvoices upsert
   */
  export type WarehouseInvoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the WarehouseInvoices to update in case it exists.
     */
    where: WarehouseInvoicesWhereUniqueInput
    /**
     * In case the WarehouseInvoices found by the `where` argument doesn't exist, create a new WarehouseInvoices with this data.
     */
    create: XOR<WarehouseInvoicesCreateInput, WarehouseInvoicesUncheckedCreateInput>
    /**
     * In case the WarehouseInvoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WarehouseInvoicesUpdateInput, WarehouseInvoicesUncheckedUpdateInput>
  }


  /**
   * WarehouseInvoices delete
   */
  export type WarehouseInvoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
    /**
     * Filter which WarehouseInvoices to delete.
     */
    where: WarehouseInvoicesWhereUniqueInput
  }


  /**
   * WarehouseInvoices deleteMany
   */
  export type WarehouseInvoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WarehouseInvoices to delete
     */
    where?: WarehouseInvoicesWhereInput
  }


  /**
   * WarehouseInvoices.Warehouses
   */
  export type WarehouseInvoices$WarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Warehouses
     */
    select?: WarehousesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehousesInclude<ExtArgs> | null
    where?: WarehousesWhereInput
  }


  /**
   * WarehouseInvoices.WarehouseTransactions
   */
  export type WarehouseInvoices$WarehouseTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseTransactions
     */
    select?: WarehouseTransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseTransactionsInclude<ExtArgs> | null
    where?: WarehouseTransactionsWhereInput
    orderBy?: WarehouseTransactionsOrderByWithRelationInput | WarehouseTransactionsOrderByWithRelationInput[]
    cursor?: WarehouseTransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WarehouseTransactionsScalarFieldEnum | WarehouseTransactionsScalarFieldEnum[]
  }


  /**
   * WarehouseInvoices without action
   */
  export type WarehouseInvoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WarehouseInvoices
     */
    select?: WarehouseInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WarehouseInvoicesInclude<ExtArgs> | null
  }



  /**
   * Model CounterReceipts
   */

  export type AggregateCounterReceipts = {
    _count: CounterReceiptsCountAggregateOutputType | null
    _avg: CounterReceiptsAvgAggregateOutputType | null
    _sum: CounterReceiptsSumAggregateOutputType | null
    _min: CounterReceiptsMinAggregateOutputType | null
    _max: CounterReceiptsMaxAggregateOutputType | null
  }

  export type CounterReceiptsAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    customerId: number | null
  }

  export type CounterReceiptsSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    customerId: number | null
  }

  export type CounterReceiptsMinAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    dueDate: Date | null
    dateCreated: Date | null
    customerId: number | null
  }

  export type CounterReceiptsMaxAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    dueDate: Date | null
    dateCreated: Date | null
    customerId: number | null
  }

  export type CounterReceiptsCountAggregateOutputType = {
    id: number
    totalAmount: number
    dueDate: number
    dateCreated: number
    customerId: number
    _all: number
  }


  export type CounterReceiptsAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    customerId?: true
  }

  export type CounterReceiptsSumAggregateInputType = {
    id?: true
    totalAmount?: true
    customerId?: true
  }

  export type CounterReceiptsMinAggregateInputType = {
    id?: true
    totalAmount?: true
    dueDate?: true
    dateCreated?: true
    customerId?: true
  }

  export type CounterReceiptsMaxAggregateInputType = {
    id?: true
    totalAmount?: true
    dueDate?: true
    dateCreated?: true
    customerId?: true
  }

  export type CounterReceiptsCountAggregateInputType = {
    id?: true
    totalAmount?: true
    dueDate?: true
    dateCreated?: true
    customerId?: true
    _all?: true
  }

  export type CounterReceiptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CounterReceipts to aggregate.
     */
    where?: CounterReceiptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterReceipts to fetch.
     */
    orderBy?: CounterReceiptsOrderByWithRelationInput | CounterReceiptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CounterReceiptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CounterReceipts
    **/
    _count?: true | CounterReceiptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CounterReceiptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CounterReceiptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CounterReceiptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CounterReceiptsMaxAggregateInputType
  }

  export type GetCounterReceiptsAggregateType<T extends CounterReceiptsAggregateArgs> = {
        [P in keyof T & keyof AggregateCounterReceipts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCounterReceipts[P]>
      : GetScalarType<T[P], AggregateCounterReceipts[P]>
  }




  export type CounterReceiptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CounterReceiptsWhereInput
    orderBy?: CounterReceiptsOrderByWithAggregationInput | CounterReceiptsOrderByWithAggregationInput[]
    by: CounterReceiptsScalarFieldEnum[] | CounterReceiptsScalarFieldEnum
    having?: CounterReceiptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CounterReceiptsCountAggregateInputType | true
    _avg?: CounterReceiptsAvgAggregateInputType
    _sum?: CounterReceiptsSumAggregateInputType
    _min?: CounterReceiptsMinAggregateInputType
    _max?: CounterReceiptsMaxAggregateInputType
  }

  export type CounterReceiptsGroupByOutputType = {
    id: number
    totalAmount: number
    dueDate: Date
    dateCreated: Date
    customerId: number | null
    _count: CounterReceiptsCountAggregateOutputType | null
    _avg: CounterReceiptsAvgAggregateOutputType | null
    _sum: CounterReceiptsSumAggregateOutputType | null
    _min: CounterReceiptsMinAggregateOutputType | null
    _max: CounterReceiptsMaxAggregateOutputType | null
  }

  type GetCounterReceiptsGroupByPayload<T extends CounterReceiptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CounterReceiptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CounterReceiptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CounterReceiptsGroupByOutputType[P]>
            : GetScalarType<T[P], CounterReceiptsGroupByOutputType[P]>
        }
      >
    >


  export type CounterReceiptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalAmount?: boolean
    dueDate?: boolean
    dateCreated?: boolean
    customerId?: boolean
    CustomerInvoices?: boolean | CounterReceipts$CustomerInvoicesArgs<ExtArgs>
    Customers?: boolean | CounterReceipts$CustomersArgs<ExtArgs>
    _count?: boolean | CounterReceiptsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["counterReceipts"]>

  export type CounterReceiptsSelectScalar = {
    id?: boolean
    totalAmount?: boolean
    dueDate?: boolean
    dateCreated?: boolean
    customerId?: boolean
  }

  export type CounterReceiptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CustomerInvoices?: boolean | CounterReceipts$CustomerInvoicesArgs<ExtArgs>
    Customers?: boolean | CounterReceipts$CustomersArgs<ExtArgs>
    _count?: boolean | CounterReceiptsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CounterReceiptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CounterReceipts"
    objects: {
      CustomerInvoices: Prisma.$CustomerInvoicesPayload<ExtArgs>[]
      Customers: Prisma.$CustomersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalAmount: number
      dueDate: Date
      dateCreated: Date
      customerId: number | null
    }, ExtArgs["result"]["counterReceipts"]>
    composites: {}
  }


  type CounterReceiptsGetPayload<S extends boolean | null | undefined | CounterReceiptsDefaultArgs> = $Result.GetResult<Prisma.$CounterReceiptsPayload, S>

  type CounterReceiptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CounterReceiptsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CounterReceiptsCountAggregateInputType | true
    }

  export interface CounterReceiptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CounterReceipts'], meta: { name: 'CounterReceipts' } }
    /**
     * Find zero or one CounterReceipts that matches the filter.
     * @param {CounterReceiptsFindUniqueArgs} args - Arguments to find a CounterReceipts
     * @example
     * // Get one CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CounterReceiptsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsFindUniqueArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CounterReceipts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CounterReceiptsFindUniqueOrThrowArgs} args - Arguments to find a CounterReceipts
     * @example
     * // Get one CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CounterReceiptsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CounterReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsFindFirstArgs} args - Arguments to find a CounterReceipts
     * @example
     * // Get one CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CounterReceiptsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsFindFirstArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CounterReceipts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsFindFirstOrThrowArgs} args - Arguments to find a CounterReceipts
     * @example
     * // Get one CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CounterReceiptsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CounterReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findMany()
     * 
     * // Get first 10 CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const counterReceiptsWithIdOnly = await prisma.counterReceipts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CounterReceiptsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CounterReceipts.
     * @param {CounterReceiptsCreateArgs} args - Arguments to create a CounterReceipts.
     * @example
     * // Create one CounterReceipts
     * const CounterReceipts = await prisma.counterReceipts.create({
     *   data: {
     *     // ... data to create a CounterReceipts
     *   }
     * })
     * 
    **/
    create<T extends CounterReceiptsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsCreateArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CounterReceipts.
     *     @param {CounterReceiptsCreateManyArgs} args - Arguments to create many CounterReceipts.
     *     @example
     *     // Create many CounterReceipts
     *     const counterReceipts = await prisma.counterReceipts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CounterReceiptsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CounterReceipts.
     * @param {CounterReceiptsDeleteArgs} args - Arguments to delete one CounterReceipts.
     * @example
     * // Delete one CounterReceipts
     * const CounterReceipts = await prisma.counterReceipts.delete({
     *   where: {
     *     // ... filter to delete one CounterReceipts
     *   }
     * })
     * 
    **/
    delete<T extends CounterReceiptsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsDeleteArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CounterReceipts.
     * @param {CounterReceiptsUpdateArgs} args - Arguments to update one CounterReceipts.
     * @example
     * // Update one CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CounterReceiptsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsUpdateArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CounterReceipts.
     * @param {CounterReceiptsDeleteManyArgs} args - Arguments to filter CounterReceipts to delete.
     * @example
     * // Delete a few CounterReceipts
     * const { count } = await prisma.counterReceipts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CounterReceiptsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CounterReceiptsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CounterReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CounterReceiptsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CounterReceipts.
     * @param {CounterReceiptsUpsertArgs} args - Arguments to update or create a CounterReceipts.
     * @example
     * // Update or create a CounterReceipts
     * const counterReceipts = await prisma.counterReceipts.upsert({
     *   create: {
     *     // ... data to create a CounterReceipts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CounterReceipts we want to update
     *   }
     * })
    **/
    upsert<T extends CounterReceiptsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CounterReceiptsUpsertArgs<ExtArgs>>
    ): Prisma__CounterReceiptsClient<$Result.GetResult<Prisma.$CounterReceiptsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CounterReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsCountArgs} args - Arguments to filter CounterReceipts to count.
     * @example
     * // Count the number of CounterReceipts
     * const count = await prisma.counterReceipts.count({
     *   where: {
     *     // ... the filter for the CounterReceipts we want to count
     *   }
     * })
    **/
    count<T extends CounterReceiptsCountArgs>(
      args?: Subset<T, CounterReceiptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CounterReceiptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CounterReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CounterReceiptsAggregateArgs>(args: Subset<T, CounterReceiptsAggregateArgs>): Prisma.PrismaPromise<GetCounterReceiptsAggregateType<T>>

    /**
     * Group by CounterReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CounterReceiptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CounterReceiptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CounterReceiptsGroupByArgs['orderBy'] }
        : { orderBy?: CounterReceiptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CounterReceiptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCounterReceiptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CounterReceipts model
   */
  readonly fields: CounterReceiptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CounterReceipts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CounterReceiptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    CustomerInvoices<T extends CounterReceipts$CustomerInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, CounterReceipts$CustomerInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerInvoicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Customers<T extends CounterReceipts$CustomersArgs<ExtArgs> = {}>(args?: Subset<T, CounterReceipts$CustomersArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CounterReceipts model
   */ 
  interface CounterReceiptsFieldRefs {
    readonly id: FieldRef<"CounterReceipts", 'Int'>
    readonly totalAmount: FieldRef<"CounterReceipts", 'Float'>
    readonly dueDate: FieldRef<"CounterReceipts", 'DateTime'>
    readonly dateCreated: FieldRef<"CounterReceipts", 'DateTime'>
    readonly customerId: FieldRef<"CounterReceipts", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CounterReceipts findUnique
   */
  export type CounterReceiptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter, which CounterReceipts to fetch.
     */
    where: CounterReceiptsWhereUniqueInput
  }


  /**
   * CounterReceipts findUniqueOrThrow
   */
  export type CounterReceiptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter, which CounterReceipts to fetch.
     */
    where: CounterReceiptsWhereUniqueInput
  }


  /**
   * CounterReceipts findFirst
   */
  export type CounterReceiptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter, which CounterReceipts to fetch.
     */
    where?: CounterReceiptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterReceipts to fetch.
     */
    orderBy?: CounterReceiptsOrderByWithRelationInput | CounterReceiptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CounterReceipts.
     */
    cursor?: CounterReceiptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CounterReceipts.
     */
    distinct?: CounterReceiptsScalarFieldEnum | CounterReceiptsScalarFieldEnum[]
  }


  /**
   * CounterReceipts findFirstOrThrow
   */
  export type CounterReceiptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter, which CounterReceipts to fetch.
     */
    where?: CounterReceiptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterReceipts to fetch.
     */
    orderBy?: CounterReceiptsOrderByWithRelationInput | CounterReceiptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CounterReceipts.
     */
    cursor?: CounterReceiptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CounterReceipts.
     */
    distinct?: CounterReceiptsScalarFieldEnum | CounterReceiptsScalarFieldEnum[]
  }


  /**
   * CounterReceipts findMany
   */
  export type CounterReceiptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter, which CounterReceipts to fetch.
     */
    where?: CounterReceiptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CounterReceipts to fetch.
     */
    orderBy?: CounterReceiptsOrderByWithRelationInput | CounterReceiptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CounterReceipts.
     */
    cursor?: CounterReceiptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CounterReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CounterReceipts.
     */
    skip?: number
    distinct?: CounterReceiptsScalarFieldEnum | CounterReceiptsScalarFieldEnum[]
  }


  /**
   * CounterReceipts create
   */
  export type CounterReceiptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * The data needed to create a CounterReceipts.
     */
    data: XOR<CounterReceiptsCreateInput, CounterReceiptsUncheckedCreateInput>
  }


  /**
   * CounterReceipts createMany
   */
  export type CounterReceiptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CounterReceipts.
     */
    data: CounterReceiptsCreateManyInput | CounterReceiptsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CounterReceipts update
   */
  export type CounterReceiptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * The data needed to update a CounterReceipts.
     */
    data: XOR<CounterReceiptsUpdateInput, CounterReceiptsUncheckedUpdateInput>
    /**
     * Choose, which CounterReceipts to update.
     */
    where: CounterReceiptsWhereUniqueInput
  }


  /**
   * CounterReceipts updateMany
   */
  export type CounterReceiptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CounterReceipts.
     */
    data: XOR<CounterReceiptsUpdateManyMutationInput, CounterReceiptsUncheckedUpdateManyInput>
    /**
     * Filter which CounterReceipts to update
     */
    where?: CounterReceiptsWhereInput
  }


  /**
   * CounterReceipts upsert
   */
  export type CounterReceiptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * The filter to search for the CounterReceipts to update in case it exists.
     */
    where: CounterReceiptsWhereUniqueInput
    /**
     * In case the CounterReceipts found by the `where` argument doesn't exist, create a new CounterReceipts with this data.
     */
    create: XOR<CounterReceiptsCreateInput, CounterReceiptsUncheckedCreateInput>
    /**
     * In case the CounterReceipts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CounterReceiptsUpdateInput, CounterReceiptsUncheckedUpdateInput>
  }


  /**
   * CounterReceipts delete
   */
  export type CounterReceiptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
    /**
     * Filter which CounterReceipts to delete.
     */
    where: CounterReceiptsWhereUniqueInput
  }


  /**
   * CounterReceipts deleteMany
   */
  export type CounterReceiptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CounterReceipts to delete
     */
    where?: CounterReceiptsWhereInput
  }


  /**
   * CounterReceipts.CustomerInvoices
   */
  export type CounterReceipts$CustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerInvoices
     */
    select?: CustomerInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInvoicesInclude<ExtArgs> | null
    where?: CustomerInvoicesWhereInput
    orderBy?: CustomerInvoicesOrderByWithRelationInput | CustomerInvoicesOrderByWithRelationInput[]
    cursor?: CustomerInvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerInvoicesScalarFieldEnum | CustomerInvoicesScalarFieldEnum[]
  }


  /**
   * CounterReceipts.Customers
   */
  export type CounterReceipts$CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
  }


  /**
   * CounterReceipts without action
   */
  export type CounterReceiptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CounterReceipts
     */
    select?: CounterReceiptsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CounterReceiptsInclude<ExtArgs> | null
  }



  /**
   * Model CheckVouchers
   */

  export type AggregateCheckVouchers = {
    _count: CheckVouchersCountAggregateOutputType | null
    _avg: CheckVouchersAvgAggregateOutputType | null
    _sum: CheckVouchersSumAggregateOutputType | null
    _min: CheckVouchersMinAggregateOutputType | null
    _max: CheckVouchersMaxAggregateOutputType | null
  }

  export type CheckVouchersAvgAggregateOutputType = {
    id: number | null
    discount: number | null
    totalAmount: number | null
    supplierId: number | null
  }

  export type CheckVouchersSumAggregateOutputType = {
    id: number | null
    discount: number | null
    totalAmount: number | null
    supplierId: number | null
  }

  export type CheckVouchersMinAggregateOutputType = {
    id: number | null
    discount: number | null
    totalAmount: number | null
    bank: string | null
    checkNumber: string | null
    dueDate: Date | null
    dateCreated: Date | null
    supplierId: number | null
  }

  export type CheckVouchersMaxAggregateOutputType = {
    id: number | null
    discount: number | null
    totalAmount: number | null
    bank: string | null
    checkNumber: string | null
    dueDate: Date | null
    dateCreated: Date | null
    supplierId: number | null
  }

  export type CheckVouchersCountAggregateOutputType = {
    id: number
    discount: number
    totalAmount: number
    bank: number
    checkNumber: number
    dueDate: number
    dateCreated: number
    supplierId: number
    _all: number
  }


  export type CheckVouchersAvgAggregateInputType = {
    id?: true
    discount?: true
    totalAmount?: true
    supplierId?: true
  }

  export type CheckVouchersSumAggregateInputType = {
    id?: true
    discount?: true
    totalAmount?: true
    supplierId?: true
  }

  export type CheckVouchersMinAggregateInputType = {
    id?: true
    discount?: true
    totalAmount?: true
    bank?: true
    checkNumber?: true
    dueDate?: true
    dateCreated?: true
    supplierId?: true
  }

  export type CheckVouchersMaxAggregateInputType = {
    id?: true
    discount?: true
    totalAmount?: true
    bank?: true
    checkNumber?: true
    dueDate?: true
    dateCreated?: true
    supplierId?: true
  }

  export type CheckVouchersCountAggregateInputType = {
    id?: true
    discount?: true
    totalAmount?: true
    bank?: true
    checkNumber?: true
    dueDate?: true
    dateCreated?: true
    supplierId?: true
    _all?: true
  }

  export type CheckVouchersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckVouchers to aggregate.
     */
    where?: CheckVouchersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckVouchers to fetch.
     */
    orderBy?: CheckVouchersOrderByWithRelationInput | CheckVouchersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckVouchersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheckVouchers
    **/
    _count?: true | CheckVouchersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheckVouchersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheckVouchersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckVouchersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckVouchersMaxAggregateInputType
  }

  export type GetCheckVouchersAggregateType<T extends CheckVouchersAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckVouchers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckVouchers[P]>
      : GetScalarType<T[P], AggregateCheckVouchers[P]>
  }




  export type CheckVouchersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckVouchersWhereInput
    orderBy?: CheckVouchersOrderByWithAggregationInput | CheckVouchersOrderByWithAggregationInput[]
    by: CheckVouchersScalarFieldEnum[] | CheckVouchersScalarFieldEnum
    having?: CheckVouchersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckVouchersCountAggregateInputType | true
    _avg?: CheckVouchersAvgAggregateInputType
    _sum?: CheckVouchersSumAggregateInputType
    _min?: CheckVouchersMinAggregateInputType
    _max?: CheckVouchersMaxAggregateInputType
  }

  export type CheckVouchersGroupByOutputType = {
    id: number
    discount: number
    totalAmount: number
    bank: string
    checkNumber: string
    dueDate: Date
    dateCreated: Date
    supplierId: number | null
    _count: CheckVouchersCountAggregateOutputType | null
    _avg: CheckVouchersAvgAggregateOutputType | null
    _sum: CheckVouchersSumAggregateOutputType | null
    _min: CheckVouchersMinAggregateOutputType | null
    _max: CheckVouchersMaxAggregateOutputType | null
  }

  type GetCheckVouchersGroupByPayload<T extends CheckVouchersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckVouchersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckVouchersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckVouchersGroupByOutputType[P]>
            : GetScalarType<T[P], CheckVouchersGroupByOutputType[P]>
        }
      >
    >


  export type CheckVouchersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discount?: boolean
    totalAmount?: boolean
    bank?: boolean
    checkNumber?: boolean
    dueDate?: boolean
    dateCreated?: boolean
    supplierId?: boolean
    SupplierInvoices?: boolean | CheckVouchers$SupplierInvoicesArgs<ExtArgs>
    Supplier?: boolean | CheckVouchers$SupplierArgs<ExtArgs>
    _count?: boolean | CheckVouchersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkVouchers"]>

  export type CheckVouchersSelectScalar = {
    id?: boolean
    discount?: boolean
    totalAmount?: boolean
    bank?: boolean
    checkNumber?: boolean
    dueDate?: boolean
    dateCreated?: boolean
    supplierId?: boolean
  }

  export type CheckVouchersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    SupplierInvoices?: boolean | CheckVouchers$SupplierInvoicesArgs<ExtArgs>
    Supplier?: boolean | CheckVouchers$SupplierArgs<ExtArgs>
    _count?: boolean | CheckVouchersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CheckVouchersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheckVouchers"
    objects: {
      SupplierInvoices: Prisma.$SupplierInvoicesPayload<ExtArgs>[]
      Supplier: Prisma.$SuppliersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      discount: number
      totalAmount: number
      bank: string
      checkNumber: string
      dueDate: Date
      dateCreated: Date
      supplierId: number | null
    }, ExtArgs["result"]["checkVouchers"]>
    composites: {}
  }


  type CheckVouchersGetPayload<S extends boolean | null | undefined | CheckVouchersDefaultArgs> = $Result.GetResult<Prisma.$CheckVouchersPayload, S>

  type CheckVouchersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckVouchersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckVouchersCountAggregateInputType | true
    }

  export interface CheckVouchersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheckVouchers'], meta: { name: 'CheckVouchers' } }
    /**
     * Find zero or one CheckVouchers that matches the filter.
     * @param {CheckVouchersFindUniqueArgs} args - Arguments to find a CheckVouchers
     * @example
     * // Get one CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CheckVouchersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersFindUniqueArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CheckVouchers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CheckVouchersFindUniqueOrThrowArgs} args - Arguments to find a CheckVouchers
     * @example
     * // Get one CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CheckVouchersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CheckVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersFindFirstArgs} args - Arguments to find a CheckVouchers
     * @example
     * // Get one CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CheckVouchersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersFindFirstArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CheckVouchers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersFindFirstOrThrowArgs} args - Arguments to find a CheckVouchers
     * @example
     * // Get one CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CheckVouchersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CheckVouchers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findMany()
     * 
     * // Get first 10 CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkVouchersWithIdOnly = await prisma.checkVouchers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CheckVouchersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CheckVouchers.
     * @param {CheckVouchersCreateArgs} args - Arguments to create a CheckVouchers.
     * @example
     * // Create one CheckVouchers
     * const CheckVouchers = await prisma.checkVouchers.create({
     *   data: {
     *     // ... data to create a CheckVouchers
     *   }
     * })
     * 
    **/
    create<T extends CheckVouchersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersCreateArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CheckVouchers.
     *     @param {CheckVouchersCreateManyArgs} args - Arguments to create many CheckVouchers.
     *     @example
     *     // Create many CheckVouchers
     *     const checkVouchers = await prisma.checkVouchers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CheckVouchersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CheckVouchers.
     * @param {CheckVouchersDeleteArgs} args - Arguments to delete one CheckVouchers.
     * @example
     * // Delete one CheckVouchers
     * const CheckVouchers = await prisma.checkVouchers.delete({
     *   where: {
     *     // ... filter to delete one CheckVouchers
     *   }
     * })
     * 
    **/
    delete<T extends CheckVouchersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersDeleteArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CheckVouchers.
     * @param {CheckVouchersUpdateArgs} args - Arguments to update one CheckVouchers.
     * @example
     * // Update one CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CheckVouchersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersUpdateArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CheckVouchers.
     * @param {CheckVouchersDeleteManyArgs} args - Arguments to filter CheckVouchers to delete.
     * @example
     * // Delete a few CheckVouchers
     * const { count } = await prisma.checkVouchers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CheckVouchersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CheckVouchersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheckVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CheckVouchersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheckVouchers.
     * @param {CheckVouchersUpsertArgs} args - Arguments to update or create a CheckVouchers.
     * @example
     * // Update or create a CheckVouchers
     * const checkVouchers = await prisma.checkVouchers.upsert({
     *   create: {
     *     // ... data to create a CheckVouchers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheckVouchers we want to update
     *   }
     * })
    **/
    upsert<T extends CheckVouchersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CheckVouchersUpsertArgs<ExtArgs>>
    ): Prisma__CheckVouchersClient<$Result.GetResult<Prisma.$CheckVouchersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of CheckVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersCountArgs} args - Arguments to filter CheckVouchers to count.
     * @example
     * // Count the number of CheckVouchers
     * const count = await prisma.checkVouchers.count({
     *   where: {
     *     // ... the filter for the CheckVouchers we want to count
     *   }
     * })
    **/
    count<T extends CheckVouchersCountArgs>(
      args?: Subset<T, CheckVouchersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckVouchersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheckVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckVouchersAggregateArgs>(args: Subset<T, CheckVouchersAggregateArgs>): Prisma.PrismaPromise<GetCheckVouchersAggregateType<T>>

    /**
     * Group by CheckVouchers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckVouchersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckVouchersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckVouchersGroupByArgs['orderBy'] }
        : { orderBy?: CheckVouchersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckVouchersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckVouchersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheckVouchers model
   */
  readonly fields: CheckVouchersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheckVouchers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckVouchersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    SupplierInvoices<T extends CheckVouchers$SupplierInvoicesArgs<ExtArgs> = {}>(args?: Subset<T, CheckVouchers$SupplierInvoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierInvoicesPayload<ExtArgs>, T, 'findMany'> | Null>;

    Supplier<T extends CheckVouchers$SupplierArgs<ExtArgs> = {}>(args?: Subset<T, CheckVouchers$SupplierArgs<ExtArgs>>): Prisma__SuppliersClient<$Result.GetResult<Prisma.$SuppliersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CheckVouchers model
   */ 
  interface CheckVouchersFieldRefs {
    readonly id: FieldRef<"CheckVouchers", 'Int'>
    readonly discount: FieldRef<"CheckVouchers", 'Float'>
    readonly totalAmount: FieldRef<"CheckVouchers", 'Float'>
    readonly bank: FieldRef<"CheckVouchers", 'String'>
    readonly checkNumber: FieldRef<"CheckVouchers", 'String'>
    readonly dueDate: FieldRef<"CheckVouchers", 'DateTime'>
    readonly dateCreated: FieldRef<"CheckVouchers", 'DateTime'>
    readonly supplierId: FieldRef<"CheckVouchers", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * CheckVouchers findUnique
   */
  export type CheckVouchersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter, which CheckVouchers to fetch.
     */
    where: CheckVouchersWhereUniqueInput
  }


  /**
   * CheckVouchers findUniqueOrThrow
   */
  export type CheckVouchersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter, which CheckVouchers to fetch.
     */
    where: CheckVouchersWhereUniqueInput
  }


  /**
   * CheckVouchers findFirst
   */
  export type CheckVouchersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter, which CheckVouchers to fetch.
     */
    where?: CheckVouchersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckVouchers to fetch.
     */
    orderBy?: CheckVouchersOrderByWithRelationInput | CheckVouchersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckVouchers.
     */
    cursor?: CheckVouchersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckVouchers.
     */
    distinct?: CheckVouchersScalarFieldEnum | CheckVouchersScalarFieldEnum[]
  }


  /**
   * CheckVouchers findFirstOrThrow
   */
  export type CheckVouchersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter, which CheckVouchers to fetch.
     */
    where?: CheckVouchersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckVouchers to fetch.
     */
    orderBy?: CheckVouchersOrderByWithRelationInput | CheckVouchersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheckVouchers.
     */
    cursor?: CheckVouchersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckVouchers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheckVouchers.
     */
    distinct?: CheckVouchersScalarFieldEnum | CheckVouchersScalarFieldEnum[]
  }


  /**
   * CheckVouchers findMany
   */
  export type CheckVouchersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter, which CheckVouchers to fetch.
     */
    where?: CheckVouchersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheckVouchers to fetch.
     */
    orderBy?: CheckVouchersOrderByWithRelationInput | CheckVouchersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheckVouchers.
     */
    cursor?: CheckVouchersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheckVouchers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheckVouchers.
     */
    skip?: number
    distinct?: CheckVouchersScalarFieldEnum | CheckVouchersScalarFieldEnum[]
  }


  /**
   * CheckVouchers create
   */
  export type CheckVouchersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * The data needed to create a CheckVouchers.
     */
    data: XOR<CheckVouchersCreateInput, CheckVouchersUncheckedCreateInput>
  }


  /**
   * CheckVouchers createMany
   */
  export type CheckVouchersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheckVouchers.
     */
    data: CheckVouchersCreateManyInput | CheckVouchersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * CheckVouchers update
   */
  export type CheckVouchersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * The data needed to update a CheckVouchers.
     */
    data: XOR<CheckVouchersUpdateInput, CheckVouchersUncheckedUpdateInput>
    /**
     * Choose, which CheckVouchers to update.
     */
    where: CheckVouchersWhereUniqueInput
  }


  /**
   * CheckVouchers updateMany
   */
  export type CheckVouchersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheckVouchers.
     */
    data: XOR<CheckVouchersUpdateManyMutationInput, CheckVouchersUncheckedUpdateManyInput>
    /**
     * Filter which CheckVouchers to update
     */
    where?: CheckVouchersWhereInput
  }


  /**
   * CheckVouchers upsert
   */
  export type CheckVouchersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * The filter to search for the CheckVouchers to update in case it exists.
     */
    where: CheckVouchersWhereUniqueInput
    /**
     * In case the CheckVouchers found by the `where` argument doesn't exist, create a new CheckVouchers with this data.
     */
    create: XOR<CheckVouchersCreateInput, CheckVouchersUncheckedCreateInput>
    /**
     * In case the CheckVouchers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckVouchersUpdateInput, CheckVouchersUncheckedUpdateInput>
  }


  /**
   * CheckVouchers delete
   */
  export type CheckVouchersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
    /**
     * Filter which CheckVouchers to delete.
     */
    where: CheckVouchersWhereUniqueInput
  }


  /**
   * CheckVouchers deleteMany
   */
  export type CheckVouchersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheckVouchers to delete
     */
    where?: CheckVouchersWhereInput
  }


  /**
   * CheckVouchers.SupplierInvoices
   */
  export type CheckVouchers$SupplierInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierInvoices
     */
    select?: SupplierInvoicesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInvoicesInclude<ExtArgs> | null
    where?: SupplierInvoicesWhereInput
    orderBy?: SupplierInvoicesOrderByWithRelationInput | SupplierInvoicesOrderByWithRelationInput[]
    cursor?: SupplierInvoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierInvoicesScalarFieldEnum | SupplierInvoicesScalarFieldEnum[]
  }


  /**
   * CheckVouchers.Supplier
   */
  export type CheckVouchers$SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Suppliers
     */
    select?: SuppliersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SuppliersInclude<ExtArgs> | null
    where?: SuppliersWhereInput
  }


  /**
   * CheckVouchers without action
   */
  export type CheckVouchersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheckVouchers
     */
    select?: CheckVouchersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CheckVouchersInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    hashedPassword: 'hashedPassword',
    image: 'image',
    role: 'role'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const ItemsScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    brandId: 'brandId',
    unitId: 'unitId',
    desc1: 'desc1',
    desc2: 'desc2',
    desc3: 'desc3',
    discount1: 'discount1',
    discount2: 'discount2',
    discount3: 'discount3',
    discount4: 'discount4',
    store: 'store',
    cal1: 'cal1',
    cal2: 'cal2',
    cal3: 'cal3',
    ws1: 'ws1',
    ws2: 'ws2',
    ws3: 'ws3',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemsScalarFieldEnum = (typeof ItemsScalarFieldEnum)[keyof typeof ItemsScalarFieldEnum]


  export const SuppliersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    termId: 'termId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuppliersScalarFieldEnum = (typeof SuppliersScalarFieldEnum)[keyof typeof SuppliersScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const WarehousesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WarehousesScalarFieldEnum = (typeof WarehousesScalarFieldEnum)[keyof typeof WarehousesScalarFieldEnum]


  export const InventoryScalarFieldEnum: {
    id: 'id',
    warehouseId: 'warehouseId',
    itemId: 'itemId',
    count: 'count',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryScalarFieldEnum = (typeof InventoryScalarFieldEnum)[keyof typeof InventoryScalarFieldEnum]


  export const UnitsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    plural: 'plural',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UnitsScalarFieldEnum = (typeof UnitsScalarFieldEnum)[keyof typeof UnitsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    termId: 'termId'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const TermsScalarFieldEnum: {
    id: 'id',
    days: 'days'
  };

  export type TermsScalarFieldEnum = (typeof TermsScalarFieldEnum)[keyof typeof TermsScalarFieldEnum]


  export const SupplierTransactionsScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemId: 'itemId',
    quantity: 'quantity',
    inventoryId: 'inventoryId'
  };

  export type SupplierTransactionsScalarFieldEnum = (typeof SupplierTransactionsScalarFieldEnum)[keyof typeof SupplierTransactionsScalarFieldEnum]


  export const SupplierInvoicesScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    isfulfilled: 'isfulfilled',
    totalAmount: 'totalAmount',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    checkVouchersId: 'checkVouchersId'
  };

  export type SupplierInvoicesScalarFieldEnum = (typeof SupplierInvoicesScalarFieldEnum)[keyof typeof SupplierInvoicesScalarFieldEnum]


  export const CustomerTransactionsScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    itemId: 'itemId',
    customerPrice: 'customerPrice',
    storePrice: 'storePrice',
    quantity: 'quantity',
    supplied: 'supplied',
    isDiscounted: 'isDiscounted'
  };

  export type CustomerTransactionsScalarFieldEnum = (typeof CustomerTransactionsScalarFieldEnum)[keyof typeof CustomerTransactionsScalarFieldEnum]


  export const CustomerInvoicesScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    invoiceNumber: 'invoiceNumber',
    invoiceDate: 'invoiceDate',
    isfulfilled: 'isfulfilled',
    isCompleted: 'isCompleted',
    totalAmount: 'totalAmount',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    counterReceiptsId: 'counterReceiptsId'
  };

  export type CustomerInvoicesScalarFieldEnum = (typeof CustomerInvoicesScalarFieldEnum)[keyof typeof CustomerInvoicesScalarFieldEnum]


  export const WarehouseTransactionsScalarFieldEnum: {
    id: 'id',
    inventoryId: 'inventoryId',
    invoiceId: 'invoiceId',
    count: 'count'
  };

  export type WarehouseTransactionsScalarFieldEnum = (typeof WarehouseTransactionsScalarFieldEnum)[keyof typeof WarehouseTransactionsScalarFieldEnum]


  export const WarehouseInvoicesScalarFieldEnum: {
    id: 'id',
    targetWarehouseId: 'targetWarehouseId',
    warehouseId: 'warehouseId',
    isFullfilled: 'isFullfilled',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated'
  };

  export type WarehouseInvoicesScalarFieldEnum = (typeof WarehouseInvoicesScalarFieldEnum)[keyof typeof WarehouseInvoicesScalarFieldEnum]


  export const CounterReceiptsScalarFieldEnum: {
    id: 'id',
    totalAmount: 'totalAmount',
    dueDate: 'dueDate',
    dateCreated: 'dateCreated',
    customerId: 'customerId'
  };

  export type CounterReceiptsScalarFieldEnum = (typeof CounterReceiptsScalarFieldEnum)[keyof typeof CounterReceiptsScalarFieldEnum]


  export const CheckVouchersScalarFieldEnum: {
    id: 'id',
    discount: 'discount',
    totalAmount: 'totalAmount',
    bank: 'bank',
    checkNumber: 'checkNumber',
    dueDate: 'dueDate',
    dateCreated: 'dateCreated',
    supplierId: 'supplierId'
  };

  export type CheckVouchersScalarFieldEnum = (typeof CheckVouchersScalarFieldEnum)[keyof typeof CheckVouchersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    hashedPassword?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: StringNullableFilter<"User"> | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    hashedPassword?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    hashedPassword?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type ItemsWhereInput = {
    AND?: ItemsWhereInput | ItemsWhereInput[]
    OR?: ItemsWhereInput[]
    NOT?: ItemsWhereInput | ItemsWhereInput[]
    id?: IntFilter<"Items"> | number
    supplierId?: IntFilter<"Items"> | number
    brandId?: IntFilter<"Items"> | number
    unitId?: IntFilter<"Items"> | number
    desc1?: StringFilter<"Items"> | string
    desc2?: StringFilter<"Items"> | string
    desc3?: StringFilter<"Items"> | string
    discount1?: FloatFilter<"Items"> | number
    discount2?: FloatFilter<"Items"> | number
    discount3?: FloatFilter<"Items"> | number
    discount4?: FloatFilter<"Items"> | number
    store?: FloatFilter<"Items"> | number
    cal1?: FloatFilter<"Items"> | number
    cal2?: FloatFilter<"Items"> | number
    cal3?: FloatFilter<"Items"> | number
    ws1?: FloatFilter<"Items"> | number
    ws2?: FloatFilter<"Items"> | number
    ws3?: FloatFilter<"Items"> | number
    createdAt?: DateTimeFilter<"Items"> | Date | string
    updatedAt?: DateTimeFilter<"Items"> | Date | string
    supplier?: XOR<SuppliersRelationFilter, SuppliersWhereInput>
    brand?: XOR<BrandsRelationFilter, BrandsWhereInput>
    unit?: XOR<UnitsRelationFilter, UnitsWhereInput>
    inventories?: InventoryListRelationFilter
    supplierTransactions?: SupplierTransactionsListRelationFilter
    CustmerTransactions?: CustomerTransactionsListRelationFilter
  }

  export type ItemsOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    desc1?: SortOrder
    desc2?: SortOrder
    desc3?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: SuppliersOrderByWithRelationInput
    brand?: BrandsOrderByWithRelationInput
    unit?: UnitsOrderByWithRelationInput
    inventories?: InventoryOrderByRelationAggregateInput
    supplierTransactions?: SupplierTransactionsOrderByRelationAggregateInput
    CustmerTransactions?: CustomerTransactionsOrderByRelationAggregateInput
  }

  export type ItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ItemsWhereInput | ItemsWhereInput[]
    OR?: ItemsWhereInput[]
    NOT?: ItemsWhereInput | ItemsWhereInput[]
    supplierId?: IntFilter<"Items"> | number
    brandId?: IntFilter<"Items"> | number
    unitId?: IntFilter<"Items"> | number
    desc1?: StringFilter<"Items"> | string
    desc2?: StringFilter<"Items"> | string
    desc3?: StringFilter<"Items"> | string
    discount1?: FloatFilter<"Items"> | number
    discount2?: FloatFilter<"Items"> | number
    discount3?: FloatFilter<"Items"> | number
    discount4?: FloatFilter<"Items"> | number
    store?: FloatFilter<"Items"> | number
    cal1?: FloatFilter<"Items"> | number
    cal2?: FloatFilter<"Items"> | number
    cal3?: FloatFilter<"Items"> | number
    ws1?: FloatFilter<"Items"> | number
    ws2?: FloatFilter<"Items"> | number
    ws3?: FloatFilter<"Items"> | number
    createdAt?: DateTimeFilter<"Items"> | Date | string
    updatedAt?: DateTimeFilter<"Items"> | Date | string
    supplier?: XOR<SuppliersRelationFilter, SuppliersWhereInput>
    brand?: XOR<BrandsRelationFilter, BrandsWhereInput>
    unit?: XOR<UnitsRelationFilter, UnitsWhereInput>
    inventories?: InventoryListRelationFilter
    supplierTransactions?: SupplierTransactionsListRelationFilter
    CustmerTransactions?: CustomerTransactionsListRelationFilter
  }, "id">

  export type ItemsOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    desc1?: SortOrder
    desc2?: SortOrder
    desc3?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemsCountOrderByAggregateInput
    _avg?: ItemsAvgOrderByAggregateInput
    _max?: ItemsMaxOrderByAggregateInput
    _min?: ItemsMinOrderByAggregateInput
    _sum?: ItemsSumOrderByAggregateInput
  }

  export type ItemsScalarWhereWithAggregatesInput = {
    AND?: ItemsScalarWhereWithAggregatesInput | ItemsScalarWhereWithAggregatesInput[]
    OR?: ItemsScalarWhereWithAggregatesInput[]
    NOT?: ItemsScalarWhereWithAggregatesInput | ItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Items"> | number
    supplierId?: IntWithAggregatesFilter<"Items"> | number
    brandId?: IntWithAggregatesFilter<"Items"> | number
    unitId?: IntWithAggregatesFilter<"Items"> | number
    desc1?: StringWithAggregatesFilter<"Items"> | string
    desc2?: StringWithAggregatesFilter<"Items"> | string
    desc3?: StringWithAggregatesFilter<"Items"> | string
    discount1?: FloatWithAggregatesFilter<"Items"> | number
    discount2?: FloatWithAggregatesFilter<"Items"> | number
    discount3?: FloatWithAggregatesFilter<"Items"> | number
    discount4?: FloatWithAggregatesFilter<"Items"> | number
    store?: FloatWithAggregatesFilter<"Items"> | number
    cal1?: FloatWithAggregatesFilter<"Items"> | number
    cal2?: FloatWithAggregatesFilter<"Items"> | number
    cal3?: FloatWithAggregatesFilter<"Items"> | number
    ws1?: FloatWithAggregatesFilter<"Items"> | number
    ws2?: FloatWithAggregatesFilter<"Items"> | number
    ws3?: FloatWithAggregatesFilter<"Items"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Items"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Items"> | Date | string
  }

  export type SuppliersWhereInput = {
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    id?: IntFilter<"Suppliers"> | number
    name?: StringFilter<"Suppliers"> | string
    address?: StringFilter<"Suppliers"> | string
    termId?: IntFilter<"Suppliers"> | number
    createdAt?: DateTimeFilter<"Suppliers"> | Date | string
    updatedAt?: DateTimeFilter<"Suppliers"> | Date | string
    items?: ItemsListRelationFilter
    Invoices?: SupplierInvoicesListRelationFilter
    CheckVouchers?: CheckVouchersListRelationFilter
    Terms?: XOR<TermsNullableRelationFilter, TermsWhereInput> | null
  }

  export type SuppliersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ItemsOrderByRelationAggregateInput
    Invoices?: SupplierInvoicesOrderByRelationAggregateInput
    CheckVouchers?: CheckVouchersOrderByRelationAggregateInput
    Terms?: TermsOrderByWithRelationInput
  }

  export type SuppliersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SuppliersWhereInput | SuppliersWhereInput[]
    OR?: SuppliersWhereInput[]
    NOT?: SuppliersWhereInput | SuppliersWhereInput[]
    name?: StringFilter<"Suppliers"> | string
    address?: StringFilter<"Suppliers"> | string
    termId?: IntFilter<"Suppliers"> | number
    createdAt?: DateTimeFilter<"Suppliers"> | Date | string
    updatedAt?: DateTimeFilter<"Suppliers"> | Date | string
    items?: ItemsListRelationFilter
    Invoices?: SupplierInvoicesListRelationFilter
    CheckVouchers?: CheckVouchersListRelationFilter
    Terms?: XOR<TermsNullableRelationFilter, TermsWhereInput> | null
  }, "id">

  export type SuppliersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuppliersCountOrderByAggregateInput
    _avg?: SuppliersAvgOrderByAggregateInput
    _max?: SuppliersMaxOrderByAggregateInput
    _min?: SuppliersMinOrderByAggregateInput
    _sum?: SuppliersSumOrderByAggregateInput
  }

  export type SuppliersScalarWhereWithAggregatesInput = {
    AND?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    OR?: SuppliersScalarWhereWithAggregatesInput[]
    NOT?: SuppliersScalarWhereWithAggregatesInput | SuppliersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Suppliers"> | number
    name?: StringWithAggregatesFilter<"Suppliers"> | string
    address?: StringWithAggregatesFilter<"Suppliers"> | string
    termId?: IntWithAggregatesFilter<"Suppliers"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Suppliers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Suppliers"> | Date | string
  }

  export type BrandsWhereInput = {
    AND?: BrandsWhereInput | BrandsWhereInput[]
    OR?: BrandsWhereInput[]
    NOT?: BrandsWhereInput | BrandsWhereInput[]
    id?: IntFilter<"Brands"> | number
    name?: StringFilter<"Brands"> | string
    createdAt?: DateTimeFilter<"Brands"> | Date | string
    updatedAt?: DateTimeFilter<"Brands"> | Date | string
    items?: ItemsListRelationFilter
  }

  export type BrandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: ItemsOrderByRelationAggregateInput
  }

  export type BrandsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BrandsWhereInput | BrandsWhereInput[]
    OR?: BrandsWhereInput[]
    NOT?: BrandsWhereInput | BrandsWhereInput[]
    name?: StringFilter<"Brands"> | string
    createdAt?: DateTimeFilter<"Brands"> | Date | string
    updatedAt?: DateTimeFilter<"Brands"> | Date | string
    items?: ItemsListRelationFilter
  }, "id">

  export type BrandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandsCountOrderByAggregateInput
    _avg?: BrandsAvgOrderByAggregateInput
    _max?: BrandsMaxOrderByAggregateInput
    _min?: BrandsMinOrderByAggregateInput
    _sum?: BrandsSumOrderByAggregateInput
  }

  export type BrandsScalarWhereWithAggregatesInput = {
    AND?: BrandsScalarWhereWithAggregatesInput | BrandsScalarWhereWithAggregatesInput[]
    OR?: BrandsScalarWhereWithAggregatesInput[]
    NOT?: BrandsScalarWhereWithAggregatesInput | BrandsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Brands"> | number
    name?: StringWithAggregatesFilter<"Brands"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Brands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brands"> | Date | string
  }

  export type WarehousesWhereInput = {
    AND?: WarehousesWhereInput | WarehousesWhereInput[]
    OR?: WarehousesWhereInput[]
    NOT?: WarehousesWhereInput | WarehousesWhereInput[]
    id?: IntFilter<"Warehouses"> | number
    name?: StringFilter<"Warehouses"> | string
    location?: StringFilter<"Warehouses"> | string
    createdAt?: DateTimeFilter<"Warehouses"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouses"> | Date | string
    inventories?: InventoryListRelationFilter
    Invoices?: WarehouseInvoicesListRelationFilter
  }

  export type WarehousesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    inventories?: InventoryOrderByRelationAggregateInput
    Invoices?: WarehouseInvoicesOrderByRelationAggregateInput
  }

  export type WarehousesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WarehousesWhereInput | WarehousesWhereInput[]
    OR?: WarehousesWhereInput[]
    NOT?: WarehousesWhereInput | WarehousesWhereInput[]
    name?: StringFilter<"Warehouses"> | string
    location?: StringFilter<"Warehouses"> | string
    createdAt?: DateTimeFilter<"Warehouses"> | Date | string
    updatedAt?: DateTimeFilter<"Warehouses"> | Date | string
    inventories?: InventoryListRelationFilter
    Invoices?: WarehouseInvoicesListRelationFilter
  }, "id">

  export type WarehousesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WarehousesCountOrderByAggregateInput
    _avg?: WarehousesAvgOrderByAggregateInput
    _max?: WarehousesMaxOrderByAggregateInput
    _min?: WarehousesMinOrderByAggregateInput
    _sum?: WarehousesSumOrderByAggregateInput
  }

  export type WarehousesScalarWhereWithAggregatesInput = {
    AND?: WarehousesScalarWhereWithAggregatesInput | WarehousesScalarWhereWithAggregatesInput[]
    OR?: WarehousesScalarWhereWithAggregatesInput[]
    NOT?: WarehousesScalarWhereWithAggregatesInput | WarehousesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Warehouses"> | number
    name?: StringWithAggregatesFilter<"Warehouses"> | string
    location?: StringWithAggregatesFilter<"Warehouses"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Warehouses"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Warehouses"> | Date | string
  }

  export type InventoryWhereInput = {
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    id?: IntFilter<"Inventory"> | number
    warehouseId?: IntFilter<"Inventory"> | number
    itemId?: IntFilter<"Inventory"> | number
    count?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    warehouse?: XOR<WarehousesRelationFilter, WarehousesWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
    SupplierTransactions?: SupplierTransactionsListRelationFilter
    WarehouseTransactions?: WarehouseTransactionsListRelationFilter
  }

  export type InventoryOrderByWithRelationInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    warehouse?: WarehousesOrderByWithRelationInput
    item?: ItemsOrderByWithRelationInput
    SupplierTransactions?: SupplierTransactionsOrderByRelationAggregateInput
    WarehouseTransactions?: WarehouseTransactionsOrderByRelationAggregateInput
  }

  export type InventoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InventoryWhereInput | InventoryWhereInput[]
    OR?: InventoryWhereInput[]
    NOT?: InventoryWhereInput | InventoryWhereInput[]
    warehouseId?: IntFilter<"Inventory"> | number
    itemId?: IntFilter<"Inventory"> | number
    count?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
    warehouse?: XOR<WarehousesRelationFilter, WarehousesWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
    SupplierTransactions?: SupplierTransactionsListRelationFilter
    WarehouseTransactions?: WarehouseTransactionsListRelationFilter
  }, "id">

  export type InventoryOrderByWithAggregationInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryCountOrderByAggregateInput
    _avg?: InventoryAvgOrderByAggregateInput
    _max?: InventoryMaxOrderByAggregateInput
    _min?: InventoryMinOrderByAggregateInput
    _sum?: InventorySumOrderByAggregateInput
  }

  export type InventoryScalarWhereWithAggregatesInput = {
    AND?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    OR?: InventoryScalarWhereWithAggregatesInput[]
    NOT?: InventoryScalarWhereWithAggregatesInput | InventoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inventory"> | number
    warehouseId?: IntWithAggregatesFilter<"Inventory"> | number
    itemId?: IntWithAggregatesFilter<"Inventory"> | number
    count?: IntWithAggregatesFilter<"Inventory"> | number
    price?: FloatWithAggregatesFilter<"Inventory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inventory"> | Date | string
  }

  export type UnitsWhereInput = {
    AND?: UnitsWhereInput | UnitsWhereInput[]
    OR?: UnitsWhereInput[]
    NOT?: UnitsWhereInput | UnitsWhereInput[]
    id?: IntFilter<"Units"> | number
    name?: StringFilter<"Units"> | string
    plural?: StringFilter<"Units"> | string
    createdAt?: DateTimeFilter<"Units"> | Date | string
    updatedAt?: DateTimeFilter<"Units"> | Date | string
    item?: ItemsListRelationFilter
  }

  export type UnitsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    plural?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    item?: ItemsOrderByRelationAggregateInput
  }

  export type UnitsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UnitsWhereInput | UnitsWhereInput[]
    OR?: UnitsWhereInput[]
    NOT?: UnitsWhereInput | UnitsWhereInput[]
    name?: StringFilter<"Units"> | string
    plural?: StringFilter<"Units"> | string
    createdAt?: DateTimeFilter<"Units"> | Date | string
    updatedAt?: DateTimeFilter<"Units"> | Date | string
    item?: ItemsListRelationFilter
  }, "id">

  export type UnitsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    plural?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UnitsCountOrderByAggregateInput
    _avg?: UnitsAvgOrderByAggregateInput
    _max?: UnitsMaxOrderByAggregateInput
    _min?: UnitsMinOrderByAggregateInput
    _sum?: UnitsSumOrderByAggregateInput
  }

  export type UnitsScalarWhereWithAggregatesInput = {
    AND?: UnitsScalarWhereWithAggregatesInput | UnitsScalarWhereWithAggregatesInput[]
    OR?: UnitsScalarWhereWithAggregatesInput[]
    NOT?: UnitsScalarWhereWithAggregatesInput | UnitsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Units"> | number
    name?: StringWithAggregatesFilter<"Units"> | string
    plural?: StringWithAggregatesFilter<"Units"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Units"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Units"> | Date | string
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: IntFilter<"Customers"> | number
    name?: StringFilter<"Customers"> | string
    address?: StringFilter<"Customers"> | string
    termId?: IntFilter<"Customers"> | number
    term?: XOR<TermsRelationFilter, TermsWhereInput>
    CustomerInvoices?: CustomerInvoicesListRelationFilter
    CounterReceits?: CounterReceiptsListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    term?: TermsOrderByWithRelationInput
    CustomerInvoices?: CustomerInvoicesOrderByRelationAggregateInput
    CounterReceits?: CounterReceiptsOrderByRelationAggregateInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    name?: StringFilter<"Customers"> | string
    address?: StringFilter<"Customers"> | string
    termId?: IntFilter<"Customers"> | number
    term?: XOR<TermsRelationFilter, TermsWhereInput>
    CustomerInvoices?: CustomerInvoicesListRelationFilter
    CounterReceits?: CounterReceiptsListRelationFilter
  }, "id">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customers"> | number
    name?: StringWithAggregatesFilter<"Customers"> | string
    address?: StringWithAggregatesFilter<"Customers"> | string
    termId?: IntWithAggregatesFilter<"Customers"> | number
  }

  export type TermsWhereInput = {
    AND?: TermsWhereInput | TermsWhereInput[]
    OR?: TermsWhereInput[]
    NOT?: TermsWhereInput | TermsWhereInput[]
    id?: IntFilter<"Terms"> | number
    days?: StringFilter<"Terms"> | string
    Customers?: CustomersListRelationFilter
    Suppliers?: SuppliersListRelationFilter
  }

  export type TermsOrderByWithRelationInput = {
    id?: SortOrder
    days?: SortOrder
    Customers?: CustomersOrderByRelationAggregateInput
    Suppliers?: SuppliersOrderByRelationAggregateInput
  }

  export type TermsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TermsWhereInput | TermsWhereInput[]
    OR?: TermsWhereInput[]
    NOT?: TermsWhereInput | TermsWhereInput[]
    days?: StringFilter<"Terms"> | string
    Customers?: CustomersListRelationFilter
    Suppliers?: SuppliersListRelationFilter
  }, "id">

  export type TermsOrderByWithAggregationInput = {
    id?: SortOrder
    days?: SortOrder
    _count?: TermsCountOrderByAggregateInput
    _avg?: TermsAvgOrderByAggregateInput
    _max?: TermsMaxOrderByAggregateInput
    _min?: TermsMinOrderByAggregateInput
    _sum?: TermsSumOrderByAggregateInput
  }

  export type TermsScalarWhereWithAggregatesInput = {
    AND?: TermsScalarWhereWithAggregatesInput | TermsScalarWhereWithAggregatesInput[]
    OR?: TermsScalarWhereWithAggregatesInput[]
    NOT?: TermsScalarWhereWithAggregatesInput | TermsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Terms"> | number
    days?: StringWithAggregatesFilter<"Terms"> | string
  }

  export type SupplierTransactionsWhereInput = {
    AND?: SupplierTransactionsWhereInput | SupplierTransactionsWhereInput[]
    OR?: SupplierTransactionsWhereInput[]
    NOT?: SupplierTransactionsWhereInput | SupplierTransactionsWhereInput[]
    id?: IntFilter<"SupplierTransactions"> | number
    invoiceId?: IntFilter<"SupplierTransactions"> | number
    itemId?: IntFilter<"SupplierTransactions"> | number
    quantity?: IntFilter<"SupplierTransactions"> | number
    inventoryId?: IntFilter<"SupplierTransactions"> | number
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
    invoice?: XOR<SupplierInvoicesRelationFilter, SupplierInvoicesWhereInput>
  }

  export type SupplierTransactionsOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
    inventory?: InventoryOrderByWithRelationInput
    item?: ItemsOrderByWithRelationInput
    invoice?: SupplierInvoicesOrderByWithRelationInput
  }

  export type SupplierTransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierTransactionsWhereInput | SupplierTransactionsWhereInput[]
    OR?: SupplierTransactionsWhereInput[]
    NOT?: SupplierTransactionsWhereInput | SupplierTransactionsWhereInput[]
    invoiceId?: IntFilter<"SupplierTransactions"> | number
    itemId?: IntFilter<"SupplierTransactions"> | number
    quantity?: IntFilter<"SupplierTransactions"> | number
    inventoryId?: IntFilter<"SupplierTransactions"> | number
    inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
    invoice?: XOR<SupplierInvoicesRelationFilter, SupplierInvoicesWhereInput>
  }, "id">

  export type SupplierTransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
    _count?: SupplierTransactionsCountOrderByAggregateInput
    _avg?: SupplierTransactionsAvgOrderByAggregateInput
    _max?: SupplierTransactionsMaxOrderByAggregateInput
    _min?: SupplierTransactionsMinOrderByAggregateInput
    _sum?: SupplierTransactionsSumOrderByAggregateInput
  }

  export type SupplierTransactionsScalarWhereWithAggregatesInput = {
    AND?: SupplierTransactionsScalarWhereWithAggregatesInput | SupplierTransactionsScalarWhereWithAggregatesInput[]
    OR?: SupplierTransactionsScalarWhereWithAggregatesInput[]
    NOT?: SupplierTransactionsScalarWhereWithAggregatesInput | SupplierTransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierTransactions"> | number
    invoiceId?: IntWithAggregatesFilter<"SupplierTransactions"> | number
    itemId?: IntWithAggregatesFilter<"SupplierTransactions"> | number
    quantity?: IntWithAggregatesFilter<"SupplierTransactions"> | number
    inventoryId?: IntWithAggregatesFilter<"SupplierTransactions"> | number
  }

  export type SupplierInvoicesWhereInput = {
    AND?: SupplierInvoicesWhereInput | SupplierInvoicesWhereInput[]
    OR?: SupplierInvoicesWhereInput[]
    NOT?: SupplierInvoicesWhereInput | SupplierInvoicesWhereInput[]
    id?: IntFilter<"SupplierInvoices"> | number
    supplierId?: IntFilter<"SupplierInvoices"> | number
    invoiceNumber?: StringFilter<"SupplierInvoices"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoices"> | Date | string
    isfulfilled?: BoolFilter<"SupplierInvoices"> | boolean
    totalAmount?: FloatFilter<"SupplierInvoices"> | number
    dateCreated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    checkVouchersId?: IntNullableFilter<"SupplierInvoices"> | number | null
    supplier?: XOR<SuppliersRelationFilter, SuppliersWhereInput>
    Transactions?: SupplierTransactionsListRelationFilter
    CheckVouchers?: XOR<CheckVouchersNullableRelationFilter, CheckVouchersWhereInput> | null
  }

  export type SupplierInvoicesOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    checkVouchersId?: SortOrderInput | SortOrder
    supplier?: SuppliersOrderByWithRelationInput
    Transactions?: SupplierTransactionsOrderByRelationAggregateInput
    CheckVouchers?: CheckVouchersOrderByWithRelationInput
  }

  export type SupplierInvoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierInvoicesWhereInput | SupplierInvoicesWhereInput[]
    OR?: SupplierInvoicesWhereInput[]
    NOT?: SupplierInvoicesWhereInput | SupplierInvoicesWhereInput[]
    supplierId?: IntFilter<"SupplierInvoices"> | number
    invoiceNumber?: StringFilter<"SupplierInvoices"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoices"> | Date | string
    isfulfilled?: BoolFilter<"SupplierInvoices"> | boolean
    totalAmount?: FloatFilter<"SupplierInvoices"> | number
    dateCreated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    checkVouchersId?: IntNullableFilter<"SupplierInvoices"> | number | null
    supplier?: XOR<SuppliersRelationFilter, SuppliersWhereInput>
    Transactions?: SupplierTransactionsListRelationFilter
    CheckVouchers?: XOR<CheckVouchersNullableRelationFilter, CheckVouchersWhereInput> | null
  }, "id">

  export type SupplierInvoicesOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    checkVouchersId?: SortOrderInput | SortOrder
    _count?: SupplierInvoicesCountOrderByAggregateInput
    _avg?: SupplierInvoicesAvgOrderByAggregateInput
    _max?: SupplierInvoicesMaxOrderByAggregateInput
    _min?: SupplierInvoicesMinOrderByAggregateInput
    _sum?: SupplierInvoicesSumOrderByAggregateInput
  }

  export type SupplierInvoicesScalarWhereWithAggregatesInput = {
    AND?: SupplierInvoicesScalarWhereWithAggregatesInput | SupplierInvoicesScalarWhereWithAggregatesInput[]
    OR?: SupplierInvoicesScalarWhereWithAggregatesInput[]
    NOT?: SupplierInvoicesScalarWhereWithAggregatesInput | SupplierInvoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierInvoices"> | number
    supplierId?: IntWithAggregatesFilter<"SupplierInvoices"> | number
    invoiceNumber?: StringWithAggregatesFilter<"SupplierInvoices"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"SupplierInvoices"> | Date | string
    isfulfilled?: BoolWithAggregatesFilter<"SupplierInvoices"> | boolean
    totalAmount?: FloatWithAggregatesFilter<"SupplierInvoices"> | number
    dateCreated?: DateTimeWithAggregatesFilter<"SupplierInvoices"> | Date | string
    dateUpdated?: DateTimeWithAggregatesFilter<"SupplierInvoices"> | Date | string
    checkVouchersId?: IntNullableWithAggregatesFilter<"SupplierInvoices"> | number | null
  }

  export type CustomerTransactionsWhereInput = {
    AND?: CustomerTransactionsWhereInput | CustomerTransactionsWhereInput[]
    OR?: CustomerTransactionsWhereInput[]
    NOT?: CustomerTransactionsWhereInput | CustomerTransactionsWhereInput[]
    id?: IntFilter<"CustomerTransactions"> | number
    invoiceId?: IntFilter<"CustomerTransactions"> | number
    itemId?: IntFilter<"CustomerTransactions"> | number
    customerPrice?: FloatFilter<"CustomerTransactions"> | number
    storePrice?: FloatFilter<"CustomerTransactions"> | number
    quantity?: IntFilter<"CustomerTransactions"> | number
    supplied?: IntFilter<"CustomerTransactions"> | number
    isDiscounted?: BoolFilter<"CustomerTransactions"> | boolean
    invoice?: XOR<CustomerInvoicesRelationFilter, CustomerInvoicesWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
  }

  export type CustomerTransactionsOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
    isDiscounted?: SortOrder
    invoice?: CustomerInvoicesOrderByWithRelationInput
    item?: ItemsOrderByWithRelationInput
  }

  export type CustomerTransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerTransactionsWhereInput | CustomerTransactionsWhereInput[]
    OR?: CustomerTransactionsWhereInput[]
    NOT?: CustomerTransactionsWhereInput | CustomerTransactionsWhereInput[]
    invoiceId?: IntFilter<"CustomerTransactions"> | number
    itemId?: IntFilter<"CustomerTransactions"> | number
    customerPrice?: FloatFilter<"CustomerTransactions"> | number
    storePrice?: FloatFilter<"CustomerTransactions"> | number
    quantity?: IntFilter<"CustomerTransactions"> | number
    supplied?: IntFilter<"CustomerTransactions"> | number
    isDiscounted?: BoolFilter<"CustomerTransactions"> | boolean
    invoice?: XOR<CustomerInvoicesRelationFilter, CustomerInvoicesWhereInput>
    item?: XOR<ItemsRelationFilter, ItemsWhereInput>
  }, "id">

  export type CustomerTransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
    isDiscounted?: SortOrder
    _count?: CustomerTransactionsCountOrderByAggregateInput
    _avg?: CustomerTransactionsAvgOrderByAggregateInput
    _max?: CustomerTransactionsMaxOrderByAggregateInput
    _min?: CustomerTransactionsMinOrderByAggregateInput
    _sum?: CustomerTransactionsSumOrderByAggregateInput
  }

  export type CustomerTransactionsScalarWhereWithAggregatesInput = {
    AND?: CustomerTransactionsScalarWhereWithAggregatesInput | CustomerTransactionsScalarWhereWithAggregatesInput[]
    OR?: CustomerTransactionsScalarWhereWithAggregatesInput[]
    NOT?: CustomerTransactionsScalarWhereWithAggregatesInput | CustomerTransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerTransactions"> | number
    invoiceId?: IntWithAggregatesFilter<"CustomerTransactions"> | number
    itemId?: IntWithAggregatesFilter<"CustomerTransactions"> | number
    customerPrice?: FloatWithAggregatesFilter<"CustomerTransactions"> | number
    storePrice?: FloatWithAggregatesFilter<"CustomerTransactions"> | number
    quantity?: IntWithAggregatesFilter<"CustomerTransactions"> | number
    supplied?: IntWithAggregatesFilter<"CustomerTransactions"> | number
    isDiscounted?: BoolWithAggregatesFilter<"CustomerTransactions"> | boolean
  }

  export type CustomerInvoicesWhereInput = {
    AND?: CustomerInvoicesWhereInput | CustomerInvoicesWhereInput[]
    OR?: CustomerInvoicesWhereInput[]
    NOT?: CustomerInvoicesWhereInput | CustomerInvoicesWhereInput[]
    id?: IntFilter<"CustomerInvoices"> | number
    customerId?: IntFilter<"CustomerInvoices"> | number
    invoiceNumber?: StringFilter<"CustomerInvoices"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoices"> | Date | string
    isfulfilled?: BoolFilter<"CustomerInvoices"> | boolean
    isCompleted?: BoolFilter<"CustomerInvoices"> | boolean
    totalAmount?: FloatFilter<"CustomerInvoices"> | number
    dateCreated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    counterReceiptsId?: IntNullableFilter<"CustomerInvoices"> | number | null
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    CustmerTransactions?: CustomerTransactionsListRelationFilter
    CounterReceipts?: XOR<CounterReceiptsNullableRelationFilter, CounterReceiptsWhereInput> | null
  }

  export type CustomerInvoicesOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    isCompleted?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    counterReceiptsId?: SortOrderInput | SortOrder
    customer?: CustomersOrderByWithRelationInput
    CustmerTransactions?: CustomerTransactionsOrderByRelationAggregateInput
    CounterReceipts?: CounterReceiptsOrderByWithRelationInput
  }

  export type CustomerInvoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerInvoicesWhereInput | CustomerInvoicesWhereInput[]
    OR?: CustomerInvoicesWhereInput[]
    NOT?: CustomerInvoicesWhereInput | CustomerInvoicesWhereInput[]
    customerId?: IntFilter<"CustomerInvoices"> | number
    invoiceNumber?: StringFilter<"CustomerInvoices"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoices"> | Date | string
    isfulfilled?: BoolFilter<"CustomerInvoices"> | boolean
    isCompleted?: BoolFilter<"CustomerInvoices"> | boolean
    totalAmount?: FloatFilter<"CustomerInvoices"> | number
    dateCreated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    counterReceiptsId?: IntNullableFilter<"CustomerInvoices"> | number | null
    customer?: XOR<CustomersRelationFilter, CustomersWhereInput>
    CustmerTransactions?: CustomerTransactionsListRelationFilter
    CounterReceipts?: XOR<CounterReceiptsNullableRelationFilter, CounterReceiptsWhereInput> | null
  }, "id">

  export type CustomerInvoicesOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    isCompleted?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    counterReceiptsId?: SortOrderInput | SortOrder
    _count?: CustomerInvoicesCountOrderByAggregateInput
    _avg?: CustomerInvoicesAvgOrderByAggregateInput
    _max?: CustomerInvoicesMaxOrderByAggregateInput
    _min?: CustomerInvoicesMinOrderByAggregateInput
    _sum?: CustomerInvoicesSumOrderByAggregateInput
  }

  export type CustomerInvoicesScalarWhereWithAggregatesInput = {
    AND?: CustomerInvoicesScalarWhereWithAggregatesInput | CustomerInvoicesScalarWhereWithAggregatesInput[]
    OR?: CustomerInvoicesScalarWhereWithAggregatesInput[]
    NOT?: CustomerInvoicesScalarWhereWithAggregatesInput | CustomerInvoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerInvoices"> | number
    customerId?: IntWithAggregatesFilter<"CustomerInvoices"> | number
    invoiceNumber?: StringWithAggregatesFilter<"CustomerInvoices"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"CustomerInvoices"> | Date | string
    isfulfilled?: BoolWithAggregatesFilter<"CustomerInvoices"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"CustomerInvoices"> | boolean
    totalAmount?: FloatWithAggregatesFilter<"CustomerInvoices"> | number
    dateCreated?: DateTimeWithAggregatesFilter<"CustomerInvoices"> | Date | string
    dateUpdated?: DateTimeWithAggregatesFilter<"CustomerInvoices"> | Date | string
    counterReceiptsId?: IntNullableWithAggregatesFilter<"CustomerInvoices"> | number | null
  }

  export type WarehouseTransactionsWhereInput = {
    AND?: WarehouseTransactionsWhereInput | WarehouseTransactionsWhereInput[]
    OR?: WarehouseTransactionsWhereInput[]
    NOT?: WarehouseTransactionsWhereInput | WarehouseTransactionsWhereInput[]
    id?: IntFilter<"WarehouseTransactions"> | number
    inventoryId?: IntFilter<"WarehouseTransactions"> | number
    invoiceId?: IntFilter<"WarehouseTransactions"> | number
    count?: IntFilter<"WarehouseTransactions"> | number
    Inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    Invoice?: XOR<WarehouseInvoicesRelationFilter, WarehouseInvoicesWhereInput>
  }

  export type WarehouseTransactionsOrderByWithRelationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
    Inventory?: InventoryOrderByWithRelationInput
    Invoice?: WarehouseInvoicesOrderByWithRelationInput
  }

  export type WarehouseTransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WarehouseTransactionsWhereInput | WarehouseTransactionsWhereInput[]
    OR?: WarehouseTransactionsWhereInput[]
    NOT?: WarehouseTransactionsWhereInput | WarehouseTransactionsWhereInput[]
    inventoryId?: IntFilter<"WarehouseTransactions"> | number
    invoiceId?: IntFilter<"WarehouseTransactions"> | number
    count?: IntFilter<"WarehouseTransactions"> | number
    Inventory?: XOR<InventoryRelationFilter, InventoryWhereInput>
    Invoice?: XOR<WarehouseInvoicesRelationFilter, WarehouseInvoicesWhereInput>
  }, "id">

  export type WarehouseTransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
    _count?: WarehouseTransactionsCountOrderByAggregateInput
    _avg?: WarehouseTransactionsAvgOrderByAggregateInput
    _max?: WarehouseTransactionsMaxOrderByAggregateInput
    _min?: WarehouseTransactionsMinOrderByAggregateInput
    _sum?: WarehouseTransactionsSumOrderByAggregateInput
  }

  export type WarehouseTransactionsScalarWhereWithAggregatesInput = {
    AND?: WarehouseTransactionsScalarWhereWithAggregatesInput | WarehouseTransactionsScalarWhereWithAggregatesInput[]
    OR?: WarehouseTransactionsScalarWhereWithAggregatesInput[]
    NOT?: WarehouseTransactionsScalarWhereWithAggregatesInput | WarehouseTransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WarehouseTransactions"> | number
    inventoryId?: IntWithAggregatesFilter<"WarehouseTransactions"> | number
    invoiceId?: IntWithAggregatesFilter<"WarehouseTransactions"> | number
    count?: IntWithAggregatesFilter<"WarehouseTransactions"> | number
  }

  export type WarehouseInvoicesWhereInput = {
    AND?: WarehouseInvoicesWhereInput | WarehouseInvoicesWhereInput[]
    OR?: WarehouseInvoicesWhereInput[]
    NOT?: WarehouseInvoicesWhereInput | WarehouseInvoicesWhereInput[]
    id?: IntFilter<"WarehouseInvoices"> | number
    targetWarehouseId?: IntFilter<"WarehouseInvoices"> | number
    warehouseId?: IntNullableFilter<"WarehouseInvoices"> | number | null
    isFullfilled?: BoolFilter<"WarehouseInvoices"> | boolean
    dateCreated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
    Warehouses?: XOR<WarehousesNullableRelationFilter, WarehousesWhereInput> | null
    WarehouseTransactions?: WarehouseTransactionsListRelationFilter
  }

  export type WarehouseInvoicesOrderByWithRelationInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    isFullfilled?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    Warehouses?: WarehousesOrderByWithRelationInput
    WarehouseTransactions?: WarehouseTransactionsOrderByRelationAggregateInput
  }

  export type WarehouseInvoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WarehouseInvoicesWhereInput | WarehouseInvoicesWhereInput[]
    OR?: WarehouseInvoicesWhereInput[]
    NOT?: WarehouseInvoicesWhereInput | WarehouseInvoicesWhereInput[]
    targetWarehouseId?: IntFilter<"WarehouseInvoices"> | number
    warehouseId?: IntNullableFilter<"WarehouseInvoices"> | number | null
    isFullfilled?: BoolFilter<"WarehouseInvoices"> | boolean
    dateCreated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
    Warehouses?: XOR<WarehousesNullableRelationFilter, WarehousesWhereInput> | null
    WarehouseTransactions?: WarehouseTransactionsListRelationFilter
  }, "id">

  export type WarehouseInvoicesOrderByWithAggregationInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrderInput | SortOrder
    isFullfilled?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    _count?: WarehouseInvoicesCountOrderByAggregateInput
    _avg?: WarehouseInvoicesAvgOrderByAggregateInput
    _max?: WarehouseInvoicesMaxOrderByAggregateInput
    _min?: WarehouseInvoicesMinOrderByAggregateInput
    _sum?: WarehouseInvoicesSumOrderByAggregateInput
  }

  export type WarehouseInvoicesScalarWhereWithAggregatesInput = {
    AND?: WarehouseInvoicesScalarWhereWithAggregatesInput | WarehouseInvoicesScalarWhereWithAggregatesInput[]
    OR?: WarehouseInvoicesScalarWhereWithAggregatesInput[]
    NOT?: WarehouseInvoicesScalarWhereWithAggregatesInput | WarehouseInvoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"WarehouseInvoices"> | number
    targetWarehouseId?: IntWithAggregatesFilter<"WarehouseInvoices"> | number
    warehouseId?: IntNullableWithAggregatesFilter<"WarehouseInvoices"> | number | null
    isFullfilled?: BoolWithAggregatesFilter<"WarehouseInvoices"> | boolean
    dateCreated?: DateTimeWithAggregatesFilter<"WarehouseInvoices"> | Date | string
    dateUpdated?: DateTimeWithAggregatesFilter<"WarehouseInvoices"> | Date | string
  }

  export type CounterReceiptsWhereInput = {
    AND?: CounterReceiptsWhereInput | CounterReceiptsWhereInput[]
    OR?: CounterReceiptsWhereInput[]
    NOT?: CounterReceiptsWhereInput | CounterReceiptsWhereInput[]
    id?: IntFilter<"CounterReceipts"> | number
    totalAmount?: FloatFilter<"CounterReceipts"> | number
    dueDate?: DateTimeFilter<"CounterReceipts"> | Date | string
    dateCreated?: DateTimeFilter<"CounterReceipts"> | Date | string
    customerId?: IntNullableFilter<"CounterReceipts"> | number | null
    CustomerInvoices?: CustomerInvoicesListRelationFilter
    Customers?: XOR<CustomersNullableRelationFilter, CustomersWhereInput> | null
  }

  export type CounterReceiptsOrderByWithRelationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    customerId?: SortOrderInput | SortOrder
    CustomerInvoices?: CustomerInvoicesOrderByRelationAggregateInput
    Customers?: CustomersOrderByWithRelationInput
  }

  export type CounterReceiptsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CounterReceiptsWhereInput | CounterReceiptsWhereInput[]
    OR?: CounterReceiptsWhereInput[]
    NOT?: CounterReceiptsWhereInput | CounterReceiptsWhereInput[]
    totalAmount?: FloatFilter<"CounterReceipts"> | number
    dueDate?: DateTimeFilter<"CounterReceipts"> | Date | string
    dateCreated?: DateTimeFilter<"CounterReceipts"> | Date | string
    customerId?: IntNullableFilter<"CounterReceipts"> | number | null
    CustomerInvoices?: CustomerInvoicesListRelationFilter
    Customers?: XOR<CustomersNullableRelationFilter, CustomersWhereInput> | null
  }, "id">

  export type CounterReceiptsOrderByWithAggregationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    customerId?: SortOrderInput | SortOrder
    _count?: CounterReceiptsCountOrderByAggregateInput
    _avg?: CounterReceiptsAvgOrderByAggregateInput
    _max?: CounterReceiptsMaxOrderByAggregateInput
    _min?: CounterReceiptsMinOrderByAggregateInput
    _sum?: CounterReceiptsSumOrderByAggregateInput
  }

  export type CounterReceiptsScalarWhereWithAggregatesInput = {
    AND?: CounterReceiptsScalarWhereWithAggregatesInput | CounterReceiptsScalarWhereWithAggregatesInput[]
    OR?: CounterReceiptsScalarWhereWithAggregatesInput[]
    NOT?: CounterReceiptsScalarWhereWithAggregatesInput | CounterReceiptsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CounterReceipts"> | number
    totalAmount?: FloatWithAggregatesFilter<"CounterReceipts"> | number
    dueDate?: DateTimeWithAggregatesFilter<"CounterReceipts"> | Date | string
    dateCreated?: DateTimeWithAggregatesFilter<"CounterReceipts"> | Date | string
    customerId?: IntNullableWithAggregatesFilter<"CounterReceipts"> | number | null
  }

  export type CheckVouchersWhereInput = {
    AND?: CheckVouchersWhereInput | CheckVouchersWhereInput[]
    OR?: CheckVouchersWhereInput[]
    NOT?: CheckVouchersWhereInput | CheckVouchersWhereInput[]
    id?: IntFilter<"CheckVouchers"> | number
    discount?: FloatFilter<"CheckVouchers"> | number
    totalAmount?: FloatFilter<"CheckVouchers"> | number
    bank?: StringFilter<"CheckVouchers"> | string
    checkNumber?: StringFilter<"CheckVouchers"> | string
    dueDate?: DateTimeFilter<"CheckVouchers"> | Date | string
    dateCreated?: DateTimeFilter<"CheckVouchers"> | Date | string
    supplierId?: IntNullableFilter<"CheckVouchers"> | number | null
    SupplierInvoices?: SupplierInvoicesListRelationFilter
    Supplier?: XOR<SuppliersNullableRelationFilter, SuppliersWhereInput> | null
  }

  export type CheckVouchersOrderByWithRelationInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    bank?: SortOrder
    checkNumber?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    SupplierInvoices?: SupplierInvoicesOrderByRelationAggregateInput
    Supplier?: SuppliersOrderByWithRelationInput
  }

  export type CheckVouchersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CheckVouchersWhereInput | CheckVouchersWhereInput[]
    OR?: CheckVouchersWhereInput[]
    NOT?: CheckVouchersWhereInput | CheckVouchersWhereInput[]
    discount?: FloatFilter<"CheckVouchers"> | number
    totalAmount?: FloatFilter<"CheckVouchers"> | number
    bank?: StringFilter<"CheckVouchers"> | string
    checkNumber?: StringFilter<"CheckVouchers"> | string
    dueDate?: DateTimeFilter<"CheckVouchers"> | Date | string
    dateCreated?: DateTimeFilter<"CheckVouchers"> | Date | string
    supplierId?: IntNullableFilter<"CheckVouchers"> | number | null
    SupplierInvoices?: SupplierInvoicesListRelationFilter
    Supplier?: XOR<SuppliersNullableRelationFilter, SuppliersWhereInput> | null
  }, "id">

  export type CheckVouchersOrderByWithAggregationInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    bank?: SortOrder
    checkNumber?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    _count?: CheckVouchersCountOrderByAggregateInput
    _avg?: CheckVouchersAvgOrderByAggregateInput
    _max?: CheckVouchersMaxOrderByAggregateInput
    _min?: CheckVouchersMinOrderByAggregateInput
    _sum?: CheckVouchersSumOrderByAggregateInput
  }

  export type CheckVouchersScalarWhereWithAggregatesInput = {
    AND?: CheckVouchersScalarWhereWithAggregatesInput | CheckVouchersScalarWhereWithAggregatesInput[]
    OR?: CheckVouchersScalarWhereWithAggregatesInput[]
    NOT?: CheckVouchersScalarWhereWithAggregatesInput | CheckVouchersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CheckVouchers"> | number
    discount?: FloatWithAggregatesFilter<"CheckVouchers"> | number
    totalAmount?: FloatWithAggregatesFilter<"CheckVouchers"> | number
    bank?: StringWithAggregatesFilter<"CheckVouchers"> | string
    checkNumber?: StringWithAggregatesFilter<"CheckVouchers"> | string
    dueDate?: DateTimeWithAggregatesFilter<"CheckVouchers"> | Date | string
    dateCreated?: DateTimeWithAggregatesFilter<"CheckVouchers"> | Date | string
    supplierId?: IntNullableWithAggregatesFilter<"CheckVouchers"> | number | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemsCreateInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    brand: BrandsCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateInput = {
    id?: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsUpdateInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemsCreateManyInput = {
    id?: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemsUpdateManyMutationInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuppliersCreateInput = {
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersCreateNestedManyWithoutSupplierInput
    Terms?: TermsCreateNestedOneWithoutSuppliersInput
  }

  export type SuppliersUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    termId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsUncheckedCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUpdateManyWithoutSupplierNestedInput
    Terms?: TermsUpdateOneWithoutSuppliersNestedInput
  }

  export type SuppliersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUncheckedUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUncheckedUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersCreateManyInput = {
    id?: number
    name: string
    address: string
    termId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuppliersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuppliersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsCreateNestedManyWithoutBrandInput
  }

  export type BrandsUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUpdateManyWithoutBrandNestedInput
  }

  export type BrandsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandsCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehousesCreateInput = {
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryCreateNestedManyWithoutWarehouseInput
    Invoices?: WarehouseInvoicesCreateNestedManyWithoutWarehousesInput
  }

  export type WarehousesUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
    Invoices?: WarehouseInvoicesUncheckedCreateNestedManyWithoutWarehousesInput
  }

  export type WarehousesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUpdateManyWithoutWarehouseNestedInput
    Invoices?: WarehouseInvoicesUpdateManyWithoutWarehousesNestedInput
  }

  export type WarehousesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
    Invoices?: WarehouseInvoicesUncheckedUpdateManyWithoutWarehousesNestedInput
  }

  export type WarehousesCreateManyInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehousesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehousesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateInput = {
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehousesCreateNestedOneWithoutInventoriesInput
    item: ItemsCreateNestedOneWithoutInventoriesInput
    SupplierTransactions?: SupplierTransactionsCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateInput = {
    id?: number
    warehouseId: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehousesUpdateOneRequiredWithoutInventoriesNestedInput
    item?: ItemsUpdateOneRequiredWithoutInventoriesNestedInput
    SupplierTransactions?: SupplierTransactionsUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryCreateManyInput = {
    id?: number
    warehouseId: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsCreateInput = {
    name: string
    plural: string
    createdAt?: Date | string
    updatedAt?: Date | string
    item?: ItemsCreateNestedManyWithoutUnitInput
  }

  export type UnitsUncheckedCreateInput = {
    id?: number
    name: string
    plural: string
    createdAt?: Date | string
    updatedAt?: Date | string
    item?: ItemsUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemsUpdateManyWithoutUnitNestedInput
  }

  export type UnitsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemsUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitsCreateManyInput = {
    id?: number
    name: string
    plural: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersCreateInput = {
    name: string
    address: string
    term: TermsCreateNestedOneWithoutCustomersInput
    CustomerInvoices?: CustomerInvoicesCreateNestedManyWithoutCustomerInput
    CounterReceits?: CounterReceiptsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    termId: number
    CustomerInvoices?: CustomerInvoicesUncheckedCreateNestedManyWithoutCustomerInput
    CounterReceits?: CounterReceiptsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    term?: TermsUpdateOneRequiredWithoutCustomersNestedInput
    CustomerInvoices?: CustomerInvoicesUpdateManyWithoutCustomerNestedInput
    CounterReceits?: CounterReceiptsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    CustomerInvoices?: CustomerInvoicesUncheckedUpdateManyWithoutCustomerNestedInput
    CounterReceits?: CounterReceiptsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    name: string
    address: string
    termId: number
  }

  export type CustomersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
  }

  export type TermsCreateInput = {
    days: string
    Customers?: CustomersCreateNestedManyWithoutTermInput
    Suppliers?: SuppliersCreateNestedManyWithoutTermsInput
  }

  export type TermsUncheckedCreateInput = {
    id?: number
    days: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutTermInput
    Suppliers?: SuppliersUncheckedCreateNestedManyWithoutTermsInput
  }

  export type TermsUpdateInput = {
    days?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutTermNestedInput
    Suppliers?: SuppliersUpdateManyWithoutTermsNestedInput
  }

  export type TermsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    days?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutTermNestedInput
    Suppliers?: SuppliersUncheckedUpdateManyWithoutTermsNestedInput
  }

  export type TermsCreateManyInput = {
    id?: number
    days: string
  }

  export type TermsUpdateManyMutationInput = {
    days?: StringFieldUpdateOperationsInput | string
  }

  export type TermsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    days?: StringFieldUpdateOperationsInput | string
  }

  export type SupplierTransactionsCreateInput = {
    quantity: number
    inventory: InventoryCreateNestedOneWithoutSupplierTransactionsInput
    item: ItemsCreateNestedOneWithoutSupplierTransactionsInput
    invoice: SupplierInvoicesCreateNestedOneWithoutTransactionsInput
  }

  export type SupplierTransactionsUncheckedCreateInput = {
    id?: number
    invoiceId: number
    itemId: number
    quantity: number
    inventoryId: number
  }

  export type SupplierTransactionsUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    inventory?: InventoryUpdateOneRequiredWithoutSupplierTransactionsNestedInput
    item?: ItemsUpdateOneRequiredWithoutSupplierTransactionsNestedInput
    invoice?: SupplierInvoicesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type SupplierTransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierTransactionsCreateManyInput = {
    id?: number
    invoiceId: number
    itemId: number
    quantity: number
    inventoryId: number
  }

  export type SupplierTransactionsUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierTransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierInvoicesCreateInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    supplier?: SuppliersCreateNestedOneWithoutInvoicesInput
    Transactions?: SupplierTransactionsCreateNestedManyWithoutInvoiceInput
    CheckVouchers?: CheckVouchersCreateNestedOneWithoutSupplierInvoicesInput
  }

  export type SupplierInvoicesUncheckedCreateInput = {
    id?: number
    supplierId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    checkVouchersId?: number | null
    Transactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SupplierInvoicesUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutInvoicesNestedInput
    Transactions?: SupplierTransactionsUpdateManyWithoutInvoiceNestedInput
    CheckVouchers?: CheckVouchersUpdateOneWithoutSupplierInvoicesNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    checkVouchersId?: NullableIntFieldUpdateOperationsInput | number | null
    Transactions?: SupplierTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SupplierInvoicesCreateManyInput = {
    id?: number
    supplierId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    checkVouchersId?: number | null
  }

  export type SupplierInvoicesUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    checkVouchersId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerTransactionsCreateInput = {
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
    invoice: CustomerInvoicesCreateNestedOneWithoutCustmerTransactionsInput
    item: ItemsCreateNestedOneWithoutCustmerTransactionsInput
  }

  export type CustomerTransactionsUncheckedCreateInput = {
    id?: number
    invoiceId: number
    itemId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type CustomerTransactionsUpdateInput = {
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
    invoice?: CustomerInvoicesUpdateOneRequiredWithoutCustmerTransactionsNestedInput
    item?: ItemsUpdateOneRequiredWithoutCustmerTransactionsNestedInput
  }

  export type CustomerTransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerTransactionsCreateManyInput = {
    id?: number
    invoiceId: number
    itemId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type CustomerTransactionsUpdateManyMutationInput = {
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerTransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerInvoicesCreateInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    customer?: CustomersCreateNestedOneWithoutCustomerInvoicesInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutInvoiceInput
    CounterReceipts?: CounterReceiptsCreateNestedOneWithoutCustomerInvoicesInput
  }

  export type CustomerInvoicesUncheckedCreateInput = {
    id?: number
    customerId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    counterReceiptsId?: number | null
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoicesUpdateInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutInvoiceNestedInput
    CounterReceipts?: CounterReceiptsUpdateOneWithoutCustomerInvoicesNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    counterReceiptsId?: NullableIntFieldUpdateOperationsInput | number | null
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoicesCreateManyInput = {
    id?: number
    customerId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    counterReceiptsId?: number | null
  }

  export type CustomerInvoicesUpdateManyMutationInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    counterReceiptsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WarehouseTransactionsCreateInput = {
    count: number
    Inventory: InventoryCreateNestedOneWithoutWarehouseTransactionsInput
    Invoice: WarehouseInvoicesCreateNestedOneWithoutWarehouseTransactionsInput
  }

  export type WarehouseTransactionsUncheckedCreateInput = {
    id?: number
    inventoryId: number
    invoiceId: number
    count: number
  }

  export type WarehouseTransactionsUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    Inventory?: InventoryUpdateOneRequiredWithoutWarehouseTransactionsNestedInput
    Invoice?: WarehouseInvoicesUpdateOneRequiredWithoutWarehouseTransactionsNestedInput
  }

  export type WarehouseTransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseTransactionsCreateManyInput = {
    id?: number
    inventoryId: number
    invoiceId: number
    count: number
  }

  export type WarehouseTransactionsUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseTransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseInvoicesCreateInput = {
    targetWarehouseId: number
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
    Warehouses?: WarehousesCreateNestedOneWithoutInvoicesInput
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type WarehouseInvoicesUncheckedCreateInput = {
    id?: number
    targetWarehouseId: number
    warehouseId?: number | null
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type WarehouseInvoicesUpdateInput = {
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Warehouses?: WarehousesUpdateOneWithoutInvoicesNestedInput
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type WarehouseInvoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type WarehouseInvoicesCreateManyInput = {
    id?: number
    targetWarehouseId: number
    warehouseId?: number | null
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
  }

  export type WarehouseInvoicesUpdateManyMutationInput = {
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseInvoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterReceiptsCreateInput = {
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    CustomerInvoices?: CustomerInvoicesCreateNestedManyWithoutCounterReceiptsInput
    Customers?: CustomersCreateNestedOneWithoutCounterReceitsInput
  }

  export type CounterReceiptsUncheckedCreateInput = {
    id?: number
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    customerId?: number | null
    CustomerInvoices?: CustomerInvoicesUncheckedCreateNestedManyWithoutCounterReceiptsInput
  }

  export type CounterReceiptsUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerInvoices?: CustomerInvoicesUpdateManyWithoutCounterReceiptsNestedInput
    Customers?: CustomersUpdateOneWithoutCounterReceitsNestedInput
  }

  export type CounterReceiptsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    CustomerInvoices?: CustomerInvoicesUncheckedUpdateManyWithoutCounterReceiptsNestedInput
  }

  export type CounterReceiptsCreateManyInput = {
    id?: number
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    customerId?: number | null
  }

  export type CounterReceiptsUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CounterReceiptsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckVouchersCreateInput = {
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    SupplierInvoices?: SupplierInvoicesCreateNestedManyWithoutCheckVouchersInput
    Supplier?: SuppliersCreateNestedOneWithoutCheckVouchersInput
  }

  export type CheckVouchersUncheckedCreateInput = {
    id?: number
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    supplierId?: number | null
    SupplierInvoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutCheckVouchersInput
  }

  export type CheckVouchersUpdateInput = {
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierInvoices?: SupplierInvoicesUpdateManyWithoutCheckVouchersNestedInput
    Supplier?: SuppliersUpdateOneWithoutCheckVouchersNestedInput
  }

  export type CheckVouchersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
    SupplierInvoices?: SupplierInvoicesUncheckedUpdateManyWithoutCheckVouchersNestedInput
  }

  export type CheckVouchersCreateManyInput = {
    id?: number
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    supplierId?: number | null
  }

  export type CheckVouchersUpdateManyMutationInput = {
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheckVouchersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    hashedPassword?: SortOrder
    image?: SortOrder
    role?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SuppliersRelationFilter = {
    is?: SuppliersWhereInput
    isNot?: SuppliersWhereInput
  }

  export type BrandsRelationFilter = {
    is?: BrandsWhereInput
    isNot?: BrandsWhereInput
  }

  export type UnitsRelationFilter = {
    is?: UnitsWhereInput
    isNot?: UnitsWhereInput
  }

  export type InventoryListRelationFilter = {
    every?: InventoryWhereInput
    some?: InventoryWhereInput
    none?: InventoryWhereInput
  }

  export type SupplierTransactionsListRelationFilter = {
    every?: SupplierTransactionsWhereInput
    some?: SupplierTransactionsWhereInput
    none?: SupplierTransactionsWhereInput
  }

  export type CustomerTransactionsListRelationFilter = {
    every?: CustomerTransactionsWhereInput
    some?: CustomerTransactionsWhereInput
    none?: CustomerTransactionsWhereInput
  }

  export type InventoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierTransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerTransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemsCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    desc1?: SortOrder
    desc2?: SortOrder
    desc3?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
  }

  export type ItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    desc1?: SortOrder
    desc2?: SortOrder
    desc3?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemsMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    desc1?: SortOrder
    desc2?: SortOrder
    desc3?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemsSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    brandId?: SortOrder
    unitId?: SortOrder
    discount1?: SortOrder
    discount2?: SortOrder
    discount3?: SortOrder
    discount4?: SortOrder
    store?: SortOrder
    cal1?: SortOrder
    cal2?: SortOrder
    cal3?: SortOrder
    ws1?: SortOrder
    ws2?: SortOrder
    ws3?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ItemsListRelationFilter = {
    every?: ItemsWhereInput
    some?: ItemsWhereInput
    none?: ItemsWhereInput
  }

  export type SupplierInvoicesListRelationFilter = {
    every?: SupplierInvoicesWhereInput
    some?: SupplierInvoicesWhereInput
    none?: SupplierInvoicesWhereInput
  }

  export type CheckVouchersListRelationFilter = {
    every?: CheckVouchersWhereInput
    some?: CheckVouchersWhereInput
    none?: CheckVouchersWhereInput
  }

  export type TermsNullableRelationFilter = {
    is?: TermsWhereInput | null
    isNot?: TermsWhereInput | null
  }

  export type ItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierInvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheckVouchersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuppliersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuppliersAvgOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
  }

  export type SuppliersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuppliersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuppliersSumOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
  }

  export type BrandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BrandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehouseInvoicesListRelationFilter = {
    every?: WarehouseInvoicesWhereInput
    some?: WarehouseInvoicesWhereInput
    none?: WarehouseInvoicesWhereInput
  }

  export type WarehouseInvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WarehousesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehousesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehousesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehousesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WarehousesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WarehousesRelationFilter = {
    is?: WarehousesWhereInput
    isNot?: WarehousesWhereInput
  }

  export type ItemsRelationFilter = {
    is?: ItemsWhereInput
    isNot?: ItemsWhereInput
  }

  export type WarehouseTransactionsListRelationFilter = {
    every?: WarehouseTransactionsWhereInput
    some?: WarehouseTransactionsWhereInput
    none?: WarehouseTransactionsWhereInput
  }

  export type WarehouseTransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryCountOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryAvgOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
  }

  export type InventoryMaxOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryMinOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventorySumOrderByAggregateInput = {
    id?: SortOrder
    warehouseId?: SortOrder
    itemId?: SortOrder
    count?: SortOrder
    price?: SortOrder
  }

  export type UnitsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plural?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plural?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    plural?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UnitsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsRelationFilter = {
    is?: TermsWhereInput
    isNot?: TermsWhereInput
  }

  export type CustomerInvoicesListRelationFilter = {
    every?: CustomerInvoicesWhereInput
    some?: CustomerInvoicesWhereInput
    none?: CustomerInvoicesWhereInput
  }

  export type CounterReceiptsListRelationFilter = {
    every?: CounterReceiptsWhereInput
    some?: CounterReceiptsWhereInput
    none?: CounterReceiptsWhereInput
  }

  export type CustomerInvoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CounterReceiptsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    termId?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    termId?: SortOrder
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type SuppliersListRelationFilter = {
    every?: SuppliersWhereInput
    some?: SuppliersWhereInput
    none?: SuppliersWhereInput
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuppliersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TermsCountOrderByAggregateInput = {
    id?: SortOrder
    days?: SortOrder
  }

  export type TermsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TermsMaxOrderByAggregateInput = {
    id?: SortOrder
    days?: SortOrder
  }

  export type TermsMinOrderByAggregateInput = {
    id?: SortOrder
    days?: SortOrder
  }

  export type TermsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type InventoryRelationFilter = {
    is?: InventoryWhereInput
    isNot?: InventoryWhereInput
  }

  export type SupplierInvoicesRelationFilter = {
    is?: SupplierInvoicesWhereInput
    isNot?: SupplierInvoicesWhereInput
  }

  export type SupplierTransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
  }

  export type SupplierTransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
  }

  export type SupplierTransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
  }

  export type SupplierTransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
  }

  export type SupplierTransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    inventoryId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CheckVouchersNullableRelationFilter = {
    is?: CheckVouchersWhereInput | null
    isNot?: CheckVouchersWhereInput | null
  }

  export type SupplierInvoicesCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    checkVouchersId?: SortOrder
  }

  export type SupplierInvoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    totalAmount?: SortOrder
    checkVouchersId?: SortOrder
  }

  export type SupplierInvoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    checkVouchersId?: SortOrder
  }

  export type SupplierInvoicesMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    checkVouchersId?: SortOrder
  }

  export type SupplierInvoicesSumOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    totalAmount?: SortOrder
    checkVouchersId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CustomerInvoicesRelationFilter = {
    is?: CustomerInvoicesWhereInput
    isNot?: CustomerInvoicesWhereInput
  }

  export type CustomerTransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
    isDiscounted?: SortOrder
  }

  export type CustomerTransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
  }

  export type CustomerTransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
    isDiscounted?: SortOrder
  }

  export type CustomerTransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
    isDiscounted?: SortOrder
  }

  export type CustomerTransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    itemId?: SortOrder
    customerPrice?: SortOrder
    storePrice?: SortOrder
    quantity?: SortOrder
    supplied?: SortOrder
  }

  export type CustomersRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type CounterReceiptsNullableRelationFilter = {
    is?: CounterReceiptsWhereInput | null
    isNot?: CounterReceiptsWhereInput | null
  }

  export type CustomerInvoicesCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    isCompleted?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    counterReceiptsId?: SortOrder
  }

  export type CustomerInvoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    totalAmount?: SortOrder
    counterReceiptsId?: SortOrder
  }

  export type CustomerInvoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    isCompleted?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    counterReceiptsId?: SortOrder
  }

  export type CustomerInvoicesMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    invoiceNumber?: SortOrder
    invoiceDate?: SortOrder
    isfulfilled?: SortOrder
    isCompleted?: SortOrder
    totalAmount?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
    counterReceiptsId?: SortOrder
  }

  export type CustomerInvoicesSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    totalAmount?: SortOrder
    counterReceiptsId?: SortOrder
  }

  export type WarehouseInvoicesRelationFilter = {
    is?: WarehouseInvoicesWhereInput
    isNot?: WarehouseInvoicesWhereInput
  }

  export type WarehouseTransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
  }

  export type WarehouseTransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
  }

  export type WarehouseTransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
  }

  export type WarehouseTransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
  }

  export type WarehouseTransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    inventoryId?: SortOrder
    invoiceId?: SortOrder
    count?: SortOrder
  }

  export type WarehousesNullableRelationFilter = {
    is?: WarehousesWhereInput | null
    isNot?: WarehousesWhereInput | null
  }

  export type WarehouseInvoicesCountOrderByAggregateInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrder
    isFullfilled?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
  }

  export type WarehouseInvoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrder
  }

  export type WarehouseInvoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrder
    isFullfilled?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
  }

  export type WarehouseInvoicesMinOrderByAggregateInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrder
    isFullfilled?: SortOrder
    dateCreated?: SortOrder
    dateUpdated?: SortOrder
  }

  export type WarehouseInvoicesSumOrderByAggregateInput = {
    id?: SortOrder
    targetWarehouseId?: SortOrder
    warehouseId?: SortOrder
  }

  export type CustomersNullableRelationFilter = {
    is?: CustomersWhereInput | null
    isNot?: CustomersWhereInput | null
  }

  export type CounterReceiptsCountOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    customerId?: SortOrder
  }

  export type CounterReceiptsAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    customerId?: SortOrder
  }

  export type CounterReceiptsMaxOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    customerId?: SortOrder
  }

  export type CounterReceiptsMinOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    customerId?: SortOrder
  }

  export type CounterReceiptsSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    customerId?: SortOrder
  }

  export type SuppliersNullableRelationFilter = {
    is?: SuppliersWhereInput | null
    isNot?: SuppliersWhereInput | null
  }

  export type CheckVouchersCountOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    bank?: SortOrder
    checkNumber?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    supplierId?: SortOrder
  }

  export type CheckVouchersAvgOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    supplierId?: SortOrder
  }

  export type CheckVouchersMaxOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    bank?: SortOrder
    checkNumber?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    supplierId?: SortOrder
  }

  export type CheckVouchersMinOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    bank?: SortOrder
    checkNumber?: SortOrder
    dueDate?: SortOrder
    dateCreated?: SortOrder
    supplierId?: SortOrder
  }

  export type CheckVouchersSumOrderByAggregateInput = {
    id?: SortOrder
    discount?: SortOrder
    totalAmount?: SortOrder
    supplierId?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type SuppliersCreateNestedOneWithoutItemsInput = {
    create?: XOR<SuppliersCreateWithoutItemsInput, SuppliersUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutItemsInput
    connect?: SuppliersWhereUniqueInput
  }

  export type BrandsCreateNestedOneWithoutItemsInput = {
    create?: XOR<BrandsCreateWithoutItemsInput, BrandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BrandsCreateOrConnectWithoutItemsInput
    connect?: BrandsWhereUniqueInput
  }

  export type UnitsCreateNestedOneWithoutItemInput = {
    create?: XOR<UnitsCreateWithoutItemInput, UnitsUncheckedCreateWithoutItemInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutItemInput
    connect?: UnitsWhereUniqueInput
  }

  export type InventoryCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type SupplierTransactionsCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput> | SupplierTransactionsCreateWithoutItemInput[] | SupplierTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutItemInput | SupplierTransactionsCreateOrConnectWithoutItemInput[]
    createMany?: SupplierTransactionsCreateManyItemInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type CustomerTransactionsCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput> | CustomerTransactionsCreateWithoutItemInput[] | CustomerTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutItemInput | CustomerTransactionsCreateOrConnectWithoutItemInput[]
    createMany?: CustomerTransactionsCreateManyItemInputEnvelope
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput> | SupplierTransactionsCreateWithoutItemInput[] | SupplierTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutItemInput | SupplierTransactionsCreateOrConnectWithoutItemInput[]
    createMany?: SupplierTransactionsCreateManyItemInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput> | CustomerTransactionsCreateWithoutItemInput[] | CustomerTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutItemInput | CustomerTransactionsCreateOrConnectWithoutItemInput[]
    createMany?: CustomerTransactionsCreateManyItemInputEnvelope
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SuppliersUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<SuppliersCreateWithoutItemsInput, SuppliersUncheckedCreateWithoutItemsInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutItemsInput
    upsert?: SuppliersUpsertWithoutItemsInput
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutItemsInput, SuppliersUpdateWithoutItemsInput>, SuppliersUncheckedUpdateWithoutItemsInput>
  }

  export type BrandsUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<BrandsCreateWithoutItemsInput, BrandsUncheckedCreateWithoutItemsInput>
    connectOrCreate?: BrandsCreateOrConnectWithoutItemsInput
    upsert?: BrandsUpsertWithoutItemsInput
    connect?: BrandsWhereUniqueInput
    update?: XOR<XOR<BrandsUpdateToOneWithWhereWithoutItemsInput, BrandsUpdateWithoutItemsInput>, BrandsUncheckedUpdateWithoutItemsInput>
  }

  export type UnitsUpdateOneRequiredWithoutItemNestedInput = {
    create?: XOR<UnitsCreateWithoutItemInput, UnitsUncheckedCreateWithoutItemInput>
    connectOrCreate?: UnitsCreateOrConnectWithoutItemInput
    upsert?: UnitsUpsertWithoutItemInput
    connect?: UnitsWhereUniqueInput
    update?: XOR<XOR<UnitsUpdateToOneWithWhereWithoutItemInput, UnitsUpdateWithoutItemInput>, UnitsUncheckedUpdateWithoutItemInput>
  }

  export type InventoryUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutItemInput | InventoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutItemInput | InventoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutItemInput | InventoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type SupplierTransactionsUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput> | SupplierTransactionsCreateWithoutItemInput[] | SupplierTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutItemInput | SupplierTransactionsCreateOrConnectWithoutItemInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutItemInput | SupplierTransactionsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierTransactionsCreateManyItemInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutItemInput | SupplierTransactionsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutItemInput | SupplierTransactionsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type CustomerTransactionsUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput> | CustomerTransactionsCreateWithoutItemInput[] | CustomerTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutItemInput | CustomerTransactionsCreateOrConnectWithoutItemInput[]
    upsert?: CustomerTransactionsUpsertWithWhereUniqueWithoutItemInput | CustomerTransactionsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerTransactionsCreateManyItemInputEnvelope
    set?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    disconnect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    delete?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    update?: CustomerTransactionsUpdateWithWhereUniqueWithoutItemInput | CustomerTransactionsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerTransactionsUpdateManyWithWhereWithoutItemInput | CustomerTransactionsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput> | InventoryCreateWithoutItemInput[] | InventoryUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutItemInput | InventoryCreateOrConnectWithoutItemInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutItemInput | InventoryUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryCreateManyItemInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutItemInput | InventoryUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutItemInput | InventoryUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput> | SupplierTransactionsCreateWithoutItemInput[] | SupplierTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutItemInput | SupplierTransactionsCreateOrConnectWithoutItemInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutItemInput | SupplierTransactionsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SupplierTransactionsCreateManyItemInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutItemInput | SupplierTransactionsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutItemInput | SupplierTransactionsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput> | CustomerTransactionsCreateWithoutItemInput[] | CustomerTransactionsUncheckedCreateWithoutItemInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutItemInput | CustomerTransactionsCreateOrConnectWithoutItemInput[]
    upsert?: CustomerTransactionsUpsertWithWhereUniqueWithoutItemInput | CustomerTransactionsUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: CustomerTransactionsCreateManyItemInputEnvelope
    set?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    disconnect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    delete?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    update?: CustomerTransactionsUpdateWithWhereUniqueWithoutItemInput | CustomerTransactionsUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: CustomerTransactionsUpdateManyWithWhereWithoutItemInput | CustomerTransactionsUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
  }

  export type ItemsCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput> | ItemsCreateWithoutSupplierInput[] | ItemsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierInput | ItemsCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemsCreateManySupplierInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type SupplierInvoicesCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput> | SupplierInvoicesCreateWithoutSupplierInput[] | SupplierInvoicesUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutSupplierInput | SupplierInvoicesCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierInvoicesCreateManySupplierInputEnvelope
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
  }

  export type CheckVouchersCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput> | CheckVouchersCreateWithoutSupplierInput[] | CheckVouchersUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInput | CheckVouchersCreateOrConnectWithoutSupplierInput[]
    createMany?: CheckVouchersCreateManySupplierInputEnvelope
    connect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
  }

  export type TermsCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<TermsCreateWithoutSuppliersInput, TermsUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TermsCreateOrConnectWithoutSuppliersInput
    connect?: TermsWhereUniqueInput
  }

  export type ItemsUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput> | ItemsCreateWithoutSupplierInput[] | ItemsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierInput | ItemsCreateOrConnectWithoutSupplierInput[]
    createMany?: ItemsCreateManySupplierInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type SupplierInvoicesUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput> | SupplierInvoicesCreateWithoutSupplierInput[] | SupplierInvoicesUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutSupplierInput | SupplierInvoicesCreateOrConnectWithoutSupplierInput[]
    createMany?: SupplierInvoicesCreateManySupplierInputEnvelope
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
  }

  export type CheckVouchersUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput> | CheckVouchersCreateWithoutSupplierInput[] | CheckVouchersUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInput | CheckVouchersCreateOrConnectWithoutSupplierInput[]
    createMany?: CheckVouchersCreateManySupplierInputEnvelope
    connect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
  }

  export type ItemsUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput> | ItemsCreateWithoutSupplierInput[] | ItemsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierInput | ItemsCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutSupplierInput | ItemsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemsCreateManySupplierInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutSupplierInput | ItemsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutSupplierInput | ItemsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type SupplierInvoicesUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput> | SupplierInvoicesCreateWithoutSupplierInput[] | SupplierInvoicesUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutSupplierInput | SupplierInvoicesCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierInvoicesUpsertWithWhereUniqueWithoutSupplierInput | SupplierInvoicesUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierInvoicesCreateManySupplierInputEnvelope
    set?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    disconnect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    delete?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    update?: SupplierInvoicesUpdateWithWhereUniqueWithoutSupplierInput | SupplierInvoicesUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierInvoicesUpdateManyWithWhereWithoutSupplierInput | SupplierInvoicesUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
  }

  export type CheckVouchersUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput> | CheckVouchersCreateWithoutSupplierInput[] | CheckVouchersUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInput | CheckVouchersCreateOrConnectWithoutSupplierInput[]
    upsert?: CheckVouchersUpsertWithWhereUniqueWithoutSupplierInput | CheckVouchersUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CheckVouchersCreateManySupplierInputEnvelope
    set?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    disconnect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    delete?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    connect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    update?: CheckVouchersUpdateWithWhereUniqueWithoutSupplierInput | CheckVouchersUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CheckVouchersUpdateManyWithWhereWithoutSupplierInput | CheckVouchersUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CheckVouchersScalarWhereInput | CheckVouchersScalarWhereInput[]
  }

  export type TermsUpdateOneWithoutSuppliersNestedInput = {
    create?: XOR<TermsCreateWithoutSuppliersInput, TermsUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TermsCreateOrConnectWithoutSuppliersInput
    upsert?: TermsUpsertWithoutSuppliersInput
    disconnect?: TermsWhereInput | boolean
    delete?: TermsWhereInput | boolean
    connect?: TermsWhereUniqueInput
    update?: XOR<XOR<TermsUpdateToOneWithWhereWithoutSuppliersInput, TermsUpdateWithoutSuppliersInput>, TermsUncheckedUpdateWithoutSuppliersInput>
  }

  export type ItemsUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput> | ItemsCreateWithoutSupplierInput[] | ItemsUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierInput | ItemsCreateOrConnectWithoutSupplierInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutSupplierInput | ItemsUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ItemsCreateManySupplierInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutSupplierInput | ItemsUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutSupplierInput | ItemsUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type SupplierInvoicesUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput> | SupplierInvoicesCreateWithoutSupplierInput[] | SupplierInvoicesUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutSupplierInput | SupplierInvoicesCreateOrConnectWithoutSupplierInput[]
    upsert?: SupplierInvoicesUpsertWithWhereUniqueWithoutSupplierInput | SupplierInvoicesUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: SupplierInvoicesCreateManySupplierInputEnvelope
    set?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    disconnect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    delete?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    update?: SupplierInvoicesUpdateWithWhereUniqueWithoutSupplierInput | SupplierInvoicesUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: SupplierInvoicesUpdateManyWithWhereWithoutSupplierInput | SupplierInvoicesUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
  }

  export type CheckVouchersUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput> | CheckVouchersCreateWithoutSupplierInput[] | CheckVouchersUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInput | CheckVouchersCreateOrConnectWithoutSupplierInput[]
    upsert?: CheckVouchersUpsertWithWhereUniqueWithoutSupplierInput | CheckVouchersUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CheckVouchersCreateManySupplierInputEnvelope
    set?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    disconnect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    delete?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    connect?: CheckVouchersWhereUniqueInput | CheckVouchersWhereUniqueInput[]
    update?: CheckVouchersUpdateWithWhereUniqueWithoutSupplierInput | CheckVouchersUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CheckVouchersUpdateManyWithWhereWithoutSupplierInput | CheckVouchersUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CheckVouchersScalarWhereInput | CheckVouchersScalarWhereInput[]
  }

  export type ItemsCreateNestedManyWithoutBrandInput = {
    create?: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput> | ItemsCreateWithoutBrandInput[] | ItemsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutBrandInput | ItemsCreateOrConnectWithoutBrandInput[]
    createMany?: ItemsCreateManyBrandInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput> | ItemsCreateWithoutBrandInput[] | ItemsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutBrandInput | ItemsCreateOrConnectWithoutBrandInput[]
    createMany?: ItemsCreateManyBrandInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput> | ItemsCreateWithoutBrandInput[] | ItemsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutBrandInput | ItemsCreateOrConnectWithoutBrandInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutBrandInput | ItemsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ItemsCreateManyBrandInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutBrandInput | ItemsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutBrandInput | ItemsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput> | ItemsCreateWithoutBrandInput[] | ItemsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutBrandInput | ItemsCreateOrConnectWithoutBrandInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutBrandInput | ItemsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ItemsCreateManyBrandInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutBrandInput | ItemsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutBrandInput | ItemsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type InventoryCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type WarehouseInvoicesCreateNestedManyWithoutWarehousesInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput> | WarehouseInvoicesCreateWithoutWarehousesInput[] | WarehouseInvoicesUncheckedCreateWithoutWarehousesInput[]
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehousesInput | WarehouseInvoicesCreateOrConnectWithoutWarehousesInput[]
    createMany?: WarehouseInvoicesCreateManyWarehousesInputEnvelope
    connect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
  }

  export type InventoryUncheckedCreateNestedManyWithoutWarehouseInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
  }

  export type WarehouseInvoicesUncheckedCreateNestedManyWithoutWarehousesInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput> | WarehouseInvoicesCreateWithoutWarehousesInput[] | WarehouseInvoicesUncheckedCreateWithoutWarehousesInput[]
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehousesInput | WarehouseInvoicesCreateOrConnectWithoutWarehousesInput[]
    createMany?: WarehouseInvoicesCreateManyWarehousesInputEnvelope
    connect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
  }

  export type InventoryUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutWarehouseInput | InventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutWarehouseInput | InventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutWarehouseInput | InventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type WarehouseInvoicesUpdateManyWithoutWarehousesNestedInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput> | WarehouseInvoicesCreateWithoutWarehousesInput[] | WarehouseInvoicesUncheckedCreateWithoutWarehousesInput[]
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehousesInput | WarehouseInvoicesCreateOrConnectWithoutWarehousesInput[]
    upsert?: WarehouseInvoicesUpsertWithWhereUniqueWithoutWarehousesInput | WarehouseInvoicesUpsertWithWhereUniqueWithoutWarehousesInput[]
    createMany?: WarehouseInvoicesCreateManyWarehousesInputEnvelope
    set?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    disconnect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    delete?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    connect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    update?: WarehouseInvoicesUpdateWithWhereUniqueWithoutWarehousesInput | WarehouseInvoicesUpdateWithWhereUniqueWithoutWarehousesInput[]
    updateMany?: WarehouseInvoicesUpdateManyWithWhereWithoutWarehousesInput | WarehouseInvoicesUpdateManyWithWhereWithoutWarehousesInput[]
    deleteMany?: WarehouseInvoicesScalarWhereInput | WarehouseInvoicesScalarWhereInput[]
  }

  export type InventoryUncheckedUpdateManyWithoutWarehouseNestedInput = {
    create?: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput> | InventoryCreateWithoutWarehouseInput[] | InventoryUncheckedCreateWithoutWarehouseInput[]
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseInput | InventoryCreateOrConnectWithoutWarehouseInput[]
    upsert?: InventoryUpsertWithWhereUniqueWithoutWarehouseInput | InventoryUpsertWithWhereUniqueWithoutWarehouseInput[]
    createMany?: InventoryCreateManyWarehouseInputEnvelope
    set?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    disconnect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    delete?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    connect?: InventoryWhereUniqueInput | InventoryWhereUniqueInput[]
    update?: InventoryUpdateWithWhereUniqueWithoutWarehouseInput | InventoryUpdateWithWhereUniqueWithoutWarehouseInput[]
    updateMany?: InventoryUpdateManyWithWhereWithoutWarehouseInput | InventoryUpdateManyWithWhereWithoutWarehouseInput[]
    deleteMany?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
  }

  export type WarehouseInvoicesUncheckedUpdateManyWithoutWarehousesNestedInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput> | WarehouseInvoicesCreateWithoutWarehousesInput[] | WarehouseInvoicesUncheckedCreateWithoutWarehousesInput[]
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehousesInput | WarehouseInvoicesCreateOrConnectWithoutWarehousesInput[]
    upsert?: WarehouseInvoicesUpsertWithWhereUniqueWithoutWarehousesInput | WarehouseInvoicesUpsertWithWhereUniqueWithoutWarehousesInput[]
    createMany?: WarehouseInvoicesCreateManyWarehousesInputEnvelope
    set?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    disconnect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    delete?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    connect?: WarehouseInvoicesWhereUniqueInput | WarehouseInvoicesWhereUniqueInput[]
    update?: WarehouseInvoicesUpdateWithWhereUniqueWithoutWarehousesInput | WarehouseInvoicesUpdateWithWhereUniqueWithoutWarehousesInput[]
    updateMany?: WarehouseInvoicesUpdateManyWithWhereWithoutWarehousesInput | WarehouseInvoicesUpdateManyWithWhereWithoutWarehousesInput[]
    deleteMany?: WarehouseInvoicesScalarWhereInput | WarehouseInvoicesScalarWhereInput[]
  }

  export type WarehousesCreateNestedOneWithoutInventoriesInput = {
    create?: XOR<WarehousesCreateWithoutInventoriesInput, WarehousesUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: WarehousesCreateOrConnectWithoutInventoriesInput
    connect?: WarehousesWhereUniqueInput
  }

  export type ItemsCreateNestedOneWithoutInventoriesInput = {
    create?: XOR<ItemsCreateWithoutInventoriesInput, ItemsUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutInventoriesInput
    connect?: ItemsWhereUniqueInput
  }

  export type SupplierTransactionsCreateNestedManyWithoutInventoryInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput> | SupplierTransactionsCreateWithoutInventoryInput[] | SupplierTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInventoryInput | SupplierTransactionsCreateOrConnectWithoutInventoryInput[]
    createMany?: SupplierTransactionsCreateManyInventoryInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type WarehouseTransactionsCreateNestedManyWithoutInventoryInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput> | WarehouseTransactionsCreateWithoutInventoryInput[] | WarehouseTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInventoryInput | WarehouseTransactionsCreateOrConnectWithoutInventoryInput[]
    createMany?: WarehouseTransactionsCreateManyInventoryInputEnvelope
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
  }

  export type SupplierTransactionsUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput> | SupplierTransactionsCreateWithoutInventoryInput[] | SupplierTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInventoryInput | SupplierTransactionsCreateOrConnectWithoutInventoryInput[]
    createMany?: SupplierTransactionsCreateManyInventoryInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type WarehouseTransactionsUncheckedCreateNestedManyWithoutInventoryInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput> | WarehouseTransactionsCreateWithoutInventoryInput[] | WarehouseTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInventoryInput | WarehouseTransactionsCreateOrConnectWithoutInventoryInput[]
    createMany?: WarehouseTransactionsCreateManyInventoryInputEnvelope
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
  }

  export type WarehousesUpdateOneRequiredWithoutInventoriesNestedInput = {
    create?: XOR<WarehousesCreateWithoutInventoriesInput, WarehousesUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: WarehousesCreateOrConnectWithoutInventoriesInput
    upsert?: WarehousesUpsertWithoutInventoriesInput
    connect?: WarehousesWhereUniqueInput
    update?: XOR<XOR<WarehousesUpdateToOneWithWhereWithoutInventoriesInput, WarehousesUpdateWithoutInventoriesInput>, WarehousesUncheckedUpdateWithoutInventoriesInput>
  }

  export type ItemsUpdateOneRequiredWithoutInventoriesNestedInput = {
    create?: XOR<ItemsCreateWithoutInventoriesInput, ItemsUncheckedCreateWithoutInventoriesInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutInventoriesInput
    upsert?: ItemsUpsertWithoutInventoriesInput
    connect?: ItemsWhereUniqueInput
    update?: XOR<XOR<ItemsUpdateToOneWithWhereWithoutInventoriesInput, ItemsUpdateWithoutInventoriesInput>, ItemsUncheckedUpdateWithoutInventoriesInput>
  }

  export type SupplierTransactionsUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput> | SupplierTransactionsCreateWithoutInventoryInput[] | SupplierTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInventoryInput | SupplierTransactionsCreateOrConnectWithoutInventoryInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutInventoryInput | SupplierTransactionsUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: SupplierTransactionsCreateManyInventoryInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutInventoryInput | SupplierTransactionsUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutInventoryInput | SupplierTransactionsUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type WarehouseTransactionsUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput> | WarehouseTransactionsCreateWithoutInventoryInput[] | WarehouseTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInventoryInput | WarehouseTransactionsCreateOrConnectWithoutInventoryInput[]
    upsert?: WarehouseTransactionsUpsertWithWhereUniqueWithoutInventoryInput | WarehouseTransactionsUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: WarehouseTransactionsCreateManyInventoryInputEnvelope
    set?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    disconnect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    delete?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    update?: WarehouseTransactionsUpdateWithWhereUniqueWithoutInventoryInput | WarehouseTransactionsUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: WarehouseTransactionsUpdateManyWithWhereWithoutInventoryInput | WarehouseTransactionsUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput> | SupplierTransactionsCreateWithoutInventoryInput[] | SupplierTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInventoryInput | SupplierTransactionsCreateOrConnectWithoutInventoryInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutInventoryInput | SupplierTransactionsUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: SupplierTransactionsCreateManyInventoryInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutInventoryInput | SupplierTransactionsUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutInventoryInput | SupplierTransactionsUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type WarehouseTransactionsUncheckedUpdateManyWithoutInventoryNestedInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput> | WarehouseTransactionsCreateWithoutInventoryInput[] | WarehouseTransactionsUncheckedCreateWithoutInventoryInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInventoryInput | WarehouseTransactionsCreateOrConnectWithoutInventoryInput[]
    upsert?: WarehouseTransactionsUpsertWithWhereUniqueWithoutInventoryInput | WarehouseTransactionsUpsertWithWhereUniqueWithoutInventoryInput[]
    createMany?: WarehouseTransactionsCreateManyInventoryInputEnvelope
    set?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    disconnect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    delete?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    update?: WarehouseTransactionsUpdateWithWhereUniqueWithoutInventoryInput | WarehouseTransactionsUpdateWithWhereUniqueWithoutInventoryInput[]
    updateMany?: WarehouseTransactionsUpdateManyWithWhereWithoutInventoryInput | WarehouseTransactionsUpdateManyWithWhereWithoutInventoryInput[]
    deleteMany?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
  }

  export type ItemsCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput> | ItemsCreateWithoutUnitInput[] | ItemsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutUnitInput | ItemsCreateOrConnectWithoutUnitInput[]
    createMany?: ItemsCreateManyUnitInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput> | ItemsCreateWithoutUnitInput[] | ItemsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutUnitInput | ItemsCreateOrConnectWithoutUnitInput[]
    createMany?: ItemsCreateManyUnitInputEnvelope
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
  }

  export type ItemsUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput> | ItemsCreateWithoutUnitInput[] | ItemsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutUnitInput | ItemsCreateOrConnectWithoutUnitInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutUnitInput | ItemsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemsCreateManyUnitInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutUnitInput | ItemsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutUnitInput | ItemsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type ItemsUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput> | ItemsCreateWithoutUnitInput[] | ItemsUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: ItemsCreateOrConnectWithoutUnitInput | ItemsCreateOrConnectWithoutUnitInput[]
    upsert?: ItemsUpsertWithWhereUniqueWithoutUnitInput | ItemsUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: ItemsCreateManyUnitInputEnvelope
    set?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    disconnect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    delete?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    connect?: ItemsWhereUniqueInput | ItemsWhereUniqueInput[]
    update?: ItemsUpdateWithWhereUniqueWithoutUnitInput | ItemsUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: ItemsUpdateManyWithWhereWithoutUnitInput | ItemsUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
  }

  export type TermsCreateNestedOneWithoutCustomersInput = {
    create?: XOR<TermsCreateWithoutCustomersInput, TermsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TermsCreateOrConnectWithoutCustomersInput
    connect?: TermsWhereUniqueInput
  }

  export type CustomerInvoicesCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput> | CustomerInvoicesCreateWithoutCustomerInput[] | CustomerInvoicesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustomerInput | CustomerInvoicesCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerInvoicesCreateManyCustomerInputEnvelope
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
  }

  export type CounterReceiptsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput> | CounterReceiptsCreateWithoutCustomersInput[] | CounterReceiptsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomersInput | CounterReceiptsCreateOrConnectWithoutCustomersInput[]
    createMany?: CounterReceiptsCreateManyCustomersInputEnvelope
    connect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
  }

  export type CustomerInvoicesUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput> | CustomerInvoicesCreateWithoutCustomerInput[] | CustomerInvoicesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustomerInput | CustomerInvoicesCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerInvoicesCreateManyCustomerInputEnvelope
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
  }

  export type CounterReceiptsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput> | CounterReceiptsCreateWithoutCustomersInput[] | CounterReceiptsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomersInput | CounterReceiptsCreateOrConnectWithoutCustomersInput[]
    createMany?: CounterReceiptsCreateManyCustomersInputEnvelope
    connect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
  }

  export type TermsUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<TermsCreateWithoutCustomersInput, TermsUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: TermsCreateOrConnectWithoutCustomersInput
    upsert?: TermsUpsertWithoutCustomersInput
    connect?: TermsWhereUniqueInput
    update?: XOR<XOR<TermsUpdateToOneWithWhereWithoutCustomersInput, TermsUpdateWithoutCustomersInput>, TermsUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerInvoicesUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput> | CustomerInvoicesCreateWithoutCustomerInput[] | CustomerInvoicesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustomerInput | CustomerInvoicesCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerInvoicesUpsertWithWhereUniqueWithoutCustomerInput | CustomerInvoicesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerInvoicesCreateManyCustomerInputEnvelope
    set?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    disconnect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    delete?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    update?: CustomerInvoicesUpdateWithWhereUniqueWithoutCustomerInput | CustomerInvoicesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerInvoicesUpdateManyWithWhereWithoutCustomerInput | CustomerInvoicesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
  }

  export type CounterReceiptsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput> | CounterReceiptsCreateWithoutCustomersInput[] | CounterReceiptsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomersInput | CounterReceiptsCreateOrConnectWithoutCustomersInput[]
    upsert?: CounterReceiptsUpsertWithWhereUniqueWithoutCustomersInput | CounterReceiptsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CounterReceiptsCreateManyCustomersInputEnvelope
    set?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    disconnect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    delete?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    connect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    update?: CounterReceiptsUpdateWithWhereUniqueWithoutCustomersInput | CounterReceiptsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CounterReceiptsUpdateManyWithWhereWithoutCustomersInput | CounterReceiptsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CounterReceiptsScalarWhereInput | CounterReceiptsScalarWhereInput[]
  }

  export type CustomerInvoicesUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput> | CustomerInvoicesCreateWithoutCustomerInput[] | CustomerInvoicesUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustomerInput | CustomerInvoicesCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerInvoicesUpsertWithWhereUniqueWithoutCustomerInput | CustomerInvoicesUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerInvoicesCreateManyCustomerInputEnvelope
    set?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    disconnect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    delete?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    update?: CustomerInvoicesUpdateWithWhereUniqueWithoutCustomerInput | CustomerInvoicesUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerInvoicesUpdateManyWithWhereWithoutCustomerInput | CustomerInvoicesUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
  }

  export type CounterReceiptsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput> | CounterReceiptsCreateWithoutCustomersInput[] | CounterReceiptsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomersInput | CounterReceiptsCreateOrConnectWithoutCustomersInput[]
    upsert?: CounterReceiptsUpsertWithWhereUniqueWithoutCustomersInput | CounterReceiptsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: CounterReceiptsCreateManyCustomersInputEnvelope
    set?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    disconnect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    delete?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    connect?: CounterReceiptsWhereUniqueInput | CounterReceiptsWhereUniqueInput[]
    update?: CounterReceiptsUpdateWithWhereUniqueWithoutCustomersInput | CounterReceiptsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: CounterReceiptsUpdateManyWithWhereWithoutCustomersInput | CounterReceiptsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: CounterReceiptsScalarWhereInput | CounterReceiptsScalarWhereInput[]
  }

  export type CustomersCreateNestedManyWithoutTermInput = {
    create?: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput> | CustomersCreateWithoutTermInput[] | CustomersUncheckedCreateWithoutTermInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutTermInput | CustomersCreateOrConnectWithoutTermInput[]
    createMany?: CustomersCreateManyTermInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type SuppliersCreateNestedManyWithoutTermsInput = {
    create?: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput> | SuppliersCreateWithoutTermsInput[] | SuppliersUncheckedCreateWithoutTermsInput[]
    connectOrCreate?: SuppliersCreateOrConnectWithoutTermsInput | SuppliersCreateOrConnectWithoutTermsInput[]
    createMany?: SuppliersCreateManyTermsInputEnvelope
    connect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutTermInput = {
    create?: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput> | CustomersCreateWithoutTermInput[] | CustomersUncheckedCreateWithoutTermInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutTermInput | CustomersCreateOrConnectWithoutTermInput[]
    createMany?: CustomersCreateManyTermInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type SuppliersUncheckedCreateNestedManyWithoutTermsInput = {
    create?: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput> | SuppliersCreateWithoutTermsInput[] | SuppliersUncheckedCreateWithoutTermsInput[]
    connectOrCreate?: SuppliersCreateOrConnectWithoutTermsInput | SuppliersCreateOrConnectWithoutTermsInput[]
    createMany?: SuppliersCreateManyTermsInputEnvelope
    connect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
  }

  export type CustomersUpdateManyWithoutTermNestedInput = {
    create?: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput> | CustomersCreateWithoutTermInput[] | CustomersUncheckedCreateWithoutTermInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutTermInput | CustomersCreateOrConnectWithoutTermInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutTermInput | CustomersUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: CustomersCreateManyTermInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutTermInput | CustomersUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutTermInput | CustomersUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type SuppliersUpdateManyWithoutTermsNestedInput = {
    create?: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput> | SuppliersCreateWithoutTermsInput[] | SuppliersUncheckedCreateWithoutTermsInput[]
    connectOrCreate?: SuppliersCreateOrConnectWithoutTermsInput | SuppliersCreateOrConnectWithoutTermsInput[]
    upsert?: SuppliersUpsertWithWhereUniqueWithoutTermsInput | SuppliersUpsertWithWhereUniqueWithoutTermsInput[]
    createMany?: SuppliersCreateManyTermsInputEnvelope
    set?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    disconnect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    delete?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    connect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    update?: SuppliersUpdateWithWhereUniqueWithoutTermsInput | SuppliersUpdateWithWhereUniqueWithoutTermsInput[]
    updateMany?: SuppliersUpdateManyWithWhereWithoutTermsInput | SuppliersUpdateManyWithWhereWithoutTermsInput[]
    deleteMany?: SuppliersScalarWhereInput | SuppliersScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutTermNestedInput = {
    create?: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput> | CustomersCreateWithoutTermInput[] | CustomersUncheckedCreateWithoutTermInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutTermInput | CustomersCreateOrConnectWithoutTermInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutTermInput | CustomersUpsertWithWhereUniqueWithoutTermInput[]
    createMany?: CustomersCreateManyTermInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutTermInput | CustomersUpdateWithWhereUniqueWithoutTermInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutTermInput | CustomersUpdateManyWithWhereWithoutTermInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type SuppliersUncheckedUpdateManyWithoutTermsNestedInput = {
    create?: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput> | SuppliersCreateWithoutTermsInput[] | SuppliersUncheckedCreateWithoutTermsInput[]
    connectOrCreate?: SuppliersCreateOrConnectWithoutTermsInput | SuppliersCreateOrConnectWithoutTermsInput[]
    upsert?: SuppliersUpsertWithWhereUniqueWithoutTermsInput | SuppliersUpsertWithWhereUniqueWithoutTermsInput[]
    createMany?: SuppliersCreateManyTermsInputEnvelope
    set?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    disconnect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    delete?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    connect?: SuppliersWhereUniqueInput | SuppliersWhereUniqueInput[]
    update?: SuppliersUpdateWithWhereUniqueWithoutTermsInput | SuppliersUpdateWithWhereUniqueWithoutTermsInput[]
    updateMany?: SuppliersUpdateManyWithWhereWithoutTermsInput | SuppliersUpdateManyWithWhereWithoutTermsInput[]
    deleteMany?: SuppliersScalarWhereInput | SuppliersScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutSupplierTransactionsInput = {
    create?: XOR<InventoryCreateWithoutSupplierTransactionsInput, InventoryUncheckedCreateWithoutSupplierTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierTransactionsInput
    connect?: InventoryWhereUniqueInput
  }

  export type ItemsCreateNestedOneWithoutSupplierTransactionsInput = {
    create?: XOR<ItemsCreateWithoutSupplierTransactionsInput, ItemsUncheckedCreateWithoutSupplierTransactionsInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierTransactionsInput
    connect?: ItemsWhereUniqueInput
  }

  export type SupplierInvoicesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<SupplierInvoicesCreateWithoutTransactionsInput, SupplierInvoicesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutTransactionsInput
    connect?: SupplierInvoicesWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutSupplierTransactionsNestedInput = {
    create?: XOR<InventoryCreateWithoutSupplierTransactionsInput, InventoryUncheckedCreateWithoutSupplierTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutSupplierTransactionsInput
    upsert?: InventoryUpsertWithoutSupplierTransactionsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutSupplierTransactionsInput, InventoryUpdateWithoutSupplierTransactionsInput>, InventoryUncheckedUpdateWithoutSupplierTransactionsInput>
  }

  export type ItemsUpdateOneRequiredWithoutSupplierTransactionsNestedInput = {
    create?: XOR<ItemsCreateWithoutSupplierTransactionsInput, ItemsUncheckedCreateWithoutSupplierTransactionsInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutSupplierTransactionsInput
    upsert?: ItemsUpsertWithoutSupplierTransactionsInput
    connect?: ItemsWhereUniqueInput
    update?: XOR<XOR<ItemsUpdateToOneWithWhereWithoutSupplierTransactionsInput, ItemsUpdateWithoutSupplierTransactionsInput>, ItemsUncheckedUpdateWithoutSupplierTransactionsInput>
  }

  export type SupplierInvoicesUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<SupplierInvoicesCreateWithoutTransactionsInput, SupplierInvoicesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutTransactionsInput
    upsert?: SupplierInvoicesUpsertWithoutTransactionsInput
    connect?: SupplierInvoicesWhereUniqueInput
    update?: XOR<XOR<SupplierInvoicesUpdateToOneWithWhereWithoutTransactionsInput, SupplierInvoicesUpdateWithoutTransactionsInput>, SupplierInvoicesUncheckedUpdateWithoutTransactionsInput>
  }

  export type SuppliersCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SuppliersCreateWithoutInvoicesInput, SuppliersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutInvoicesInput
    connect?: SuppliersWhereUniqueInput
  }

  export type SupplierTransactionsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput> | SupplierTransactionsCreateWithoutInvoiceInput[] | SupplierTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInvoiceInput | SupplierTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: SupplierTransactionsCreateManyInvoiceInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type CheckVouchersCreateNestedOneWithoutSupplierInvoicesInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInvoicesInput, CheckVouchersUncheckedCreateWithoutSupplierInvoicesInput>
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInvoicesInput
    connect?: CheckVouchersWhereUniqueInput
  }

  export type SupplierTransactionsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput> | SupplierTransactionsCreateWithoutInvoiceInput[] | SupplierTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInvoiceInput | SupplierTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: SupplierTransactionsCreateManyInvoiceInputEnvelope
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SuppliersUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SuppliersCreateWithoutInvoicesInput, SuppliersUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutInvoicesInput
    upsert?: SuppliersUpsertWithoutInvoicesInput
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutInvoicesInput, SuppliersUpdateWithoutInvoicesInput>, SuppliersUncheckedUpdateWithoutInvoicesInput>
  }

  export type SupplierTransactionsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput> | SupplierTransactionsCreateWithoutInvoiceInput[] | SupplierTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInvoiceInput | SupplierTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | SupplierTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SupplierTransactionsCreateManyInvoiceInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | SupplierTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutInvoiceInput | SupplierTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type CheckVouchersUpdateOneWithoutSupplierInvoicesNestedInput = {
    create?: XOR<CheckVouchersCreateWithoutSupplierInvoicesInput, CheckVouchersUncheckedCreateWithoutSupplierInvoicesInput>
    connectOrCreate?: CheckVouchersCreateOrConnectWithoutSupplierInvoicesInput
    upsert?: CheckVouchersUpsertWithoutSupplierInvoicesInput
    disconnect?: CheckVouchersWhereInput | boolean
    delete?: CheckVouchersWhereInput | boolean
    connect?: CheckVouchersWhereUniqueInput
    update?: XOR<XOR<CheckVouchersUpdateToOneWithWhereWithoutSupplierInvoicesInput, CheckVouchersUpdateWithoutSupplierInvoicesInput>, CheckVouchersUncheckedUpdateWithoutSupplierInvoicesInput>
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput> | SupplierTransactionsCreateWithoutInvoiceInput[] | SupplierTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: SupplierTransactionsCreateOrConnectWithoutInvoiceInput | SupplierTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: SupplierTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | SupplierTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: SupplierTransactionsCreateManyInvoiceInputEnvelope
    set?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    disconnect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    delete?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    connect?: SupplierTransactionsWhereUniqueInput | SupplierTransactionsWhereUniqueInput[]
    update?: SupplierTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | SupplierTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: SupplierTransactionsUpdateManyWithWhereWithoutInvoiceInput | SupplierTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
  }

  export type CustomerInvoicesCreateNestedOneWithoutCustmerTransactionsInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedCreateWithoutCustmerTransactionsInput>
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustmerTransactionsInput
    connect?: CustomerInvoicesWhereUniqueInput
  }

  export type ItemsCreateNestedOneWithoutCustmerTransactionsInput = {
    create?: XOR<ItemsCreateWithoutCustmerTransactionsInput, ItemsUncheckedCreateWithoutCustmerTransactionsInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutCustmerTransactionsInput
    connect?: ItemsWhereUniqueInput
  }

  export type CustomerInvoicesUpdateOneRequiredWithoutCustmerTransactionsNestedInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedCreateWithoutCustmerTransactionsInput>
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCustmerTransactionsInput
    upsert?: CustomerInvoicesUpsertWithoutCustmerTransactionsInput
    connect?: CustomerInvoicesWhereUniqueInput
    update?: XOR<XOR<CustomerInvoicesUpdateToOneWithWhereWithoutCustmerTransactionsInput, CustomerInvoicesUpdateWithoutCustmerTransactionsInput>, CustomerInvoicesUncheckedUpdateWithoutCustmerTransactionsInput>
  }

  export type ItemsUpdateOneRequiredWithoutCustmerTransactionsNestedInput = {
    create?: XOR<ItemsCreateWithoutCustmerTransactionsInput, ItemsUncheckedCreateWithoutCustmerTransactionsInput>
    connectOrCreate?: ItemsCreateOrConnectWithoutCustmerTransactionsInput
    upsert?: ItemsUpsertWithoutCustmerTransactionsInput
    connect?: ItemsWhereUniqueInput
    update?: XOR<XOR<ItemsUpdateToOneWithWhereWithoutCustmerTransactionsInput, ItemsUpdateWithoutCustmerTransactionsInput>, ItemsUncheckedUpdateWithoutCustmerTransactionsInput>
  }

  export type CustomersCreateNestedOneWithoutCustomerInvoicesInput = {
    create?: XOR<CustomersCreateWithoutCustomerInvoicesInput, CustomersUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerInvoicesInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerTransactionsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput> | CustomerTransactionsCreateWithoutInvoiceInput[] | CustomerTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutInvoiceInput | CustomerTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerTransactionsCreateManyInvoiceInputEnvelope
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
  }

  export type CounterReceiptsCreateNestedOneWithoutCustomerInvoicesInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomerInvoicesInput
    connect?: CounterReceiptsWhereUniqueInput
  }

  export type CustomerTransactionsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput> | CustomerTransactionsCreateWithoutInvoiceInput[] | CustomerTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutInvoiceInput | CustomerTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: CustomerTransactionsCreateManyInvoiceInputEnvelope
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
  }

  export type CustomersUpdateOneRequiredWithoutCustomerInvoicesNestedInput = {
    create?: XOR<CustomersCreateWithoutCustomerInvoicesInput, CustomersUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCustomerInvoicesInput
    upsert?: CustomersUpsertWithoutCustomerInvoicesInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutCustomerInvoicesInput, CustomersUpdateWithoutCustomerInvoicesInput>, CustomersUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type CustomerTransactionsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput> | CustomerTransactionsCreateWithoutInvoiceInput[] | CustomerTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutInvoiceInput | CustomerTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | CustomerTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerTransactionsCreateManyInvoiceInputEnvelope
    set?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    disconnect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    delete?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    update?: CustomerTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | CustomerTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerTransactionsUpdateManyWithWhereWithoutInvoiceInput | CustomerTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
  }

  export type CounterReceiptsUpdateOneWithoutCustomerInvoicesNestedInput = {
    create?: XOR<CounterReceiptsCreateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedCreateWithoutCustomerInvoicesInput>
    connectOrCreate?: CounterReceiptsCreateOrConnectWithoutCustomerInvoicesInput
    upsert?: CounterReceiptsUpsertWithoutCustomerInvoicesInput
    disconnect?: CounterReceiptsWhereInput | boolean
    delete?: CounterReceiptsWhereInput | boolean
    connect?: CounterReceiptsWhereUniqueInput
    update?: XOR<XOR<CounterReceiptsUpdateToOneWithWhereWithoutCustomerInvoicesInput, CounterReceiptsUpdateWithoutCustomerInvoicesInput>, CounterReceiptsUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type CustomerTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput> | CustomerTransactionsCreateWithoutInvoiceInput[] | CustomerTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: CustomerTransactionsCreateOrConnectWithoutInvoiceInput | CustomerTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: CustomerTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | CustomerTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: CustomerTransactionsCreateManyInvoiceInputEnvelope
    set?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    disconnect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    delete?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    connect?: CustomerTransactionsWhereUniqueInput | CustomerTransactionsWhereUniqueInput[]
    update?: CustomerTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | CustomerTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: CustomerTransactionsUpdateManyWithWhereWithoutInvoiceInput | CustomerTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
  }

  export type InventoryCreateNestedOneWithoutWarehouseTransactionsInput = {
    create?: XOR<InventoryCreateWithoutWarehouseTransactionsInput, InventoryUncheckedCreateWithoutWarehouseTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseTransactionsInput
    connect?: InventoryWhereUniqueInput
  }

  export type WarehouseInvoicesCreateNestedOneWithoutWarehouseTransactionsInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedCreateWithoutWarehouseTransactionsInput>
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehouseTransactionsInput
    connect?: WarehouseInvoicesWhereUniqueInput
  }

  export type InventoryUpdateOneRequiredWithoutWarehouseTransactionsNestedInput = {
    create?: XOR<InventoryCreateWithoutWarehouseTransactionsInput, InventoryUncheckedCreateWithoutWarehouseTransactionsInput>
    connectOrCreate?: InventoryCreateOrConnectWithoutWarehouseTransactionsInput
    upsert?: InventoryUpsertWithoutWarehouseTransactionsInput
    connect?: InventoryWhereUniqueInput
    update?: XOR<XOR<InventoryUpdateToOneWithWhereWithoutWarehouseTransactionsInput, InventoryUpdateWithoutWarehouseTransactionsInput>, InventoryUncheckedUpdateWithoutWarehouseTransactionsInput>
  }

  export type WarehouseInvoicesUpdateOneRequiredWithoutWarehouseTransactionsNestedInput = {
    create?: XOR<WarehouseInvoicesCreateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedCreateWithoutWarehouseTransactionsInput>
    connectOrCreate?: WarehouseInvoicesCreateOrConnectWithoutWarehouseTransactionsInput
    upsert?: WarehouseInvoicesUpsertWithoutWarehouseTransactionsInput
    connect?: WarehouseInvoicesWhereUniqueInput
    update?: XOR<XOR<WarehouseInvoicesUpdateToOneWithWhereWithoutWarehouseTransactionsInput, WarehouseInvoicesUpdateWithoutWarehouseTransactionsInput>, WarehouseInvoicesUncheckedUpdateWithoutWarehouseTransactionsInput>
  }

  export type WarehousesCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<WarehousesCreateWithoutInvoicesInput, WarehousesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: WarehousesCreateOrConnectWithoutInvoicesInput
    connect?: WarehousesWhereUniqueInput
  }

  export type WarehouseTransactionsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput> | WarehouseTransactionsCreateWithoutInvoiceInput[] | WarehouseTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInvoiceInput | WarehouseTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: WarehouseTransactionsCreateManyInvoiceInputEnvelope
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
  }

  export type WarehouseTransactionsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput> | WarehouseTransactionsCreateWithoutInvoiceInput[] | WarehouseTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInvoiceInput | WarehouseTransactionsCreateOrConnectWithoutInvoiceInput[]
    createMany?: WarehouseTransactionsCreateManyInvoiceInputEnvelope
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
  }

  export type WarehousesUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<WarehousesCreateWithoutInvoicesInput, WarehousesUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: WarehousesCreateOrConnectWithoutInvoicesInput
    upsert?: WarehousesUpsertWithoutInvoicesInput
    disconnect?: WarehousesWhereInput | boolean
    delete?: WarehousesWhereInput | boolean
    connect?: WarehousesWhereUniqueInput
    update?: XOR<XOR<WarehousesUpdateToOneWithWhereWithoutInvoicesInput, WarehousesUpdateWithoutInvoicesInput>, WarehousesUncheckedUpdateWithoutInvoicesInput>
  }

  export type WarehouseTransactionsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput> | WarehouseTransactionsCreateWithoutInvoiceInput[] | WarehouseTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInvoiceInput | WarehouseTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: WarehouseTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | WarehouseTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: WarehouseTransactionsCreateManyInvoiceInputEnvelope
    set?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    disconnect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    delete?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    update?: WarehouseTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | WarehouseTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: WarehouseTransactionsUpdateManyWithWhereWithoutInvoiceInput | WarehouseTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
  }

  export type WarehouseTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput> | WarehouseTransactionsCreateWithoutInvoiceInput[] | WarehouseTransactionsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: WarehouseTransactionsCreateOrConnectWithoutInvoiceInput | WarehouseTransactionsCreateOrConnectWithoutInvoiceInput[]
    upsert?: WarehouseTransactionsUpsertWithWhereUniqueWithoutInvoiceInput | WarehouseTransactionsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: WarehouseTransactionsCreateManyInvoiceInputEnvelope
    set?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    disconnect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    delete?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    connect?: WarehouseTransactionsWhereUniqueInput | WarehouseTransactionsWhereUniqueInput[]
    update?: WarehouseTransactionsUpdateWithWhereUniqueWithoutInvoiceInput | WarehouseTransactionsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: WarehouseTransactionsUpdateManyWithWhereWithoutInvoiceInput | WarehouseTransactionsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
  }

  export type CustomerInvoicesCreateNestedManyWithoutCounterReceiptsInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput> | CustomerInvoicesCreateWithoutCounterReceiptsInput[] | CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput | CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput[]
    createMany?: CustomerInvoicesCreateManyCounterReceiptsInputEnvelope
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
  }

  export type CustomersCreateNestedOneWithoutCounterReceitsInput = {
    create?: XOR<CustomersCreateWithoutCounterReceitsInput, CustomersUncheckedCreateWithoutCounterReceitsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCounterReceitsInput
    connect?: CustomersWhereUniqueInput
  }

  export type CustomerInvoicesUncheckedCreateNestedManyWithoutCounterReceiptsInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput> | CustomerInvoicesCreateWithoutCounterReceiptsInput[] | CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput | CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput[]
    createMany?: CustomerInvoicesCreateManyCounterReceiptsInputEnvelope
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
  }

  export type CustomerInvoicesUpdateManyWithoutCounterReceiptsNestedInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput> | CustomerInvoicesCreateWithoutCounterReceiptsInput[] | CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput | CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput[]
    upsert?: CustomerInvoicesUpsertWithWhereUniqueWithoutCounterReceiptsInput | CustomerInvoicesUpsertWithWhereUniqueWithoutCounterReceiptsInput[]
    createMany?: CustomerInvoicesCreateManyCounterReceiptsInputEnvelope
    set?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    disconnect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    delete?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    update?: CustomerInvoicesUpdateWithWhereUniqueWithoutCounterReceiptsInput | CustomerInvoicesUpdateWithWhereUniqueWithoutCounterReceiptsInput[]
    updateMany?: CustomerInvoicesUpdateManyWithWhereWithoutCounterReceiptsInput | CustomerInvoicesUpdateManyWithWhereWithoutCounterReceiptsInput[]
    deleteMany?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
  }

  export type CustomersUpdateOneWithoutCounterReceitsNestedInput = {
    create?: XOR<CustomersCreateWithoutCounterReceitsInput, CustomersUncheckedCreateWithoutCounterReceitsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutCounterReceitsInput
    upsert?: CustomersUpsertWithoutCounterReceitsInput
    disconnect?: CustomersWhereInput | boolean
    delete?: CustomersWhereInput | boolean
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutCounterReceitsInput, CustomersUpdateWithoutCounterReceitsInput>, CustomersUncheckedUpdateWithoutCounterReceitsInput>
  }

  export type CustomerInvoicesUncheckedUpdateManyWithoutCounterReceiptsNestedInput = {
    create?: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput> | CustomerInvoicesCreateWithoutCounterReceiptsInput[] | CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput[]
    connectOrCreate?: CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput | CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput[]
    upsert?: CustomerInvoicesUpsertWithWhereUniqueWithoutCounterReceiptsInput | CustomerInvoicesUpsertWithWhereUniqueWithoutCounterReceiptsInput[]
    createMany?: CustomerInvoicesCreateManyCounterReceiptsInputEnvelope
    set?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    disconnect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    delete?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    connect?: CustomerInvoicesWhereUniqueInput | CustomerInvoicesWhereUniqueInput[]
    update?: CustomerInvoicesUpdateWithWhereUniqueWithoutCounterReceiptsInput | CustomerInvoicesUpdateWithWhereUniqueWithoutCounterReceiptsInput[]
    updateMany?: CustomerInvoicesUpdateManyWithWhereWithoutCounterReceiptsInput | CustomerInvoicesUpdateManyWithWhereWithoutCounterReceiptsInput[]
    deleteMany?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
  }

  export type SupplierInvoicesCreateNestedManyWithoutCheckVouchersInput = {
    create?: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput> | SupplierInvoicesCreateWithoutCheckVouchersInput[] | SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput | SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput[]
    createMany?: SupplierInvoicesCreateManyCheckVouchersInputEnvelope
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
  }

  export type SuppliersCreateNestedOneWithoutCheckVouchersInput = {
    create?: XOR<SuppliersCreateWithoutCheckVouchersInput, SuppliersUncheckedCreateWithoutCheckVouchersInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutCheckVouchersInput
    connect?: SuppliersWhereUniqueInput
  }

  export type SupplierInvoicesUncheckedCreateNestedManyWithoutCheckVouchersInput = {
    create?: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput> | SupplierInvoicesCreateWithoutCheckVouchersInput[] | SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput | SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput[]
    createMany?: SupplierInvoicesCreateManyCheckVouchersInputEnvelope
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
  }

  export type SupplierInvoicesUpdateManyWithoutCheckVouchersNestedInput = {
    create?: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput> | SupplierInvoicesCreateWithoutCheckVouchersInput[] | SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput | SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput[]
    upsert?: SupplierInvoicesUpsertWithWhereUniqueWithoutCheckVouchersInput | SupplierInvoicesUpsertWithWhereUniqueWithoutCheckVouchersInput[]
    createMany?: SupplierInvoicesCreateManyCheckVouchersInputEnvelope
    set?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    disconnect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    delete?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    update?: SupplierInvoicesUpdateWithWhereUniqueWithoutCheckVouchersInput | SupplierInvoicesUpdateWithWhereUniqueWithoutCheckVouchersInput[]
    updateMany?: SupplierInvoicesUpdateManyWithWhereWithoutCheckVouchersInput | SupplierInvoicesUpdateManyWithWhereWithoutCheckVouchersInput[]
    deleteMany?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
  }

  export type SuppliersUpdateOneWithoutCheckVouchersNestedInput = {
    create?: XOR<SuppliersCreateWithoutCheckVouchersInput, SuppliersUncheckedCreateWithoutCheckVouchersInput>
    connectOrCreate?: SuppliersCreateOrConnectWithoutCheckVouchersInput
    upsert?: SuppliersUpsertWithoutCheckVouchersInput
    disconnect?: SuppliersWhereInput | boolean
    delete?: SuppliersWhereInput | boolean
    connect?: SuppliersWhereUniqueInput
    update?: XOR<XOR<SuppliersUpdateToOneWithWhereWithoutCheckVouchersInput, SuppliersUpdateWithoutCheckVouchersInput>, SuppliersUncheckedUpdateWithoutCheckVouchersInput>
  }

  export type SupplierInvoicesUncheckedUpdateManyWithoutCheckVouchersNestedInput = {
    create?: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput> | SupplierInvoicesCreateWithoutCheckVouchersInput[] | SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput[]
    connectOrCreate?: SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput | SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput[]
    upsert?: SupplierInvoicesUpsertWithWhereUniqueWithoutCheckVouchersInput | SupplierInvoicesUpsertWithWhereUniqueWithoutCheckVouchersInput[]
    createMany?: SupplierInvoicesCreateManyCheckVouchersInputEnvelope
    set?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    disconnect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    delete?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    connect?: SupplierInvoicesWhereUniqueInput | SupplierInvoicesWhereUniqueInput[]
    update?: SupplierInvoicesUpdateWithWhereUniqueWithoutCheckVouchersInput | SupplierInvoicesUpdateWithWhereUniqueWithoutCheckVouchersInput[]
    updateMany?: SupplierInvoicesUpdateManyWithWhereWithoutCheckVouchersInput | SupplierInvoicesUpdateManyWithWhereWithoutCheckVouchersInput[]
    deleteMany?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    hashedPassword?: string | null
    image?: string | null
    role?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hashedPassword?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type SuppliersCreateWithoutItemsInput = {
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Invoices?: SupplierInvoicesCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersCreateNestedManyWithoutSupplierInput
    Terms?: TermsCreateNestedOneWithoutSuppliersInput
  }

  export type SuppliersUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    address: string
    termId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    Invoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutItemsInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutItemsInput, SuppliersUncheckedCreateWithoutItemsInput>
  }

  export type BrandsCreateWithoutItemsInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandsCreateOrConnectWithoutItemsInput = {
    where: BrandsWhereUniqueInput
    create: XOR<BrandsCreateWithoutItemsInput, BrandsUncheckedCreateWithoutItemsInput>
  }

  export type UnitsCreateWithoutItemInput = {
    name: string
    plural: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitsUncheckedCreateWithoutItemInput = {
    id?: number
    name: string
    plural: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UnitsCreateOrConnectWithoutItemInput = {
    where: UnitsWhereUniqueInput
    create: XOR<UnitsCreateWithoutItemInput, UnitsUncheckedCreateWithoutItemInput>
  }

  export type InventoryCreateWithoutItemInput = {
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehousesCreateNestedOneWithoutInventoriesInput
    SupplierTransactions?: SupplierTransactionsCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutItemInput = {
    id?: number
    warehouseId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutItemInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput>
  }

  export type InventoryCreateManyItemInputEnvelope = {
    data: InventoryCreateManyItemInput | InventoryCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SupplierTransactionsCreateWithoutItemInput = {
    quantity: number
    inventory: InventoryCreateNestedOneWithoutSupplierTransactionsInput
    invoice: SupplierInvoicesCreateNestedOneWithoutTransactionsInput
  }

  export type SupplierTransactionsUncheckedCreateWithoutItemInput = {
    id?: number
    invoiceId: number
    quantity: number
    inventoryId: number
  }

  export type SupplierTransactionsCreateOrConnectWithoutItemInput = {
    where: SupplierTransactionsWhereUniqueInput
    create: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput>
  }

  export type SupplierTransactionsCreateManyItemInputEnvelope = {
    data: SupplierTransactionsCreateManyItemInput | SupplierTransactionsCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type CustomerTransactionsCreateWithoutItemInput = {
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
    invoice: CustomerInvoicesCreateNestedOneWithoutCustmerTransactionsInput
  }

  export type CustomerTransactionsUncheckedCreateWithoutItemInput = {
    id?: number
    invoiceId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type CustomerTransactionsCreateOrConnectWithoutItemInput = {
    where: CustomerTransactionsWhereUniqueInput
    create: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput>
  }

  export type CustomerTransactionsCreateManyItemInputEnvelope = {
    data: CustomerTransactionsCreateManyItemInput | CustomerTransactionsCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type SuppliersUpsertWithoutItemsInput = {
    update: XOR<SuppliersUpdateWithoutItemsInput, SuppliersUncheckedUpdateWithoutItemsInput>
    create: XOR<SuppliersCreateWithoutItemsInput, SuppliersUncheckedCreateWithoutItemsInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutItemsInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutItemsInput, SuppliersUncheckedUpdateWithoutItemsInput>
  }

  export type SuppliersUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Invoices?: SupplierInvoicesUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUpdateManyWithoutSupplierNestedInput
    Terms?: TermsUpdateOneWithoutSuppliersNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Invoices?: SupplierInvoicesUncheckedUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type BrandsUpsertWithoutItemsInput = {
    update: XOR<BrandsUpdateWithoutItemsInput, BrandsUncheckedUpdateWithoutItemsInput>
    create: XOR<BrandsCreateWithoutItemsInput, BrandsUncheckedCreateWithoutItemsInput>
    where?: BrandsWhereInput
  }

  export type BrandsUpdateToOneWithWhereWithoutItemsInput = {
    where?: BrandsWhereInput
    data: XOR<BrandsUpdateWithoutItemsInput, BrandsUncheckedUpdateWithoutItemsInput>
  }

  export type BrandsUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandsUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsUpsertWithoutItemInput = {
    update: XOR<UnitsUpdateWithoutItemInput, UnitsUncheckedUpdateWithoutItemInput>
    create: XOR<UnitsCreateWithoutItemInput, UnitsUncheckedCreateWithoutItemInput>
    where?: UnitsWhereInput
  }

  export type UnitsUpdateToOneWithWhereWithoutItemInput = {
    where?: UnitsWhereInput
    data: XOR<UnitsUpdateWithoutItemInput, UnitsUncheckedUpdateWithoutItemInput>
  }

  export type UnitsUpdateWithoutItemInput = {
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UnitsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    plural?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutItemInput, InventoryUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryCreateWithoutItemInput, InventoryUncheckedCreateWithoutItemInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutItemInput, InventoryUncheckedUpdateWithoutItemInput>
  }

  export type InventoryUpdateManyWithWhereWithoutItemInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryScalarWhereInput = {
    AND?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    OR?: InventoryScalarWhereInput[]
    NOT?: InventoryScalarWhereInput | InventoryScalarWhereInput[]
    id?: IntFilter<"Inventory"> | number
    warehouseId?: IntFilter<"Inventory"> | number
    itemId?: IntFilter<"Inventory"> | number
    count?: IntFilter<"Inventory"> | number
    price?: FloatFilter<"Inventory"> | number
    createdAt?: DateTimeFilter<"Inventory"> | Date | string
    updatedAt?: DateTimeFilter<"Inventory"> | Date | string
  }

  export type SupplierTransactionsUpsertWithWhereUniqueWithoutItemInput = {
    where: SupplierTransactionsWhereUniqueInput
    update: XOR<SupplierTransactionsUpdateWithoutItemInput, SupplierTransactionsUncheckedUpdateWithoutItemInput>
    create: XOR<SupplierTransactionsCreateWithoutItemInput, SupplierTransactionsUncheckedCreateWithoutItemInput>
  }

  export type SupplierTransactionsUpdateWithWhereUniqueWithoutItemInput = {
    where: SupplierTransactionsWhereUniqueInput
    data: XOR<SupplierTransactionsUpdateWithoutItemInput, SupplierTransactionsUncheckedUpdateWithoutItemInput>
  }

  export type SupplierTransactionsUpdateManyWithWhereWithoutItemInput = {
    where: SupplierTransactionsScalarWhereInput
    data: XOR<SupplierTransactionsUpdateManyMutationInput, SupplierTransactionsUncheckedUpdateManyWithoutItemInput>
  }

  export type SupplierTransactionsScalarWhereInput = {
    AND?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
    OR?: SupplierTransactionsScalarWhereInput[]
    NOT?: SupplierTransactionsScalarWhereInput | SupplierTransactionsScalarWhereInput[]
    id?: IntFilter<"SupplierTransactions"> | number
    invoiceId?: IntFilter<"SupplierTransactions"> | number
    itemId?: IntFilter<"SupplierTransactions"> | number
    quantity?: IntFilter<"SupplierTransactions"> | number
    inventoryId?: IntFilter<"SupplierTransactions"> | number
  }

  export type CustomerTransactionsUpsertWithWhereUniqueWithoutItemInput = {
    where: CustomerTransactionsWhereUniqueInput
    update: XOR<CustomerTransactionsUpdateWithoutItemInput, CustomerTransactionsUncheckedUpdateWithoutItemInput>
    create: XOR<CustomerTransactionsCreateWithoutItemInput, CustomerTransactionsUncheckedCreateWithoutItemInput>
  }

  export type CustomerTransactionsUpdateWithWhereUniqueWithoutItemInput = {
    where: CustomerTransactionsWhereUniqueInput
    data: XOR<CustomerTransactionsUpdateWithoutItemInput, CustomerTransactionsUncheckedUpdateWithoutItemInput>
  }

  export type CustomerTransactionsUpdateManyWithWhereWithoutItemInput = {
    where: CustomerTransactionsScalarWhereInput
    data: XOR<CustomerTransactionsUpdateManyMutationInput, CustomerTransactionsUncheckedUpdateManyWithoutItemInput>
  }

  export type CustomerTransactionsScalarWhereInput = {
    AND?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
    OR?: CustomerTransactionsScalarWhereInput[]
    NOT?: CustomerTransactionsScalarWhereInput | CustomerTransactionsScalarWhereInput[]
    id?: IntFilter<"CustomerTransactions"> | number
    invoiceId?: IntFilter<"CustomerTransactions"> | number
    itemId?: IntFilter<"CustomerTransactions"> | number
    customerPrice?: FloatFilter<"CustomerTransactions"> | number
    storePrice?: FloatFilter<"CustomerTransactions"> | number
    quantity?: IntFilter<"CustomerTransactions"> | number
    supplied?: IntFilter<"CustomerTransactions"> | number
    isDiscounted?: BoolFilter<"CustomerTransactions"> | boolean
  }

  export type ItemsCreateWithoutSupplierInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandsCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutSupplierInput = {
    id?: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutSupplierInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput>
  }

  export type ItemsCreateManySupplierInputEnvelope = {
    data: ItemsCreateManySupplierInput | ItemsCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SupplierInvoicesCreateWithoutSupplierInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    Transactions?: SupplierTransactionsCreateNestedManyWithoutInvoiceInput
    CheckVouchers?: CheckVouchersCreateNestedOneWithoutSupplierInvoicesInput
  }

  export type SupplierInvoicesUncheckedCreateWithoutSupplierInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    checkVouchersId?: number | null
    Transactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SupplierInvoicesCreateOrConnectWithoutSupplierInput = {
    where: SupplierInvoicesWhereUniqueInput
    create: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierInvoicesCreateManySupplierInputEnvelope = {
    data: SupplierInvoicesCreateManySupplierInput | SupplierInvoicesCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type CheckVouchersCreateWithoutSupplierInput = {
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    SupplierInvoices?: SupplierInvoicesCreateNestedManyWithoutCheckVouchersInput
  }

  export type CheckVouchersUncheckedCreateWithoutSupplierInput = {
    id?: number
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    SupplierInvoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutCheckVouchersInput
  }

  export type CheckVouchersCreateOrConnectWithoutSupplierInput = {
    where: CheckVouchersWhereUniqueInput
    create: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput>
  }

  export type CheckVouchersCreateManySupplierInputEnvelope = {
    data: CheckVouchersCreateManySupplierInput | CheckVouchersCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type TermsCreateWithoutSuppliersInput = {
    days: string
    Customers?: CustomersCreateNestedManyWithoutTermInput
  }

  export type TermsUncheckedCreateWithoutSuppliersInput = {
    id?: number
    days: string
    Customers?: CustomersUncheckedCreateNestedManyWithoutTermInput
  }

  export type TermsCreateOrConnectWithoutSuppliersInput = {
    where: TermsWhereUniqueInput
    create: XOR<TermsCreateWithoutSuppliersInput, TermsUncheckedCreateWithoutSuppliersInput>
  }

  export type ItemsUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutSupplierInput, ItemsUncheckedUpdateWithoutSupplierInput>
    create: XOR<ItemsCreateWithoutSupplierInput, ItemsUncheckedCreateWithoutSupplierInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutSupplierInput, ItemsUncheckedUpdateWithoutSupplierInput>
  }

  export type ItemsUpdateManyWithWhereWithoutSupplierInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutSupplierInput>
  }

  export type ItemsScalarWhereInput = {
    AND?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
    OR?: ItemsScalarWhereInput[]
    NOT?: ItemsScalarWhereInput | ItemsScalarWhereInput[]
    id?: IntFilter<"Items"> | number
    supplierId?: IntFilter<"Items"> | number
    brandId?: IntFilter<"Items"> | number
    unitId?: IntFilter<"Items"> | number
    desc1?: StringFilter<"Items"> | string
    desc2?: StringFilter<"Items"> | string
    desc3?: StringFilter<"Items"> | string
    discount1?: FloatFilter<"Items"> | number
    discount2?: FloatFilter<"Items"> | number
    discount3?: FloatFilter<"Items"> | number
    discount4?: FloatFilter<"Items"> | number
    store?: FloatFilter<"Items"> | number
    cal1?: FloatFilter<"Items"> | number
    cal2?: FloatFilter<"Items"> | number
    cal3?: FloatFilter<"Items"> | number
    ws1?: FloatFilter<"Items"> | number
    ws2?: FloatFilter<"Items"> | number
    ws3?: FloatFilter<"Items"> | number
    createdAt?: DateTimeFilter<"Items"> | Date | string
    updatedAt?: DateTimeFilter<"Items"> | Date | string
  }

  export type SupplierInvoicesUpsertWithWhereUniqueWithoutSupplierInput = {
    where: SupplierInvoicesWhereUniqueInput
    update: XOR<SupplierInvoicesUpdateWithoutSupplierInput, SupplierInvoicesUncheckedUpdateWithoutSupplierInput>
    create: XOR<SupplierInvoicesCreateWithoutSupplierInput, SupplierInvoicesUncheckedCreateWithoutSupplierInput>
  }

  export type SupplierInvoicesUpdateWithWhereUniqueWithoutSupplierInput = {
    where: SupplierInvoicesWhereUniqueInput
    data: XOR<SupplierInvoicesUpdateWithoutSupplierInput, SupplierInvoicesUncheckedUpdateWithoutSupplierInput>
  }

  export type SupplierInvoicesUpdateManyWithWhereWithoutSupplierInput = {
    where: SupplierInvoicesScalarWhereInput
    data: XOR<SupplierInvoicesUpdateManyMutationInput, SupplierInvoicesUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SupplierInvoicesScalarWhereInput = {
    AND?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
    OR?: SupplierInvoicesScalarWhereInput[]
    NOT?: SupplierInvoicesScalarWhereInput | SupplierInvoicesScalarWhereInput[]
    id?: IntFilter<"SupplierInvoices"> | number
    supplierId?: IntFilter<"SupplierInvoices"> | number
    invoiceNumber?: StringFilter<"SupplierInvoices"> | string
    invoiceDate?: DateTimeFilter<"SupplierInvoices"> | Date | string
    isfulfilled?: BoolFilter<"SupplierInvoices"> | boolean
    totalAmount?: FloatFilter<"SupplierInvoices"> | number
    dateCreated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"SupplierInvoices"> | Date | string
    checkVouchersId?: IntNullableFilter<"SupplierInvoices"> | number | null
  }

  export type CheckVouchersUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CheckVouchersWhereUniqueInput
    update: XOR<CheckVouchersUpdateWithoutSupplierInput, CheckVouchersUncheckedUpdateWithoutSupplierInput>
    create: XOR<CheckVouchersCreateWithoutSupplierInput, CheckVouchersUncheckedCreateWithoutSupplierInput>
  }

  export type CheckVouchersUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CheckVouchersWhereUniqueInput
    data: XOR<CheckVouchersUpdateWithoutSupplierInput, CheckVouchersUncheckedUpdateWithoutSupplierInput>
  }

  export type CheckVouchersUpdateManyWithWhereWithoutSupplierInput = {
    where: CheckVouchersScalarWhereInput
    data: XOR<CheckVouchersUpdateManyMutationInput, CheckVouchersUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CheckVouchersScalarWhereInput = {
    AND?: CheckVouchersScalarWhereInput | CheckVouchersScalarWhereInput[]
    OR?: CheckVouchersScalarWhereInput[]
    NOT?: CheckVouchersScalarWhereInput | CheckVouchersScalarWhereInput[]
    id?: IntFilter<"CheckVouchers"> | number
    discount?: FloatFilter<"CheckVouchers"> | number
    totalAmount?: FloatFilter<"CheckVouchers"> | number
    bank?: StringFilter<"CheckVouchers"> | string
    checkNumber?: StringFilter<"CheckVouchers"> | string
    dueDate?: DateTimeFilter<"CheckVouchers"> | Date | string
    dateCreated?: DateTimeFilter<"CheckVouchers"> | Date | string
    supplierId?: IntNullableFilter<"CheckVouchers"> | number | null
  }

  export type TermsUpsertWithoutSuppliersInput = {
    update: XOR<TermsUpdateWithoutSuppliersInput, TermsUncheckedUpdateWithoutSuppliersInput>
    create: XOR<TermsCreateWithoutSuppliersInput, TermsUncheckedCreateWithoutSuppliersInput>
    where?: TermsWhereInput
  }

  export type TermsUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: TermsWhereInput
    data: XOR<TermsUpdateWithoutSuppliersInput, TermsUncheckedUpdateWithoutSuppliersInput>
  }

  export type TermsUpdateWithoutSuppliersInput = {
    days?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUpdateManyWithoutTermNestedInput
  }

  export type TermsUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    days?: StringFieldUpdateOperationsInput | string
    Customers?: CustomersUncheckedUpdateManyWithoutTermNestedInput
  }

  export type ItemsCreateWithoutBrandInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutBrandInput = {
    id?: number
    supplierId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutBrandInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput>
  }

  export type ItemsCreateManyBrandInputEnvelope = {
    data: ItemsCreateManyBrandInput | ItemsCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type ItemsUpsertWithWhereUniqueWithoutBrandInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutBrandInput, ItemsUncheckedUpdateWithoutBrandInput>
    create: XOR<ItemsCreateWithoutBrandInput, ItemsUncheckedCreateWithoutBrandInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutBrandInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutBrandInput, ItemsUncheckedUpdateWithoutBrandInput>
  }

  export type ItemsUpdateManyWithWhereWithoutBrandInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutBrandInput>
  }

  export type InventoryCreateWithoutWarehouseInput = {
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    item: ItemsCreateNestedOneWithoutInventoriesInput
    SupplierTransactions?: SupplierTransactionsCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutWarehouseInput = {
    id?: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInventoryInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryCreateManyWarehouseInputEnvelope = {
    data: InventoryCreateManyWarehouseInput | InventoryCreateManyWarehouseInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseInvoicesCreateWithoutWarehousesInput = {
    targetWarehouseId: number
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type WarehouseInvoicesUncheckedCreateWithoutWarehousesInput = {
    id?: number
    targetWarehouseId: number
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type WarehouseInvoicesCreateOrConnectWithoutWarehousesInput = {
    where: WarehouseInvoicesWhereUniqueInput
    create: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput>
  }

  export type WarehouseInvoicesCreateManyWarehousesInputEnvelope = {
    data: WarehouseInvoicesCreateManyWarehousesInput | WarehouseInvoicesCreateManyWarehousesInput[]
    skipDuplicates?: boolean
  }

  export type InventoryUpsertWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    update: XOR<InventoryUpdateWithoutWarehouseInput, InventoryUncheckedUpdateWithoutWarehouseInput>
    create: XOR<InventoryCreateWithoutWarehouseInput, InventoryUncheckedCreateWithoutWarehouseInput>
  }

  export type InventoryUpdateWithWhereUniqueWithoutWarehouseInput = {
    where: InventoryWhereUniqueInput
    data: XOR<InventoryUpdateWithoutWarehouseInput, InventoryUncheckedUpdateWithoutWarehouseInput>
  }

  export type InventoryUpdateManyWithWhereWithoutWarehouseInput = {
    where: InventoryScalarWhereInput
    data: XOR<InventoryUpdateManyMutationInput, InventoryUncheckedUpdateManyWithoutWarehouseInput>
  }

  export type WarehouseInvoicesUpsertWithWhereUniqueWithoutWarehousesInput = {
    where: WarehouseInvoicesWhereUniqueInput
    update: XOR<WarehouseInvoicesUpdateWithoutWarehousesInput, WarehouseInvoicesUncheckedUpdateWithoutWarehousesInput>
    create: XOR<WarehouseInvoicesCreateWithoutWarehousesInput, WarehouseInvoicesUncheckedCreateWithoutWarehousesInput>
  }

  export type WarehouseInvoicesUpdateWithWhereUniqueWithoutWarehousesInput = {
    where: WarehouseInvoicesWhereUniqueInput
    data: XOR<WarehouseInvoicesUpdateWithoutWarehousesInput, WarehouseInvoicesUncheckedUpdateWithoutWarehousesInput>
  }

  export type WarehouseInvoicesUpdateManyWithWhereWithoutWarehousesInput = {
    where: WarehouseInvoicesScalarWhereInput
    data: XOR<WarehouseInvoicesUpdateManyMutationInput, WarehouseInvoicesUncheckedUpdateManyWithoutWarehousesInput>
  }

  export type WarehouseInvoicesScalarWhereInput = {
    AND?: WarehouseInvoicesScalarWhereInput | WarehouseInvoicesScalarWhereInput[]
    OR?: WarehouseInvoicesScalarWhereInput[]
    NOT?: WarehouseInvoicesScalarWhereInput | WarehouseInvoicesScalarWhereInput[]
    id?: IntFilter<"WarehouseInvoices"> | number
    targetWarehouseId?: IntFilter<"WarehouseInvoices"> | number
    warehouseId?: IntNullableFilter<"WarehouseInvoices"> | number | null
    isFullfilled?: BoolFilter<"WarehouseInvoices"> | boolean
    dateCreated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"WarehouseInvoices"> | Date | string
  }

  export type WarehousesCreateWithoutInventoriesInput = {
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Invoices?: WarehouseInvoicesCreateNestedManyWithoutWarehousesInput
  }

  export type WarehousesUncheckedCreateWithoutInventoriesInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Invoices?: WarehouseInvoicesUncheckedCreateNestedManyWithoutWarehousesInput
  }

  export type WarehousesCreateOrConnectWithoutInventoriesInput = {
    where: WarehousesWhereUniqueInput
    create: XOR<WarehousesCreateWithoutInventoriesInput, WarehousesUncheckedCreateWithoutInventoriesInput>
  }

  export type ItemsCreateWithoutInventoriesInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    brand: BrandsCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutInventoriesInput = {
    id?: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutInventoriesInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutInventoriesInput, ItemsUncheckedCreateWithoutInventoriesInput>
  }

  export type SupplierTransactionsCreateWithoutInventoryInput = {
    quantity: number
    item: ItemsCreateNestedOneWithoutSupplierTransactionsInput
    invoice: SupplierInvoicesCreateNestedOneWithoutTransactionsInput
  }

  export type SupplierTransactionsUncheckedCreateWithoutInventoryInput = {
    id?: number
    invoiceId: number
    itemId: number
    quantity: number
  }

  export type SupplierTransactionsCreateOrConnectWithoutInventoryInput = {
    where: SupplierTransactionsWhereUniqueInput
    create: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput>
  }

  export type SupplierTransactionsCreateManyInventoryInputEnvelope = {
    data: SupplierTransactionsCreateManyInventoryInput | SupplierTransactionsCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type WarehouseTransactionsCreateWithoutInventoryInput = {
    count: number
    Invoice: WarehouseInvoicesCreateNestedOneWithoutWarehouseTransactionsInput
  }

  export type WarehouseTransactionsUncheckedCreateWithoutInventoryInput = {
    id?: number
    invoiceId: number
    count: number
  }

  export type WarehouseTransactionsCreateOrConnectWithoutInventoryInput = {
    where: WarehouseTransactionsWhereUniqueInput
    create: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput>
  }

  export type WarehouseTransactionsCreateManyInventoryInputEnvelope = {
    data: WarehouseTransactionsCreateManyInventoryInput | WarehouseTransactionsCreateManyInventoryInput[]
    skipDuplicates?: boolean
  }

  export type WarehousesUpsertWithoutInventoriesInput = {
    update: XOR<WarehousesUpdateWithoutInventoriesInput, WarehousesUncheckedUpdateWithoutInventoriesInput>
    create: XOR<WarehousesCreateWithoutInventoriesInput, WarehousesUncheckedCreateWithoutInventoriesInput>
    where?: WarehousesWhereInput
  }

  export type WarehousesUpdateToOneWithWhereWithoutInventoriesInput = {
    where?: WarehousesWhereInput
    data: XOR<WarehousesUpdateWithoutInventoriesInput, WarehousesUncheckedUpdateWithoutInventoriesInput>
  }

  export type WarehousesUpdateWithoutInventoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Invoices?: WarehouseInvoicesUpdateManyWithoutWarehousesNestedInput
  }

  export type WarehousesUncheckedUpdateWithoutInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Invoices?: WarehouseInvoicesUncheckedUpdateManyWithoutWarehousesNestedInput
  }

  export type ItemsUpsertWithoutInventoriesInput = {
    update: XOR<ItemsUpdateWithoutInventoriesInput, ItemsUncheckedUpdateWithoutInventoriesInput>
    create: XOR<ItemsCreateWithoutInventoriesInput, ItemsUncheckedCreateWithoutInventoriesInput>
    where?: ItemsWhereInput
  }

  export type ItemsUpdateToOneWithWhereWithoutInventoriesInput = {
    where?: ItemsWhereInput
    data: XOR<ItemsUpdateWithoutInventoriesInput, ItemsUncheckedUpdateWithoutInventoriesInput>
  }

  export type ItemsUpdateWithoutInventoriesInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutInventoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierTransactionsUpsertWithWhereUniqueWithoutInventoryInput = {
    where: SupplierTransactionsWhereUniqueInput
    update: XOR<SupplierTransactionsUpdateWithoutInventoryInput, SupplierTransactionsUncheckedUpdateWithoutInventoryInput>
    create: XOR<SupplierTransactionsCreateWithoutInventoryInput, SupplierTransactionsUncheckedCreateWithoutInventoryInput>
  }

  export type SupplierTransactionsUpdateWithWhereUniqueWithoutInventoryInput = {
    where: SupplierTransactionsWhereUniqueInput
    data: XOR<SupplierTransactionsUpdateWithoutInventoryInput, SupplierTransactionsUncheckedUpdateWithoutInventoryInput>
  }

  export type SupplierTransactionsUpdateManyWithWhereWithoutInventoryInput = {
    where: SupplierTransactionsScalarWhereInput
    data: XOR<SupplierTransactionsUpdateManyMutationInput, SupplierTransactionsUncheckedUpdateManyWithoutInventoryInput>
  }

  export type WarehouseTransactionsUpsertWithWhereUniqueWithoutInventoryInput = {
    where: WarehouseTransactionsWhereUniqueInput
    update: XOR<WarehouseTransactionsUpdateWithoutInventoryInput, WarehouseTransactionsUncheckedUpdateWithoutInventoryInput>
    create: XOR<WarehouseTransactionsCreateWithoutInventoryInput, WarehouseTransactionsUncheckedCreateWithoutInventoryInput>
  }

  export type WarehouseTransactionsUpdateWithWhereUniqueWithoutInventoryInput = {
    where: WarehouseTransactionsWhereUniqueInput
    data: XOR<WarehouseTransactionsUpdateWithoutInventoryInput, WarehouseTransactionsUncheckedUpdateWithoutInventoryInput>
  }

  export type WarehouseTransactionsUpdateManyWithWhereWithoutInventoryInput = {
    where: WarehouseTransactionsScalarWhereInput
    data: XOR<WarehouseTransactionsUpdateManyMutationInput, WarehouseTransactionsUncheckedUpdateManyWithoutInventoryInput>
  }

  export type WarehouseTransactionsScalarWhereInput = {
    AND?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
    OR?: WarehouseTransactionsScalarWhereInput[]
    NOT?: WarehouseTransactionsScalarWhereInput | WarehouseTransactionsScalarWhereInput[]
    id?: IntFilter<"WarehouseTransactions"> | number
    inventoryId?: IntFilter<"WarehouseTransactions"> | number
    invoiceId?: IntFilter<"WarehouseTransactions"> | number
    count?: IntFilter<"WarehouseTransactions"> | number
  }

  export type ItemsCreateWithoutUnitInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    brand: BrandsCreateNestedOneWithoutItemsInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutUnitInput = {
    id?: number
    supplierId: number
    brandId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutUnitInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput>
  }

  export type ItemsCreateManyUnitInputEnvelope = {
    data: ItemsCreateManyUnitInput | ItemsCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ItemsUpsertWithWhereUniqueWithoutUnitInput = {
    where: ItemsWhereUniqueInput
    update: XOR<ItemsUpdateWithoutUnitInput, ItemsUncheckedUpdateWithoutUnitInput>
    create: XOR<ItemsCreateWithoutUnitInput, ItemsUncheckedCreateWithoutUnitInput>
  }

  export type ItemsUpdateWithWhereUniqueWithoutUnitInput = {
    where: ItemsWhereUniqueInput
    data: XOR<ItemsUpdateWithoutUnitInput, ItemsUncheckedUpdateWithoutUnitInput>
  }

  export type ItemsUpdateManyWithWhereWithoutUnitInput = {
    where: ItemsScalarWhereInput
    data: XOR<ItemsUpdateManyMutationInput, ItemsUncheckedUpdateManyWithoutUnitInput>
  }

  export type TermsCreateWithoutCustomersInput = {
    days: string
    Suppliers?: SuppliersCreateNestedManyWithoutTermsInput
  }

  export type TermsUncheckedCreateWithoutCustomersInput = {
    id?: number
    days: string
    Suppliers?: SuppliersUncheckedCreateNestedManyWithoutTermsInput
  }

  export type TermsCreateOrConnectWithoutCustomersInput = {
    where: TermsWhereUniqueInput
    create: XOR<TermsCreateWithoutCustomersInput, TermsUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerInvoicesCreateWithoutCustomerInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutInvoiceInput
    CounterReceipts?: CounterReceiptsCreateNestedOneWithoutCustomerInvoicesInput
  }

  export type CustomerInvoicesUncheckedCreateWithoutCustomerInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    counterReceiptsId?: number | null
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoicesCreateOrConnectWithoutCustomerInput = {
    where: CustomerInvoicesWhereUniqueInput
    create: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerInvoicesCreateManyCustomerInputEnvelope = {
    data: CustomerInvoicesCreateManyCustomerInput | CustomerInvoicesCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type CounterReceiptsCreateWithoutCustomersInput = {
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    CustomerInvoices?: CustomerInvoicesCreateNestedManyWithoutCounterReceiptsInput
  }

  export type CounterReceiptsUncheckedCreateWithoutCustomersInput = {
    id?: number
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    CustomerInvoices?: CustomerInvoicesUncheckedCreateNestedManyWithoutCounterReceiptsInput
  }

  export type CounterReceiptsCreateOrConnectWithoutCustomersInput = {
    where: CounterReceiptsWhereUniqueInput
    create: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput>
  }

  export type CounterReceiptsCreateManyCustomersInputEnvelope = {
    data: CounterReceiptsCreateManyCustomersInput | CounterReceiptsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type TermsUpsertWithoutCustomersInput = {
    update: XOR<TermsUpdateWithoutCustomersInput, TermsUncheckedUpdateWithoutCustomersInput>
    create: XOR<TermsCreateWithoutCustomersInput, TermsUncheckedCreateWithoutCustomersInput>
    where?: TermsWhereInput
  }

  export type TermsUpdateToOneWithWhereWithoutCustomersInput = {
    where?: TermsWhereInput
    data: XOR<TermsUpdateWithoutCustomersInput, TermsUncheckedUpdateWithoutCustomersInput>
  }

  export type TermsUpdateWithoutCustomersInput = {
    days?: StringFieldUpdateOperationsInput | string
    Suppliers?: SuppliersUpdateManyWithoutTermsNestedInput
  }

  export type TermsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    days?: StringFieldUpdateOperationsInput | string
    Suppliers?: SuppliersUncheckedUpdateManyWithoutTermsNestedInput
  }

  export type CustomerInvoicesUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerInvoicesWhereUniqueInput
    update: XOR<CustomerInvoicesUpdateWithoutCustomerInput, CustomerInvoicesUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerInvoicesCreateWithoutCustomerInput, CustomerInvoicesUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerInvoicesUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerInvoicesWhereUniqueInput
    data: XOR<CustomerInvoicesUpdateWithoutCustomerInput, CustomerInvoicesUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerInvoicesUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerInvoicesScalarWhereInput
    data: XOR<CustomerInvoicesUpdateManyMutationInput, CustomerInvoicesUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerInvoicesScalarWhereInput = {
    AND?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
    OR?: CustomerInvoicesScalarWhereInput[]
    NOT?: CustomerInvoicesScalarWhereInput | CustomerInvoicesScalarWhereInput[]
    id?: IntFilter<"CustomerInvoices"> | number
    customerId?: IntFilter<"CustomerInvoices"> | number
    invoiceNumber?: StringFilter<"CustomerInvoices"> | string
    invoiceDate?: DateTimeFilter<"CustomerInvoices"> | Date | string
    isfulfilled?: BoolFilter<"CustomerInvoices"> | boolean
    isCompleted?: BoolFilter<"CustomerInvoices"> | boolean
    totalAmount?: FloatFilter<"CustomerInvoices"> | number
    dateCreated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    dateUpdated?: DateTimeFilter<"CustomerInvoices"> | Date | string
    counterReceiptsId?: IntNullableFilter<"CustomerInvoices"> | number | null
  }

  export type CounterReceiptsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: CounterReceiptsWhereUniqueInput
    update: XOR<CounterReceiptsUpdateWithoutCustomersInput, CounterReceiptsUncheckedUpdateWithoutCustomersInput>
    create: XOR<CounterReceiptsCreateWithoutCustomersInput, CounterReceiptsUncheckedCreateWithoutCustomersInput>
  }

  export type CounterReceiptsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: CounterReceiptsWhereUniqueInput
    data: XOR<CounterReceiptsUpdateWithoutCustomersInput, CounterReceiptsUncheckedUpdateWithoutCustomersInput>
  }

  export type CounterReceiptsUpdateManyWithWhereWithoutCustomersInput = {
    where: CounterReceiptsScalarWhereInput
    data: XOR<CounterReceiptsUpdateManyMutationInput, CounterReceiptsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type CounterReceiptsScalarWhereInput = {
    AND?: CounterReceiptsScalarWhereInput | CounterReceiptsScalarWhereInput[]
    OR?: CounterReceiptsScalarWhereInput[]
    NOT?: CounterReceiptsScalarWhereInput | CounterReceiptsScalarWhereInput[]
    id?: IntFilter<"CounterReceipts"> | number
    totalAmount?: FloatFilter<"CounterReceipts"> | number
    dueDate?: DateTimeFilter<"CounterReceipts"> | Date | string
    dateCreated?: DateTimeFilter<"CounterReceipts"> | Date | string
    customerId?: IntNullableFilter<"CounterReceipts"> | number | null
  }

  export type CustomersCreateWithoutTermInput = {
    name: string
    address: string
    CustomerInvoices?: CustomerInvoicesCreateNestedManyWithoutCustomerInput
    CounterReceits?: CounterReceiptsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutTermInput = {
    id?: number
    name: string
    address: string
    CustomerInvoices?: CustomerInvoicesUncheckedCreateNestedManyWithoutCustomerInput
    CounterReceits?: CounterReceiptsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutTermInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput>
  }

  export type CustomersCreateManyTermInputEnvelope = {
    data: CustomersCreateManyTermInput | CustomersCreateManyTermInput[]
    skipDuplicates?: boolean
  }

  export type SuppliersCreateWithoutTermsInput = {
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersUncheckedCreateWithoutTermsInput = {
    id?: number
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsUncheckedCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutTermsInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput>
  }

  export type SuppliersCreateManyTermsInputEnvelope = {
    data: SuppliersCreateManyTermsInput | SuppliersCreateManyTermsInput[]
    skipDuplicates?: boolean
  }

  export type CustomersUpsertWithWhereUniqueWithoutTermInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutTermInput, CustomersUncheckedUpdateWithoutTermInput>
    create: XOR<CustomersCreateWithoutTermInput, CustomersUncheckedCreateWithoutTermInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutTermInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutTermInput, CustomersUncheckedUpdateWithoutTermInput>
  }

  export type CustomersUpdateManyWithWhereWithoutTermInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutTermInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    OR?: CustomersScalarWhereInput[]
    NOT?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    id?: IntFilter<"Customers"> | number
    name?: StringFilter<"Customers"> | string
    address?: StringFilter<"Customers"> | string
    termId?: IntFilter<"Customers"> | number
  }

  export type SuppliersUpsertWithWhereUniqueWithoutTermsInput = {
    where: SuppliersWhereUniqueInput
    update: XOR<SuppliersUpdateWithoutTermsInput, SuppliersUncheckedUpdateWithoutTermsInput>
    create: XOR<SuppliersCreateWithoutTermsInput, SuppliersUncheckedCreateWithoutTermsInput>
  }

  export type SuppliersUpdateWithWhereUniqueWithoutTermsInput = {
    where: SuppliersWhereUniqueInput
    data: XOR<SuppliersUpdateWithoutTermsInput, SuppliersUncheckedUpdateWithoutTermsInput>
  }

  export type SuppliersUpdateManyWithWhereWithoutTermsInput = {
    where: SuppliersScalarWhereInput
    data: XOR<SuppliersUpdateManyMutationInput, SuppliersUncheckedUpdateManyWithoutTermsInput>
  }

  export type SuppliersScalarWhereInput = {
    AND?: SuppliersScalarWhereInput | SuppliersScalarWhereInput[]
    OR?: SuppliersScalarWhereInput[]
    NOT?: SuppliersScalarWhereInput | SuppliersScalarWhereInput[]
    id?: IntFilter<"Suppliers"> | number
    name?: StringFilter<"Suppliers"> | string
    address?: StringFilter<"Suppliers"> | string
    termId?: IntFilter<"Suppliers"> | number
    createdAt?: DateTimeFilter<"Suppliers"> | Date | string
    updatedAt?: DateTimeFilter<"Suppliers"> | Date | string
  }

  export type InventoryCreateWithoutSupplierTransactionsInput = {
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehousesCreateNestedOneWithoutInventoriesInput
    item: ItemsCreateNestedOneWithoutInventoriesInput
    WarehouseTransactions?: WarehouseTransactionsCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutSupplierTransactionsInput = {
    id?: number
    warehouseId: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutSupplierTransactionsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutSupplierTransactionsInput, InventoryUncheckedCreateWithoutSupplierTransactionsInput>
  }

  export type ItemsCreateWithoutSupplierTransactionsInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    brand: BrandsCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutSupplierTransactionsInput = {
    id?: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutSupplierTransactionsInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutSupplierTransactionsInput, ItemsUncheckedCreateWithoutSupplierTransactionsInput>
  }

  export type SupplierInvoicesCreateWithoutTransactionsInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    supplier?: SuppliersCreateNestedOneWithoutInvoicesInput
    CheckVouchers?: CheckVouchersCreateNestedOneWithoutSupplierInvoicesInput
  }

  export type SupplierInvoicesUncheckedCreateWithoutTransactionsInput = {
    id?: number
    supplierId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    checkVouchersId?: number | null
  }

  export type SupplierInvoicesCreateOrConnectWithoutTransactionsInput = {
    where: SupplierInvoicesWhereUniqueInput
    create: XOR<SupplierInvoicesCreateWithoutTransactionsInput, SupplierInvoicesUncheckedCreateWithoutTransactionsInput>
  }

  export type InventoryUpsertWithoutSupplierTransactionsInput = {
    update: XOR<InventoryUpdateWithoutSupplierTransactionsInput, InventoryUncheckedUpdateWithoutSupplierTransactionsInput>
    create: XOR<InventoryCreateWithoutSupplierTransactionsInput, InventoryUncheckedCreateWithoutSupplierTransactionsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutSupplierTransactionsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutSupplierTransactionsInput, InventoryUncheckedUpdateWithoutSupplierTransactionsInput>
  }

  export type InventoryUpdateWithoutSupplierTransactionsInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehousesUpdateOneRequiredWithoutInventoriesNestedInput
    item?: ItemsUpdateOneRequiredWithoutInventoriesNestedInput
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutSupplierTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type ItemsUpsertWithoutSupplierTransactionsInput = {
    update: XOR<ItemsUpdateWithoutSupplierTransactionsInput, ItemsUncheckedUpdateWithoutSupplierTransactionsInput>
    create: XOR<ItemsCreateWithoutSupplierTransactionsInput, ItemsUncheckedCreateWithoutSupplierTransactionsInput>
    where?: ItemsWhereInput
  }

  export type ItemsUpdateToOneWithWhereWithoutSupplierTransactionsInput = {
    where?: ItemsWhereInput
    data: XOR<ItemsUpdateWithoutSupplierTransactionsInput, ItemsUncheckedUpdateWithoutSupplierTransactionsInput>
  }

  export type ItemsUpdateWithoutSupplierTransactionsInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutSupplierTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SupplierInvoicesUpsertWithoutTransactionsInput = {
    update: XOR<SupplierInvoicesUpdateWithoutTransactionsInput, SupplierInvoicesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<SupplierInvoicesCreateWithoutTransactionsInput, SupplierInvoicesUncheckedCreateWithoutTransactionsInput>
    where?: SupplierInvoicesWhereInput
  }

  export type SupplierInvoicesUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: SupplierInvoicesWhereInput
    data: XOR<SupplierInvoicesUpdateWithoutTransactionsInput, SupplierInvoicesUncheckedUpdateWithoutTransactionsInput>
  }

  export type SupplierInvoicesUpdateWithoutTransactionsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutInvoicesNestedInput
    CheckVouchers?: CheckVouchersUpdateOneWithoutSupplierInvoicesNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    checkVouchersId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SuppliersCreateWithoutInvoicesInput = {
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersCreateNestedManyWithoutSupplierInput
    Terms?: TermsCreateNestedOneWithoutSuppliersInput
  }

  export type SuppliersUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    address: string
    termId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsUncheckedCreateNestedManyWithoutSupplierInput
    CheckVouchers?: CheckVouchersUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutInvoicesInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutInvoicesInput, SuppliersUncheckedCreateWithoutInvoicesInput>
  }

  export type SupplierTransactionsCreateWithoutInvoiceInput = {
    quantity: number
    inventory: InventoryCreateNestedOneWithoutSupplierTransactionsInput
    item: ItemsCreateNestedOneWithoutSupplierTransactionsInput
  }

  export type SupplierTransactionsUncheckedCreateWithoutInvoiceInput = {
    id?: number
    itemId: number
    quantity: number
    inventoryId: number
  }

  export type SupplierTransactionsCreateOrConnectWithoutInvoiceInput = {
    where: SupplierTransactionsWhereUniqueInput
    create: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type SupplierTransactionsCreateManyInvoiceInputEnvelope = {
    data: SupplierTransactionsCreateManyInvoiceInput | SupplierTransactionsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CheckVouchersCreateWithoutSupplierInvoicesInput = {
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    Supplier?: SuppliersCreateNestedOneWithoutCheckVouchersInput
  }

  export type CheckVouchersUncheckedCreateWithoutSupplierInvoicesInput = {
    id?: number
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
    supplierId?: number | null
  }

  export type CheckVouchersCreateOrConnectWithoutSupplierInvoicesInput = {
    where: CheckVouchersWhereUniqueInput
    create: XOR<CheckVouchersCreateWithoutSupplierInvoicesInput, CheckVouchersUncheckedCreateWithoutSupplierInvoicesInput>
  }

  export type SuppliersUpsertWithoutInvoicesInput = {
    update: XOR<SuppliersUpdateWithoutInvoicesInput, SuppliersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SuppliersCreateWithoutInvoicesInput, SuppliersUncheckedCreateWithoutInvoicesInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutInvoicesInput, SuppliersUncheckedUpdateWithoutInvoicesInput>
  }

  export type SuppliersUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUpdateManyWithoutSupplierNestedInput
    Terms?: TermsUpdateOneWithoutSuppliersNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUncheckedUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierTransactionsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: SupplierTransactionsWhereUniqueInput
    update: XOR<SupplierTransactionsUpdateWithoutInvoiceInput, SupplierTransactionsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<SupplierTransactionsCreateWithoutInvoiceInput, SupplierTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type SupplierTransactionsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: SupplierTransactionsWhereUniqueInput
    data: XOR<SupplierTransactionsUpdateWithoutInvoiceInput, SupplierTransactionsUncheckedUpdateWithoutInvoiceInput>
  }

  export type SupplierTransactionsUpdateManyWithWhereWithoutInvoiceInput = {
    where: SupplierTransactionsScalarWhereInput
    data: XOR<SupplierTransactionsUpdateManyMutationInput, SupplierTransactionsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CheckVouchersUpsertWithoutSupplierInvoicesInput = {
    update: XOR<CheckVouchersUpdateWithoutSupplierInvoicesInput, CheckVouchersUncheckedUpdateWithoutSupplierInvoicesInput>
    create: XOR<CheckVouchersCreateWithoutSupplierInvoicesInput, CheckVouchersUncheckedCreateWithoutSupplierInvoicesInput>
    where?: CheckVouchersWhereInput
  }

  export type CheckVouchersUpdateToOneWithWhereWithoutSupplierInvoicesInput = {
    where?: CheckVouchersWhereInput
    data: XOR<CheckVouchersUpdateWithoutSupplierInvoicesInput, CheckVouchersUncheckedUpdateWithoutSupplierInvoicesInput>
  }

  export type CheckVouchersUpdateWithoutSupplierInvoicesInput = {
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    Supplier?: SuppliersUpdateOneWithoutCheckVouchersNestedInput
  }

  export type CheckVouchersUncheckedUpdateWithoutSupplierInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerInvoicesCreateWithoutCustmerTransactionsInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    customer?: CustomersCreateNestedOneWithoutCustomerInvoicesInput
    CounterReceipts?: CounterReceiptsCreateNestedOneWithoutCustomerInvoicesInput
  }

  export type CustomerInvoicesUncheckedCreateWithoutCustmerTransactionsInput = {
    id?: number
    customerId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    counterReceiptsId?: number | null
  }

  export type CustomerInvoicesCreateOrConnectWithoutCustmerTransactionsInput = {
    where: CustomerInvoicesWhereUniqueInput
    create: XOR<CustomerInvoicesCreateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedCreateWithoutCustmerTransactionsInput>
  }

  export type ItemsCreateWithoutCustmerTransactionsInput = {
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SuppliersCreateNestedOneWithoutItemsInput
    brand: BrandsCreateNestedOneWithoutItemsInput
    unit: UnitsCreateNestedOneWithoutItemInput
    inventories?: InventoryCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsCreateNestedManyWithoutItemInput
  }

  export type ItemsUncheckedCreateWithoutCustmerTransactionsInput = {
    id?: number
    supplierId: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutItemInput
    supplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemsCreateOrConnectWithoutCustmerTransactionsInput = {
    where: ItemsWhereUniqueInput
    create: XOR<ItemsCreateWithoutCustmerTransactionsInput, ItemsUncheckedCreateWithoutCustmerTransactionsInput>
  }

  export type CustomerInvoicesUpsertWithoutCustmerTransactionsInput = {
    update: XOR<CustomerInvoicesUpdateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedUpdateWithoutCustmerTransactionsInput>
    create: XOR<CustomerInvoicesCreateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedCreateWithoutCustmerTransactionsInput>
    where?: CustomerInvoicesWhereInput
  }

  export type CustomerInvoicesUpdateToOneWithWhereWithoutCustmerTransactionsInput = {
    where?: CustomerInvoicesWhereInput
    data: XOR<CustomerInvoicesUpdateWithoutCustmerTransactionsInput, CustomerInvoicesUncheckedUpdateWithoutCustmerTransactionsInput>
  }

  export type CustomerInvoicesUpdateWithoutCustmerTransactionsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    CounterReceipts?: CounterReceiptsUpdateOneWithoutCustomerInvoicesNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateWithoutCustmerTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    counterReceiptsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ItemsUpsertWithoutCustmerTransactionsInput = {
    update: XOR<ItemsUpdateWithoutCustmerTransactionsInput, ItemsUncheckedUpdateWithoutCustmerTransactionsInput>
    create: XOR<ItemsCreateWithoutCustmerTransactionsInput, ItemsUncheckedCreateWithoutCustmerTransactionsInput>
    where?: ItemsWhereInput
  }

  export type ItemsUpdateToOneWithWhereWithoutCustmerTransactionsInput = {
    where?: ItemsWhereInput
    data: XOR<ItemsUpdateWithoutCustmerTransactionsInput, ItemsUncheckedUpdateWithoutCustmerTransactionsInput>
  }

  export type ItemsUpdateWithoutCustmerTransactionsInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutCustmerTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type CustomersCreateWithoutCustomerInvoicesInput = {
    name: string
    address: string
    term: TermsCreateNestedOneWithoutCustomersInput
    CounterReceits?: CounterReceiptsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutCustomerInvoicesInput = {
    id?: number
    name: string
    address: string
    termId: number
    CounterReceits?: CounterReceiptsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutCustomerInvoicesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCustomerInvoicesInput, CustomersUncheckedCreateWithoutCustomerInvoicesInput>
  }

  export type CustomerTransactionsCreateWithoutInvoiceInput = {
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
    item: ItemsCreateNestedOneWithoutCustmerTransactionsInput
  }

  export type CustomerTransactionsUncheckedCreateWithoutInvoiceInput = {
    id?: number
    itemId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type CustomerTransactionsCreateOrConnectWithoutInvoiceInput = {
    where: CustomerTransactionsWhereUniqueInput
    create: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerTransactionsCreateManyInvoiceInputEnvelope = {
    data: CustomerTransactionsCreateManyInvoiceInput | CustomerTransactionsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CounterReceiptsCreateWithoutCustomerInvoicesInput = {
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    Customers?: CustomersCreateNestedOneWithoutCounterReceitsInput
  }

  export type CounterReceiptsUncheckedCreateWithoutCustomerInvoicesInput = {
    id?: number
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
    customerId?: number | null
  }

  export type CounterReceiptsCreateOrConnectWithoutCustomerInvoicesInput = {
    where: CounterReceiptsWhereUniqueInput
    create: XOR<CounterReceiptsCreateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedCreateWithoutCustomerInvoicesInput>
  }

  export type CustomersUpsertWithoutCustomerInvoicesInput = {
    update: XOR<CustomersUpdateWithoutCustomerInvoicesInput, CustomersUncheckedUpdateWithoutCustomerInvoicesInput>
    create: XOR<CustomersCreateWithoutCustomerInvoicesInput, CustomersUncheckedCreateWithoutCustomerInvoicesInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutCustomerInvoicesInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutCustomerInvoicesInput, CustomersUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type CustomersUpdateWithoutCustomerInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    term?: TermsUpdateOneRequiredWithoutCustomersNestedInput
    CounterReceits?: CounterReceiptsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCustomerInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    CounterReceits?: CounterReceiptsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomerTransactionsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerTransactionsWhereUniqueInput
    update: XOR<CustomerTransactionsUpdateWithoutInvoiceInput, CustomerTransactionsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<CustomerTransactionsCreateWithoutInvoiceInput, CustomerTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type CustomerTransactionsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: CustomerTransactionsWhereUniqueInput
    data: XOR<CustomerTransactionsUpdateWithoutInvoiceInput, CustomerTransactionsUncheckedUpdateWithoutInvoiceInput>
  }

  export type CustomerTransactionsUpdateManyWithWhereWithoutInvoiceInput = {
    where: CustomerTransactionsScalarWhereInput
    data: XOR<CustomerTransactionsUpdateManyMutationInput, CustomerTransactionsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CounterReceiptsUpsertWithoutCustomerInvoicesInput = {
    update: XOR<CounterReceiptsUpdateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedUpdateWithoutCustomerInvoicesInput>
    create: XOR<CounterReceiptsCreateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedCreateWithoutCustomerInvoicesInput>
    where?: CounterReceiptsWhereInput
  }

  export type CounterReceiptsUpdateToOneWithWhereWithoutCustomerInvoicesInput = {
    where?: CounterReceiptsWhereInput
    data: XOR<CounterReceiptsUpdateWithoutCustomerInvoicesInput, CounterReceiptsUncheckedUpdateWithoutCustomerInvoicesInput>
  }

  export type CounterReceiptsUpdateWithoutCustomerInvoicesInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    Customers?: CustomersUpdateOneWithoutCounterReceitsNestedInput
  }

  export type CounterReceiptsUncheckedUpdateWithoutCustomerInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InventoryCreateWithoutWarehouseTransactionsInput = {
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    warehouse: WarehousesCreateNestedOneWithoutInventoriesInput
    item: ItemsCreateNestedOneWithoutInventoriesInput
    SupplierTransactions?: SupplierTransactionsCreateNestedManyWithoutInventoryInput
  }

  export type InventoryUncheckedCreateWithoutWarehouseTransactionsInput = {
    id?: number
    warehouseId: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInventoryInput
  }

  export type InventoryCreateOrConnectWithoutWarehouseTransactionsInput = {
    where: InventoryWhereUniqueInput
    create: XOR<InventoryCreateWithoutWarehouseTransactionsInput, InventoryUncheckedCreateWithoutWarehouseTransactionsInput>
  }

  export type WarehouseInvoicesCreateWithoutWarehouseTransactionsInput = {
    targetWarehouseId: number
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
    Warehouses?: WarehousesCreateNestedOneWithoutInvoicesInput
  }

  export type WarehouseInvoicesUncheckedCreateWithoutWarehouseTransactionsInput = {
    id?: number
    targetWarehouseId: number
    warehouseId?: number | null
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
  }

  export type WarehouseInvoicesCreateOrConnectWithoutWarehouseTransactionsInput = {
    where: WarehouseInvoicesWhereUniqueInput
    create: XOR<WarehouseInvoicesCreateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedCreateWithoutWarehouseTransactionsInput>
  }

  export type InventoryUpsertWithoutWarehouseTransactionsInput = {
    update: XOR<InventoryUpdateWithoutWarehouseTransactionsInput, InventoryUncheckedUpdateWithoutWarehouseTransactionsInput>
    create: XOR<InventoryCreateWithoutWarehouseTransactionsInput, InventoryUncheckedCreateWithoutWarehouseTransactionsInput>
    where?: InventoryWhereInput
  }

  export type InventoryUpdateToOneWithWhereWithoutWarehouseTransactionsInput = {
    where?: InventoryWhereInput
    data: XOR<InventoryUpdateWithoutWarehouseTransactionsInput, InventoryUncheckedUpdateWithoutWarehouseTransactionsInput>
  }

  export type InventoryUpdateWithoutWarehouseTransactionsInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehousesUpdateOneRequiredWithoutInventoriesNestedInput
    item?: ItemsUpdateOneRequiredWithoutInventoriesNestedInput
    SupplierTransactions?: SupplierTransactionsUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutWarehouseTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type WarehouseInvoicesUpsertWithoutWarehouseTransactionsInput = {
    update: XOR<WarehouseInvoicesUpdateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedUpdateWithoutWarehouseTransactionsInput>
    create: XOR<WarehouseInvoicesCreateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedCreateWithoutWarehouseTransactionsInput>
    where?: WarehouseInvoicesWhereInput
  }

  export type WarehouseInvoicesUpdateToOneWithWhereWithoutWarehouseTransactionsInput = {
    where?: WarehouseInvoicesWhereInput
    data: XOR<WarehouseInvoicesUpdateWithoutWarehouseTransactionsInput, WarehouseInvoicesUncheckedUpdateWithoutWarehouseTransactionsInput>
  }

  export type WarehouseInvoicesUpdateWithoutWarehouseTransactionsInput = {
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Warehouses?: WarehousesUpdateOneWithoutInvoicesNestedInput
  }

  export type WarehouseInvoicesUncheckedUpdateWithoutWarehouseTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    warehouseId?: NullableIntFieldUpdateOperationsInput | number | null
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehousesCreateWithoutInvoicesInput = {
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryCreateNestedManyWithoutWarehouseInput
  }

  export type WarehousesUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inventories?: InventoryUncheckedCreateNestedManyWithoutWarehouseInput
  }

  export type WarehousesCreateOrConnectWithoutInvoicesInput = {
    where: WarehousesWhereUniqueInput
    create: XOR<WarehousesCreateWithoutInvoicesInput, WarehousesUncheckedCreateWithoutInvoicesInput>
  }

  export type WarehouseTransactionsCreateWithoutInvoiceInput = {
    count: number
    Inventory: InventoryCreateNestedOneWithoutWarehouseTransactionsInput
  }

  export type WarehouseTransactionsUncheckedCreateWithoutInvoiceInput = {
    id?: number
    inventoryId: number
    count: number
  }

  export type WarehouseTransactionsCreateOrConnectWithoutInvoiceInput = {
    where: WarehouseTransactionsWhereUniqueInput
    create: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type WarehouseTransactionsCreateManyInvoiceInputEnvelope = {
    data: WarehouseTransactionsCreateManyInvoiceInput | WarehouseTransactionsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type WarehousesUpsertWithoutInvoicesInput = {
    update: XOR<WarehousesUpdateWithoutInvoicesInput, WarehousesUncheckedUpdateWithoutInvoicesInput>
    create: XOR<WarehousesCreateWithoutInvoicesInput, WarehousesUncheckedCreateWithoutInvoicesInput>
    where?: WarehousesWhereInput
  }

  export type WarehousesUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: WarehousesWhereInput
    data: XOR<WarehousesUpdateWithoutInvoicesInput, WarehousesUncheckedUpdateWithoutInvoicesInput>
  }

  export type WarehousesUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehousesUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutWarehouseNestedInput
  }

  export type WarehouseTransactionsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: WarehouseTransactionsWhereUniqueInput
    update: XOR<WarehouseTransactionsUpdateWithoutInvoiceInput, WarehouseTransactionsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<WarehouseTransactionsCreateWithoutInvoiceInput, WarehouseTransactionsUncheckedCreateWithoutInvoiceInput>
  }

  export type WarehouseTransactionsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: WarehouseTransactionsWhereUniqueInput
    data: XOR<WarehouseTransactionsUpdateWithoutInvoiceInput, WarehouseTransactionsUncheckedUpdateWithoutInvoiceInput>
  }

  export type WarehouseTransactionsUpdateManyWithWhereWithoutInvoiceInput = {
    where: WarehouseTransactionsScalarWhereInput
    data: XOR<WarehouseTransactionsUpdateManyMutationInput, WarehouseTransactionsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type CustomerInvoicesCreateWithoutCounterReceiptsInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    customer?: CustomersCreateNestedOneWithoutCustomerInvoicesInput
    CustmerTransactions?: CustomerTransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput = {
    id?: number
    customerId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    CustmerTransactions?: CustomerTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type CustomerInvoicesCreateOrConnectWithoutCounterReceiptsInput = {
    where: CustomerInvoicesWhereUniqueInput
    create: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput>
  }

  export type CustomerInvoicesCreateManyCounterReceiptsInputEnvelope = {
    data: CustomerInvoicesCreateManyCounterReceiptsInput | CustomerInvoicesCreateManyCounterReceiptsInput[]
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutCounterReceitsInput = {
    name: string
    address: string
    term: TermsCreateNestedOneWithoutCustomersInput
    CustomerInvoices?: CustomerInvoicesCreateNestedManyWithoutCustomerInput
  }

  export type CustomersUncheckedCreateWithoutCounterReceitsInput = {
    id?: number
    name: string
    address: string
    termId: number
    CustomerInvoices?: CustomerInvoicesUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomersCreateOrConnectWithoutCounterReceitsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutCounterReceitsInput, CustomersUncheckedCreateWithoutCounterReceitsInput>
  }

  export type CustomerInvoicesUpsertWithWhereUniqueWithoutCounterReceiptsInput = {
    where: CustomerInvoicesWhereUniqueInput
    update: XOR<CustomerInvoicesUpdateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedUpdateWithoutCounterReceiptsInput>
    create: XOR<CustomerInvoicesCreateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedCreateWithoutCounterReceiptsInput>
  }

  export type CustomerInvoicesUpdateWithWhereUniqueWithoutCounterReceiptsInput = {
    where: CustomerInvoicesWhereUniqueInput
    data: XOR<CustomerInvoicesUpdateWithoutCounterReceiptsInput, CustomerInvoicesUncheckedUpdateWithoutCounterReceiptsInput>
  }

  export type CustomerInvoicesUpdateManyWithWhereWithoutCounterReceiptsInput = {
    where: CustomerInvoicesScalarWhereInput
    data: XOR<CustomerInvoicesUpdateManyMutationInput, CustomerInvoicesUncheckedUpdateManyWithoutCounterReceiptsInput>
  }

  export type CustomersUpsertWithoutCounterReceitsInput = {
    update: XOR<CustomersUpdateWithoutCounterReceitsInput, CustomersUncheckedUpdateWithoutCounterReceitsInput>
    create: XOR<CustomersCreateWithoutCounterReceitsInput, CustomersUncheckedCreateWithoutCounterReceitsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutCounterReceitsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutCounterReceitsInput, CustomersUncheckedUpdateWithoutCounterReceitsInput>
  }

  export type CustomersUpdateWithoutCounterReceitsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    term?: TermsUpdateOneRequiredWithoutCustomersNestedInput
    CustomerInvoices?: CustomerInvoicesUpdateManyWithoutCustomerNestedInput
  }

  export type CustomersUncheckedUpdateWithoutCounterReceitsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    CustomerInvoices?: CustomerInvoicesUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type SupplierInvoicesCreateWithoutCheckVouchersInput = {
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    supplier?: SuppliersCreateNestedOneWithoutInvoicesInput
    Transactions?: SupplierTransactionsCreateNestedManyWithoutInvoiceInput
  }

  export type SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput = {
    id?: number
    supplierId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    Transactions?: SupplierTransactionsUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type SupplierInvoicesCreateOrConnectWithoutCheckVouchersInput = {
    where: SupplierInvoicesWhereUniqueInput
    create: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput>
  }

  export type SupplierInvoicesCreateManyCheckVouchersInputEnvelope = {
    data: SupplierInvoicesCreateManyCheckVouchersInput | SupplierInvoicesCreateManyCheckVouchersInput[]
    skipDuplicates?: boolean
  }

  export type SuppliersCreateWithoutCheckVouchersInput = {
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesCreateNestedManyWithoutSupplierInput
    Terms?: TermsCreateNestedOneWithoutSuppliersInput
  }

  export type SuppliersUncheckedCreateWithoutCheckVouchersInput = {
    id?: number
    name: string
    address: string
    termId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ItemsUncheckedCreateNestedManyWithoutSupplierInput
    Invoices?: SupplierInvoicesUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SuppliersCreateOrConnectWithoutCheckVouchersInput = {
    where: SuppliersWhereUniqueInput
    create: XOR<SuppliersCreateWithoutCheckVouchersInput, SuppliersUncheckedCreateWithoutCheckVouchersInput>
  }

  export type SupplierInvoicesUpsertWithWhereUniqueWithoutCheckVouchersInput = {
    where: SupplierInvoicesWhereUniqueInput
    update: XOR<SupplierInvoicesUpdateWithoutCheckVouchersInput, SupplierInvoicesUncheckedUpdateWithoutCheckVouchersInput>
    create: XOR<SupplierInvoicesCreateWithoutCheckVouchersInput, SupplierInvoicesUncheckedCreateWithoutCheckVouchersInput>
  }

  export type SupplierInvoicesUpdateWithWhereUniqueWithoutCheckVouchersInput = {
    where: SupplierInvoicesWhereUniqueInput
    data: XOR<SupplierInvoicesUpdateWithoutCheckVouchersInput, SupplierInvoicesUncheckedUpdateWithoutCheckVouchersInput>
  }

  export type SupplierInvoicesUpdateManyWithWhereWithoutCheckVouchersInput = {
    where: SupplierInvoicesScalarWhereInput
    data: XOR<SupplierInvoicesUpdateManyMutationInput, SupplierInvoicesUncheckedUpdateManyWithoutCheckVouchersInput>
  }

  export type SuppliersUpsertWithoutCheckVouchersInput = {
    update: XOR<SuppliersUpdateWithoutCheckVouchersInput, SuppliersUncheckedUpdateWithoutCheckVouchersInput>
    create: XOR<SuppliersCreateWithoutCheckVouchersInput, SuppliersUncheckedCreateWithoutCheckVouchersInput>
    where?: SuppliersWhereInput
  }

  export type SuppliersUpdateToOneWithWhereWithoutCheckVouchersInput = {
    where?: SuppliersWhereInput
    data: XOR<SuppliersUpdateWithoutCheckVouchersInput, SuppliersUncheckedUpdateWithoutCheckVouchersInput>
  }

  export type SuppliersUpdateWithoutCheckVouchersInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUpdateManyWithoutSupplierNestedInput
    Terms?: TermsUpdateOneWithoutSuppliersNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutCheckVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    termId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUncheckedUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyItemInput = {
    id?: number
    warehouseId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierTransactionsCreateManyItemInput = {
    id?: number
    invoiceId: number
    quantity: number
    inventoryId: number
  }

  export type CustomerTransactionsCreateManyItemInput = {
    id?: number
    invoiceId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type InventoryUpdateWithoutItemInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    warehouse?: WarehousesUpdateOneRequiredWithoutInventoriesNestedInput
    SupplierTransactions?: SupplierTransactionsUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    warehouseId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierTransactionsUpdateWithoutItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    inventory?: InventoryUpdateOneRequiredWithoutSupplierTransactionsNestedInput
    invoice?: SupplierInvoicesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type SupplierTransactionsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerTransactionsUpdateWithoutItemInput = {
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
    invoice?: CustomerInvoicesUpdateOneRequiredWithoutCustmerTransactionsNestedInput
  }

  export type CustomerTransactionsUncheckedUpdateWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerTransactionsUncheckedUpdateManyWithoutItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ItemsCreateManySupplierInput = {
    id?: number
    brandId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierInvoicesCreateManySupplierInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    checkVouchersId?: number | null
  }

  export type CheckVouchersCreateManySupplierInput = {
    id?: number
    discount?: number
    totalAmount: number
    bank?: string
    checkNumber?: string
    dueDate: Date | string
    dateCreated?: Date | string
  }

  export type ItemsUpdateWithoutSupplierInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoicesUpdateWithoutSupplierInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Transactions?: SupplierTransactionsUpdateManyWithoutInvoiceNestedInput
    CheckVouchers?: CheckVouchersUpdateOneWithoutSupplierInvoicesNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    checkVouchersId?: NullableIntFieldUpdateOperationsInput | number | null
    Transactions?: SupplierTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    checkVouchersId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CheckVouchersUpdateWithoutSupplierInput = {
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierInvoices?: SupplierInvoicesUpdateManyWithoutCheckVouchersNestedInput
  }

  export type CheckVouchersUncheckedUpdateWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierInvoices?: SupplierInvoicesUncheckedUpdateManyWithoutCheckVouchersNestedInput
  }

  export type CheckVouchersUncheckedUpdateManyWithoutSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    discount?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    bank?: StringFieldUpdateOperationsInput | string
    checkNumber?: StringFieldUpdateOperationsInput | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemsCreateManyBrandInput = {
    id?: number
    supplierId: number
    unitId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemsUpdateWithoutBrandInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    unit?: UnitsUpdateOneRequiredWithoutItemNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateManyWithoutBrandInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    unitId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryCreateManyWarehouseInput = {
    id?: number
    itemId: number
    count: number
    price?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WarehouseInvoicesCreateManyWarehousesInput = {
    id?: number
    targetWarehouseId: number
    isFullfilled?: boolean
    dateCreated?: Date | string
    dateUpdated?: Date | string
  }

  export type InventoryUpdateWithoutWarehouseInput = {
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemsUpdateOneRequiredWithoutInventoriesNestedInput
    SupplierTransactions?: SupplierTransactionsUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SupplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInventoryNestedInput
  }

  export type InventoryUncheckedUpdateManyWithoutWarehouseInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WarehouseInvoicesUpdateWithoutWarehousesInput = {
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    WarehouseTransactions?: WarehouseTransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type WarehouseInvoicesUncheckedUpdateWithoutWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    WarehouseTransactions?: WarehouseTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type WarehouseInvoicesUncheckedUpdateManyWithoutWarehousesInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetWarehouseId?: IntFieldUpdateOperationsInput | number
    isFullfilled?: BoolFieldUpdateOperationsInput | boolean
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierTransactionsCreateManyInventoryInput = {
    id?: number
    invoiceId: number
    itemId: number
    quantity: number
  }

  export type WarehouseTransactionsCreateManyInventoryInput = {
    id?: number
    invoiceId: number
    count: number
  }

  export type SupplierTransactionsUpdateWithoutInventoryInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    item?: ItemsUpdateOneRequiredWithoutSupplierTransactionsNestedInput
    invoice?: SupplierInvoicesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type SupplierTransactionsUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseTransactionsUpdateWithoutInventoryInput = {
    count?: IntFieldUpdateOperationsInput | number
    Invoice?: WarehouseInvoicesUpdateOneRequiredWithoutWarehouseTransactionsNestedInput
  }

  export type WarehouseTransactionsUncheckedUpdateWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseTransactionsUncheckedUpdateManyWithoutInventoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type ItemsCreateManyUnitInput = {
    id?: number
    supplierId: number
    brandId: number
    desc1: string
    desc2: string
    desc3: string
    discount1?: number
    discount2?: number
    discount3?: number
    discount4?: number
    store?: number
    cal1: number
    cal2: number
    cal3: number
    ws1: number
    ws2: number
    ws3: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemsUpdateWithoutUnitInput = {
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutItemsNestedInput
    brand?: BrandsUpdateOneRequiredWithoutItemsNestedInput
    inventories?: InventoryUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventories?: InventoryUncheckedUpdateManyWithoutItemNestedInput
    supplierTransactions?: SupplierTransactionsUncheckedUpdateManyWithoutItemNestedInput
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemsUncheckedUpdateManyWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    brandId?: IntFieldUpdateOperationsInput | number
    desc1?: StringFieldUpdateOperationsInput | string
    desc2?: StringFieldUpdateOperationsInput | string
    desc3?: StringFieldUpdateOperationsInput | string
    discount1?: FloatFieldUpdateOperationsInput | number
    discount2?: FloatFieldUpdateOperationsInput | number
    discount3?: FloatFieldUpdateOperationsInput | number
    discount4?: FloatFieldUpdateOperationsInput | number
    store?: FloatFieldUpdateOperationsInput | number
    cal1?: FloatFieldUpdateOperationsInput | number
    cal2?: FloatFieldUpdateOperationsInput | number
    cal3?: FloatFieldUpdateOperationsInput | number
    ws1?: FloatFieldUpdateOperationsInput | number
    ws2?: FloatFieldUpdateOperationsInput | number
    ws3?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerInvoicesCreateManyCustomerInput = {
    id?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
    counterReceiptsId?: number | null
  }

  export type CounterReceiptsCreateManyCustomersInput = {
    id?: number
    totalAmount: number
    dueDate: Date | string
    dateCreated?: Date | string
  }

  export type CustomerInvoicesUpdateWithoutCustomerInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutInvoiceNestedInput
    CounterReceipts?: CounterReceiptsUpdateOneWithoutCustomerInvoicesNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    counterReceiptsId?: NullableIntFieldUpdateOperationsInput | number | null
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    counterReceiptsId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CounterReceiptsUpdateWithoutCustomersInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerInvoices?: CustomerInvoicesUpdateManyWithoutCounterReceiptsNestedInput
  }

  export type CounterReceiptsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    CustomerInvoices?: CustomerInvoicesUncheckedUpdateManyWithoutCounterReceiptsNestedInput
  }

  export type CounterReceiptsUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomersCreateManyTermInput = {
    id?: number
    name: string
    address: string
  }

  export type SuppliersCreateManyTermsInput = {
    id?: number
    name: string
    address: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomersUpdateWithoutTermInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    CustomerInvoices?: CustomerInvoicesUpdateManyWithoutCustomerNestedInput
    CounterReceits?: CounterReceiptsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutTermInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    CustomerInvoices?: CustomerInvoicesUncheckedUpdateManyWithoutCustomerNestedInput
    CounterReceits?: CounterReceiptsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutTermInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
  }

  export type SuppliersUpdateWithoutTermsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ItemsUncheckedUpdateManyWithoutSupplierNestedInput
    Invoices?: SupplierInvoicesUncheckedUpdateManyWithoutSupplierNestedInput
    CheckVouchers?: CheckVouchersUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SuppliersUncheckedUpdateManyWithoutTermsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierTransactionsCreateManyInvoiceInput = {
    id?: number
    itemId: number
    quantity: number
    inventoryId: number
  }

  export type SupplierTransactionsUpdateWithoutInvoiceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    inventory?: InventoryUpdateOneRequiredWithoutSupplierTransactionsNestedInput
    item?: ItemsUpdateOneRequiredWithoutSupplierTransactionsNestedInput
  }

  export type SupplierTransactionsUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierTransactionsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerTransactionsCreateManyInvoiceInput = {
    id?: number
    itemId: number
    customerPrice: number
    storePrice?: number
    quantity: number
    supplied: number
    isDiscounted?: boolean
  }

  export type CustomerTransactionsUpdateWithoutInvoiceInput = {
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
    item?: ItemsUpdateOneRequiredWithoutCustmerTransactionsNestedInput
  }

  export type CustomerTransactionsUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomerTransactionsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    itemId?: IntFieldUpdateOperationsInput | number
    customerPrice?: FloatFieldUpdateOperationsInput | number
    storePrice?: FloatFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    supplied?: IntFieldUpdateOperationsInput | number
    isDiscounted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WarehouseTransactionsCreateManyInvoiceInput = {
    id?: number
    inventoryId: number
    count: number
  }

  export type WarehouseTransactionsUpdateWithoutInvoiceInput = {
    count?: IntFieldUpdateOperationsInput | number
    Inventory?: InventoryUpdateOneRequiredWithoutWarehouseTransactionsNestedInput
  }

  export type WarehouseTransactionsUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type WarehouseTransactionsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    inventoryId?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type CustomerInvoicesCreateManyCounterReceiptsInput = {
    id?: number
    customerId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    isCompleted?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
  }

  export type CustomerInvoicesUpdateWithoutCounterReceiptsInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomersUpdateOneRequiredWithoutCustomerInvoicesNestedInput
    CustmerTransactions?: CustomerTransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateWithoutCounterReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    CustmerTransactions?: CustomerTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type CustomerInvoicesUncheckedUpdateManyWithoutCounterReceiptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierInvoicesCreateManyCheckVouchersInput = {
    id?: number
    supplierId?: number
    invoiceNumber: string
    invoiceDate: Date | string
    isfulfilled?: boolean
    totalAmount?: number
    dateCreated?: Date | string
    dateUpdated?: Date | string
  }

  export type SupplierInvoicesUpdateWithoutCheckVouchersInput = {
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SuppliersUpdateOneRequiredWithoutInvoicesNestedInput
    Transactions?: SupplierTransactionsUpdateManyWithoutInvoiceNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateWithoutCheckVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    Transactions?: SupplierTransactionsUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type SupplierInvoicesUncheckedUpdateManyWithoutCheckVouchersInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierId?: IntFieldUpdateOperationsInput | number
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isfulfilled?: BoolFieldUpdateOperationsInput | boolean
    totalAmount?: FloatFieldUpdateOperationsInput | number
    dateCreated?: DateTimeFieldUpdateOperationsInput | Date | string
    dateUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemsCountOutputTypeDefaultArgs instead
     */
    export type ItemsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuppliersCountOutputTypeDefaultArgs instead
     */
    export type SuppliersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuppliersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsCountOutputTypeDefaultArgs instead
     */
    export type BrandsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehousesCountOutputTypeDefaultArgs instead
     */
    export type WarehousesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehousesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryCountOutputTypeDefaultArgs instead
     */
    export type InventoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitsCountOutputTypeDefaultArgs instead
     */
    export type UnitsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomersCountOutputTypeDefaultArgs instead
     */
    export type CustomersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TermsCountOutputTypeDefaultArgs instead
     */
    export type TermsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TermsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierInvoicesCountOutputTypeDefaultArgs instead
     */
    export type SupplierInvoicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierInvoicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerInvoicesCountOutputTypeDefaultArgs instead
     */
    export type CustomerInvoicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerInvoicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseInvoicesCountOutputTypeDefaultArgs instead
     */
    export type WarehouseInvoicesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseInvoicesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounterReceiptsCountOutputTypeDefaultArgs instead
     */
    export type CounterReceiptsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounterReceiptsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckVouchersCountOutputTypeDefaultArgs instead
     */
    export type CheckVouchersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckVouchersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemsDefaultArgs instead
     */
    export type ItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SuppliersDefaultArgs instead
     */
    export type SuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SuppliersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BrandsDefaultArgs instead
     */
    export type BrandsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BrandsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehousesDefaultArgs instead
     */
    export type WarehousesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehousesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryDefaultArgs instead
     */
    export type InventoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UnitsDefaultArgs instead
     */
    export type UnitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UnitsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomersDefaultArgs instead
     */
    export type CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TermsDefaultArgs instead
     */
    export type TermsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TermsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierTransactionsDefaultArgs instead
     */
    export type SupplierTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierTransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierInvoicesDefaultArgs instead
     */
    export type SupplierInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierInvoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerTransactionsDefaultArgs instead
     */
    export type CustomerTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerTransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerInvoicesDefaultArgs instead
     */
    export type CustomerInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerInvoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseTransactionsDefaultArgs instead
     */
    export type WarehouseTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseTransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WarehouseInvoicesDefaultArgs instead
     */
    export type WarehouseInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WarehouseInvoicesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CounterReceiptsDefaultArgs instead
     */
    export type CounterReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CounterReceiptsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckVouchersDefaultArgs instead
     */
    export type CheckVouchersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckVouchersDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}